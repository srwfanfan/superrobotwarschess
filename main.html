<!DOCTYPE html><html lang="zh-TW"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://qph.cf2.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content; report-uri https://www.quora.com/poe_api/csp_report_3RD_PARTY_POST; report-to csp-endpoint;">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超級機械人大戰Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'primary': '#5D5CDE',
                        'board-light': '#f0d9b5',
                        'board-dark': '#b58863',
                        'highlight': 'rgba(93, 92, 222, 0.5)',
                        'valid-move': 'rgba(0, 255, 0, 0.3)',
                        'attack-move': 'rgba(255, 0, 0, 0.3)'
                    }
                }
            }
        }
    </script>
    <style>
        /* Cover Page 樣式 */
        .cover-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000428, #004e92);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }
        
        .cover-page.hide {
            opacity: 0;
            pointer-events: none;
        }
        
        .cover-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: white;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            }
            to {
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(93, 92, 222, 0.6);
            }
        }
        
        .cover-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 300px;
        }
        
        .cover-button {
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            backdrop-filter: blur(5px);
        }
        
        .cover-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Loading 樣式 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .loading-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: white;
            text-align: center;
        }
        
        .loading-container {
            width: 80%;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .loading-bar {
            height: 20px;
            width: 0%;
            background: linear-gradient(90deg, #5D5CDE, #9381FF);
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .loading-percentage {
            color: white;
            margin-top: 0.5rem;
            font-size: 1rem;
        }
        
        .loading-time {
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.25rem;
            font-size: 0.875rem;
        }
        
        /* 多人模式設置頁面 */
        .multiplayer-setup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000428, #004e92);
            z-index: 1001;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .multiplayer-setup.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .multiplayer-container {
            width: 90%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
        }
        
        .multiplayer-title {
            font-size: 1.75rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: white;
            text-align: center;
        }
        
        .multiplayer-actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .multiplayer-tab {
            flex: 1;
            padding: 0.75rem;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .active-tab {
            background: rgba(93, 92, 222, 0.5);
            color: white;
        }
        
        .inactive-tab {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .multiplayer-content {
            margin-top: 1rem;
        }
        
        .create-room-panel, .join-room-panel {
            display: none;
        }
        
        .show-panel {
            display: block;
        }
        
        .room-input-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .room-input {
            flex: 1;
            padding: 0.75rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 1rem;
        }
        
        .room-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .room-btn {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background: rgba(93, 92, 222, 0.7);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .room-btn:hover {
            background: rgba(93, 92, 222, 0.9);
        }
        
        .multiplayer-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
        }
        
        .back-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .connection-status {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 1rem;
            text-align: center;
        }
        
        /* 重置確認對話框 */
        .reset-confirm {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1002;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .reset-confirm.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .reset-dialog {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            max-width: 90%;
            width: 400px;
            text-align: center;
        }
        
        .reset-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
        }
        
        .reset-message {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            color: #555;
        }
        
        .reset-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .reset-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .confirm-btn {
            background: #5D5CDE;
            color: white;
        }
        
        .confirm-btn:hover {
            background: #4A49B0;
        }
        
        .cancel-btn {
            background: #f3f4f6;
            color: #333;
        }
        
        .cancel-btn:hover {
            background: #e5e7eb;
        }
        
        .waiting-status {
            display: none;
            margin-top: 1rem;
            font-size: 0.875rem;
            color: #5D5CDE;
        }
        
        /* 星空背景 */
        .space-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }
        
        .star {
            position: absolute;
            width: 1px;
            height: 1px;
            background: white;
            border-radius: 50%;
        }
        
        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 50%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transform-origin: right center;
            animation: shoot 3s ease-out infinite;
        }
        
        @keyframes shoot {
            0% {
                opacity: 0;
                transform: translateX(0) rotate(0deg);
            }
            15% {
                opacity: 1;
            }
            30% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
        }
        
        /* 遊戲內樣式 */
        /* 勝利告示樣式 */
        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            visibility: hidden;
        }
        
        .victory-overlay.show {
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }
        
        .victory-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            max-width: 90%;
            width: 600px;
            transform: scale(0.8);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }
        
        .victory-overlay.show .victory-card {
            transform: scale(1);
        }
        
        .victory-card::before {
            content: '';
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            background: linear-gradient(
                135deg,
                transparent,
                rgba(255, 255, 255, 0.05),
                transparent,
                transparent
            );
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }
        
        @keyframes shine {
            0% {
                left: -100%;
                top: -100%;
            }
            50%, 100% {
                left: 100%;
                top: 100%;
            }
        }
        
        .victory-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px currentColor;
            animation: pulse 2s infinite;
        }
        
        .blue-victory {
            color: #4169E1;
            background: linear-gradient(135deg, #000428, #004e92);
        }
        
        .blue-victory .victory-title {
            color: #4169E1;
        }
        
        .red-victory {
            color: #DC143C;
            background: linear-gradient(135deg, #16222A, #3A1C71);
        }
        
        .red-victory .victory-title {
            color: #DC143C;
        }
        
        .victory-message {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: white;
        }
        
        .victory-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }
        
        @keyframes bounce {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(-20px);
            }
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
            50% {
                opacity: 0.8;
                text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
        }
        
        .victory-reset {
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        
        .victory-reset:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .victory-confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            opacity: 0.7;
            animation: confetti-fall linear forwards;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh)) rotate(90deg);
                opacity: 0;
            }
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
        }
        
        .chess-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        
        .piece-img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            position: relative;
            z-index: 10;
            transition: all 0.2s ease;
            /* 移除 pointer-events: none 以允許滑鼠事件 */
        }
        
        /* 棋子遮罩樣式 */
        .piece-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 11;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none;
        }
        
        .blue-overlay {
            background-color: rgba(0, 0, 255, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
        }
        
        .red-overlay {
            background-color: rgba(255, 0, 0, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            transform: scaleX(-1); /* 水平翻轉 */
        }
        
        .valid-move-indicator {
            position: absolute;
            width: 40%;
            height: 40%;
            border-radius: 50%;
            opacity: 0.7;
            z-index: 5;
        }
        
        .coordinate {
            position: absolute;
            font-size: 0.7rem;
            opacity: 0;  /* Hide coordinates */
            z-index: 5;
            display: none; /* Ensure they're not visible */
        }
        
        .top-left {
            top: 2px;
            left: 2px;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .selected {
            animation: blink 1s infinite;
            box-shadow: inset 0 0 0 4px rgba(93, 92, 222, 0.7);
        }
        
        /* 在亮模式和暗模式下使用相同的棋盤背景圖 */
        .chess-board {
            background-image: url('https://i.imgur.com/po1uZL5.png');
            background-size: cover;
            background-position: center;
        }
        
        .chess-board .light, .chess-board .dark,
        .dark .chess-board .light, .dark .chess-board .dark {
            background-color: transparent;
        }
        
        .turn-indicator {
            width: 20px;
            height: 20px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        .connecting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #network-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50;
        }
        
        /* Loader animation */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #5D5CDE;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        /* Shooting minigame styles */
        .combat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .combat-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 25px rgba(93, 92, 222, 0.8);
            cursor: default;
        }
        
        /* Combat info panel - NEW! */
        .combat-info-panel {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 800px;
            height: auto;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 15px rgba(93, 92, 222, 0.6);
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .attacker-info, .defender-info {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            position: relative;
            height: 80px;
        }
        
        .attacker-info {
            background: linear-gradient(to bottom, rgba(255,0,85,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .defender-info {
            background: linear-gradient(to top, rgba(0,255,200,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .unit-image {
            height: 80px;
            width: 80px;
            object-fit: contain;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.7));
        }
        
        .unit-stats {
            display: flex;
            flex-direction: column;
            margin: 0 10px;
            color: white;
        }
        
        .unit-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        .stat-bar {
            width: 150px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            margin: 3px 0;
            overflow: hidden;
            position: relative;
        }
        
        .hit-stat {
            background: linear-gradient(90deg, #FF1493 0%, #FF69B4 100%);
        }
        
        .dodge-stat {
            background: linear-gradient(90deg, #00CED1 0%, #40E0D0 100%);
        }
        
        /* VS badge removed as requested */
        
        .attacker-role, .defender-role {
            position: absolute;
            top: -40px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        .attacker-role {
            left: 10px;
            background: linear-gradient(90deg, #FF1493 0%, #C71585 100%);
        }
        
        .defender-role {
            right: 10px;
            background: linear-gradient(90deg, #20B2AA 0%, #5F9EA0 100%);
        }
        
        .attacker-instruction, .defender-instruction {
            position: absolute;
            bottom: 10px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            width: 45%;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .attacker-instruction {
            left: 10px;
        }
        
        .defender-instruction {
            right: 10px;
        }
        
        .space-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000033, #000011);
            overflow: hidden;
        }
        
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
        }
        
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(10px);
            opacity: 0.2;
        }
        
        .combat-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .timer {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            z-index: 10;
            background: linear-gradient(135deg, #ff0099, #493240);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,0,153,0.5);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }
        
        .crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-horizontal, .crosshair-vertical {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0) 100%);
        }
        
        .crosshair-horizontal {
            top: 50%;
            left: 0;
            height: 4px; /* Increased thickness */
            transform: translateY(-50%);
        }
        
        .crosshair-vertical {
            top: 0;
            left: 50%;
            width: 4px; /* Increased thickness */
            transform: translateX(-50%);
        }
        
        .crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: rgba(255, 20, 147, 0.5);
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .defender {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 8;
            transition: top 0.05s linear, left 0.05s linear;
        }
        
        .defender img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(0,255,200,0.7));
        }
        
        .defender-target {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px dashed rgba(0, 255, 200, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 7;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 10px rgba(0,255,200,0.5);
            animation: targetPulse 1.5s infinite;
        }
        
        @keyframes targetPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Enhanced Laser effects */
        .laser {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0.5) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0.5) 100%);
            transform-origin: center left;
            z-index: 9;
            opacity: 0;
            animation: laser-pulse 0.3s ease-out;
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
        }
        
        .laser-glow {
            position: absolute;
            background: rgba(255,20,147,0.1);
            transform-origin: center left;
            z-index: 8;
            opacity: 0;
            animation: laser-glow 0.5s ease-out;
            filter: blur(10px);
        }
        
        @keyframes laser-pulse {
            0% { opacity: 0.7; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes laser-glow {
            0% { opacity: 0.3; transform: scale(1, 3); }
            50% { opacity: 0.5; transform: scale(1, 5); }
            100% { opacity: 0; transform: scale(1, 2); }
        }
        
        /* Enhanced Explosion effect */
        .explosion {
            position: absolute;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,105,180,0.8) 30%, rgba(255,20,147,0.6) 70%, rgba(0,0,0,0) 100%);
            z-index: 20;
            transform: translate(-50%, -50%);
            animation: explode 0.6s forwards;
            box-shadow: 0 0 30px #FF1493, 0 0 60px #FF1493;
        }
        
        @keyframes explode {
            0% { width: 0; height: 0; opacity: 1; }
            70% { opacity: 1; }
            100% { width: 250px; height: 250px; opacity: 0; }
        }
        
        /* Spark particles */
        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            z-index: 19;
            opacity: 1;
            box-shadow: 0 0 5px currentColor;
        }
        
        /* Combat result */
        .combat-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 0 30px rgba(255,20,147,0.7);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }
        
        .combat-result.show {
            opacity: 1;
            animation: resultPulse 2s infinite;
        }
        
        @keyframes resultPulse {
            0% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
            50% { box-shadow: 0 0 50px rgba(255,20,147,1); }
            100% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
        }
        
        /* 增加遊戲畫面響應式設計 */
        @media (max-width: 768px) {
            .cover-title {
                font-size: 2rem;
            }
            
            .cover-buttons {
                max-width: 250px;
            }
            
            .multiplayer-container {
                padding: 1.5rem;
            }
            
            .multiplayer-title {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen p-4">
    <!-- Cover Page -->
    <div id="cover-page" class="cover-page">
        <div class="space-bg" id="cover-space-bg"></div>
        <div class="cover-logo-container" style="display: flex; justify-content: center; width: 100%;">
            <img src="https://i.imgur.com/ve99gPQ.png" alt="超級機械人大戰Chess" class="cover-logo" style="max-width: 90%; height: auto; margin-bottom: 2rem;">
        </div>
        <div class="cover-buttons">
            <button id="singleplayer-cover-btn" class="cover-button">開始遊戲</button>
            <!-- 多人模式按鈕已被隱藏 -->
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <h2 class="loading-title">載入遊戲資源中...</h2>
        <div class="loading-container">
            <div id="loading-bar" class="loading-bar"></div>
        </div>
        <div id="loading-percentage" class="loading-percentage">0%</div>
        <div id="loading-time" class="loading-time">預計剩餘時間: 計算中...</div>
    </div>
    
    <!-- Multiplayer Setup -->
    <div id="multiplayer-setup" class="multiplayer-setup">
        <div class="multiplayer-container">
            <h2 class="multiplayer-title">多人遊戲設置</h2>
            
            <div class="multiplayer-actions">
                <div id="create-tab" class="multiplayer-tab active-tab">創建房間</div>
                <div id="join-tab" class="multiplayer-tab inactive-tab">加入房間</div>
            </div>
            
            <div class="multiplayer-content">
                <div id="create-room-panel" class="create-room-panel show-panel">
                    <label class="block text-white mb-2">您的房間ID:</label>
                    <div class="room-input-group">
                        <input type="text" id="my-room-id" readonly="" class="room-input" placeholder="正在生成房間ID...">
                        <button id="copy-id-btn" class="room-btn">複製</button>
                    </div>
                    <p class="text-white text-sm mt-2">將此ID分享給您的對手，讓他們加入您的遊戲。</p>
                </div>
                
                <div id="join-room-panel" class="join-room-panel">
                    <label class="block text-white mb-2">輸入房間ID:</label>
                    <div class="room-input-group">
                        <input type="text" id="join-room-id" class="room-input" placeholder="請輸入房間ID">
                        <button id="connect-btn" class="room-btn">連接</button>
                    </div>
                </div>
                
                <div id="connection-status" class="connection-status"></div>
            </div>
            
            <div class="multiplayer-footer">
                <button id="back-to-cover-btn" class="back-btn">返回</button>
            </div>
        </div>
    </div>
    
    <!-- Reset Confirmation Dialog -->
    <div id="reset-confirm" class="reset-confirm">
        <div class="reset-dialog">
            <h3 class="reset-title">重置遊戲</h3>
            <p id="reset-message" class="reset-message">您確定要重置遊戲嗎？</p>
            <div class="reset-actions">
                <button id="reset-cancel" class="reset-btn cancel-btn">取消</button>
                <button id="reset-confirm-btn" class="reset-btn confirm-btn">確定</button>
            </div>
            <div id="reset-waiting" class="waiting-status">等待對方確認...</div>
        </div>
    </div>
    
    <div id="network-status" class="hidden bg-yellow-500 text-black"></div>
    <div id="connecting-overlay" class="connecting-overlay hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <h3 class="text-xl font-bold mb-4 text-center">正在連接對手...</h3>
            <div class="loader"></div>
            <p id="connection-message" class="text-center mt-4">建立連接中...</p>
        </div>
    </div>
    
    <!-- 勝利遮罩 -->
    <div id="victory-overlay" class="victory-overlay">
        <div id="victory-card" class="victory-card">
            <div id="victory-icon" class="victory-icon">🏆</div>
            <h2 id="victory-title" class="victory-title">勝利！</h2>
            <p id="victory-message" class="victory-message">恭喜您獲得勝利！</p>
            <button id="victory-reset" class="victory-reset">返回主畫面</button>
        </div>
    </div>
    
    <!-- Shooting Mini-Game Overlay -->
    <div id="combat-overlay" class="combat-overlay hidden">
        <div id="attacker-role" class="attacker-role">你是攻擊者</div>
        <div id="defender-role" class="defender-role">你是防守者</div>
        
        <div class="combat-wrapper mx-auto" style="width: 80%; max-width: 640px;">
            <!-- 上方攻擊者資訊 -->
            <div class="combat-info-panel">
                <div class="attacker-info">
                    <img id="attacker-image" class="unit-image" src="" alt="攻擊機體">
                    <div class="unit-stats">
                        <div id="attacker-name" class="unit-name">攻擊者機體</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-pink-300">命中:</span>
                            <div class="stat-bar">
                                <div id="attacker-hit-bar" class="hit-stat" style="width: 60%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="combat-container" id="combat-container">
                <div class="space-background" id="space-background"></div>
                <div class="combat-info" id="combat-info">攻擊者 vs 防守者</div>
                <div class="timer" id="combat-timer">3</div>
                
                <div class="attacker-instruction" id="attacker-instruction">移動滑鼠瞄準，點擊左鍵射擊（僅一次機會）</div>
                <div class="defender-instruction" id="defender-instruction">移動滑鼠選擇方向，點擊左鍵進行閃避</div>
                
                <div class="crosshair" id="crosshair">
                    <div class="crosshair-horizontal"></div>
                    <div class="crosshair-vertical"></div>
                    <div class="crosshair-inner"></div>
                </div>
                
                <div class="defender" id="defender">
                    <!-- Defender image will be set dynamically -->
                </div>
                
                <div class="defender-target" id="defender-target"></div>
                
                <div class="combat-result" id="combat-result">攻擊者勝利！</div>
            </div>
            
            <!-- 下方防守者資訊 -->
            <div class="combat-info-panel mt-2">
                <div class="defender-info">
                    <div class="unit-stats">
                        <div id="defender-name" class="unit-name">防守者機體</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-cyan-300">迴避:</span>
                            <div class="stat-bar">
                                <div id="defender-dodge-bar" class="dodge-stat" style="width: 80%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                    <img id="defender-image" class="unit-image" src="" alt="防守機體">
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <!-- Main Game UI (Initially Hidden) -->
    <div class="max-w-7xl mx-auto" id="game-ui" style="display: none;">
        <div class="flex justify-center mb-6">
            <img src="https://i.imgur.com/ve99gPQ.png" alt="超級機械人大戰Chess" class="h-16 md:h-20 object-contain">
        </div>
        
        <div class="grid md:grid-cols-3 gap-8">
            <!-- Chess Board - 放在左邊 -->
            <div class="md:col-span-2">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow aspect-square flex items-center justify-center">
                    <div id="board-container" class="w-[93%] h-[93%] flex items-center justify-center">
                        <div class="chess-board" id="chess-board"></div>
                    </div>
                </div>
                
                <!-- Mobile Captured Pieces (已隱藏) -->
                <div class="md:hidden bg-white dark:bg-gray-800 p-4 rounded-lg shadow mt-6 hidden">
                    <h2 class="text-xl font-semibold mb-4">已捕獲棋子</h2>
                    <div class="flex flex-wrap gap-2 mb-4">
                        <h3 class="w-full font-medium">藍方已捕獲:</h3>
                        <div id="blue-captured-mobile" class="flex flex-wrap gap-1"></div>
                    </div>
                    <div class="flex flex-wrap gap-2">
                        <h3 class="w-full font-medium">紅方已捕獲:</h3>
                        <div id="red-captured-mobile" class="flex flex-wrap gap-1"></div>
                    </div>
                </div>
            </div>
            
            <!-- Game Controls (Simplified) - 放在右邊，已重新排序 -->
            <div class="md:col-span-1 space-y-6">
                <!-- 能力參數視窗 -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">能力參數</h2>
                    <div id="piece-info" class="p-3 bg-gray-100 dark:bg-gray-700 rounded-lg h-[150px] flex flex-col justify-center items-center">
                        <div id="piece-info-default" class="text-center text-gray-500 dark:text-gray-400">
                            滑鼠移至棋子上方查看詳細資訊
                        </div>
                        <div id="piece-info-content" class="w-full hidden">
                            <div class="flex items-center mb-2">
                                <img id="piece-info-image" src="" alt="" class="w-16 h-16 object-contain mr-3">
                                <div>
                                    <h3 id="piece-info-name" class="font-bold"></h3>
                                    <p id="piece-info-type" class="text-sm"></p>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-pink-500 dark:text-pink-400">命中值:</span>
                                        <span id="piece-info-hit-value" class="text-sm font-bold text-pink-500 dark:text-pink-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-hit" class="bg-pink-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-cyan-500 dark:text-cyan-400">迴避值:</span>
                                        <span id="piece-info-dodge-value" class="text-sm font-bold text-cyan-500 dark:text-cyan-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-dodge" class="bg-cyan-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow overflow-hidden">
                    <h2 class="text-xl font-semibold mb-3">遊戲狀態</h2>
                    <!-- 隱藏元素，保留它們以供JS使用 -->
                    <div class="hidden">
                        <span class="turn-indicator" id="turn-indicator"></span>
                        <span id="turn-text">藍方回合</span>
                    </div>
                    <div id="status-message" class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 dark:from-blue-700 dark:to-purple-800 text-white rounded-lg min-h-[60px] flex items-center justify-center font-bold text-center shadow-lg text-lg mb-4">
                        遊戲準備就緒。藍方先行。
                    </div>
                    
                    <!-- 已捕獲棋子區域 (已隱藏) -->
                    <div class="hidden">
                        <h3 class="font-medium mb-2">已捕獲棋子:</h3>
                        <div class="flex flex-wrap gap-y-3">
                            <div class="w-full">
                                <h4 class="text-sm font-medium text-blue-600 dark:text-blue-400 mb-1">藍方已捕獲:</h4>
                                <div id="blue-captured" class="flex flex-wrap gap-1 min-h-[40px]"></div>
                            </div>
                            <div class="w-full">
                                <h4 class="text-sm font-medium text-red-600 dark:text-red-400 mb-1">紅方已捕獲:</h4>
                                <div id="red-captured" class="flex flex-wrap gap-1 min-h-[40px]"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">遊戲控制</h2>
                    
                    <div class="flex justify-center mt-4">
                        <button id="reset-btn" class="px-6 py-3 bg-red-500 text-white rounded-lg font-bold text-lg hover:bg-red-600 transition">重置遊戲</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 預設使用Dark Mode
        document.documentElement.classList.add('dark');
        
        // 仍然監聽系統偏好變化，但預設保持dark mode
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            // 不管系統偏好如何，保持dark mode
            document.documentElement.classList.add('dark');
        });
        
        // Game state and constants
        const BOARD_SIZE = 8;
        const BLUE = 'blue';
        const RED = 'red';
        
        // Piece movement types
        const PAWN = 'pawn';
        const ROOK = 'rook';
        const KNIGHT = 'knight';
        const BISHOP = 'bishop';
        const QUEEN = 'queen';
        const KING = 'king';
        
        // Combat mode state
        let combatMode = {
            active: false,
            attacker: null,
            defender: null,
            attackerPos: null,
            defenderPos: null,
            timer: 3,
            timeRemaining: 3000, // in milliseconds
            timerInterval: null,
            frameRequest: null,
            lastFrameTime: 0,
            mouseX: 0,
            mouseY: 0,
            defenderX: 0,
            defenderY: 0,
            defenderTargetX: 0,
            defenderTargetY: 0,
            defenderMoving: false,
            defenderSpeed: 0, // will be set based on defender's dodge value
            crosshairSize: 0, // will be set based on attacker's hit value
            defenderSize: 100, // Fixed defender size: 100px
            isPlayerAttacker: false,
            isPlayerDefender: false,
            bulletFired: false,
            result: null // 'attacker' or 'defender'
        };
        
        // Game state
        let gameState = {
            board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
            currentTurn: BLUE,
            selectedPiece: null,
            validMoves: [],
            gameMode: 'single-player',
            blueCaptured: [],
            redCaptured: [],
            gameOver: false,
            winner: null
        };
        
        // P2P variables
        let peer = null;
        let connection = null;
        let isHost = false;
        let remotePeerId = null;
        
        // Reset request tracking
        let resetRequestSent = false;
        let resetRequestReceived = false;
        
        // AI移動時間追蹤
        let lastAIMoveTime = 0;
        let aiMoveCount = 0;
        
        // AI移動計時器引用 - 用於管理和清除計時器
        let aiMoveTimer = null;
        
        // Initialize pieces and their properties
        const pieceDefinitions = {
            // Blue pieces (top)
            'core_fighter_1': { team: BLUE, type: '核心戰機 1', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [0, 6] },
            'core_fighter_2': { team: BLUE, type: '核心戰機 2', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [1, 6] },
            'core_fighter_3': { team: BLUE, type: '核心戰機 3', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [2, 6] },
            'core_fighter_4': { team: BLUE, type: '核心戰機 4', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [3, 6] },
            'core_fighter_5': { team: BLUE, type: '核心戰機 5', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [4, 6] },
            'core_fighter_6': { team: BLUE, type: '核心戰機 6', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [5, 6] },
            'core_fighter_7': { team: BLUE, type: '核心戰機 7', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [6, 6] },
            'core_fighter_8': { team: BLUE, type: '核心戰機 8', moveType: PAWN, imgUrl: 'https://i.imgur.com/T5zshZu.png', hit: 2, dodge: 2, startPos: [7, 6] },
            'gundam': { team: BLUE, type: '高達', moveType: ROOK, imgUrl: 'https://i.imgur.com/ma9ZzPs.png', hit: 2, dodge: 3, startPos: [0, 7] },
            'gp01_gundam': { team: BLUE, type: '高達GP01-Fb', moveType: ROOK, imgUrl: 'https://i.imgur.com/rX541xg.png', hit: 3, dodge: 2, startPos: [7, 7] },
            'gundam_mk_ii': { team: BLUE, type: '高達Mk-II', moveType: KNIGHT, imgUrl: 'https://i.imgur.com/i3ntMDy.png', hit: 3, dodge: 3, startPos: [6, 7] },
            'hyaku_shiki': { team: BLUE, type: '百式', moveType: KNIGHT, imgUrl: 'https://i.imgur.com/j8bn0Qb.png', hit: 3, dodge: 3, startPos: [1, 7] },
            'zeta_gundam': { team: BLUE, type: 'Z高達', moveType: BISHOP, imgUrl: 'https://i.imgur.com/onLceHg.png', hit: 3, dodge: 4, startPos: [5, 7] },
            'zz_gundam': { team: BLUE, type: 'ZZ高達', moveType: BISHOP, imgUrl: 'https://i.imgur.com/gvTnCUg.png', hit: 4, dodge: 3, startPos: [2, 7] },
            'ra_cailum': { team: BLUE, type: '勞·卡拉姆號', moveType: KING, imgUrl: 'https://i.imgur.com/Sjfaxe6.png', hit: 5, dodge: 2, startPos: [4, 7] },
            'nu_gundam': { team: BLUE, type: 'Nu高達', moveType: QUEEN, imgUrl: 'https://i.imgur.com/uUhvX3b.png', hit: 4, dodge: 4, startPos: [3, 7] },
            
            // Red pieces (bottom)
            'zaku_ii_1': { team: RED, type: '扎古II 1', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [0, 1] },
            'zaku_ii_2': { team: RED, type: '扎古II 2', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [1, 1] },
            'zaku_ii_3': { team: RED, type: '扎古II 3', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [2, 1] },
            'zaku_ii_4': { team: RED, type: '扎古II 4', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [3, 1] },
            'zaku_ii_5': { team: RED, type: '扎古II 5', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [4, 1] },
            'zaku_ii_6': { team: RED, type: '扎古II 6', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [5, 1] },
            'zaku_ii_7': { team: RED, type: '扎古II 7', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [6, 1] },
            'zaku_ii_8': { team: RED, type: '扎古II 8', moveType: PAWN, imgUrl: 'https://i.imgur.com/lMflnaQ.png', hit: 2, dodge: 2, startPos: [7, 1] },
            'gerbera_tetra': { team: RED, type: '嘉貝拉四式', moveType: ROOK, imgUrl: 'https://i.imgur.com/NrtiMVN.png', hit: 2, dodge: 3, startPos: [0, 0] },
            'dom': { team: RED, type: '德姆', moveType: ROOK, imgUrl: 'https://i.imgur.com/zbHK0BB.png', hit: 3, dodge: 2, startPos: [7, 0] },
            'gp02a_gundam': { team: RED, type: '高達GP02A', moveType: KNIGHT, imgUrl: 'https://i.imgur.com/QBG3h9J.png', hit: 3, dodge: 3, startPos: [6, 0] },
            'gelgoog_char': { team: RED, type: '夏亞專用勇士', moveType: KNIGHT, imgUrl: 'https://i.imgur.com/XQ95RZZ.png', hit: 3, dodge: 3, startPos: [1, 0] },
            'hamma_hamma': { team: RED, type: '漢馬漢馬', moveType: BISHOP, imgUrl: 'https://i.imgur.com/aYAopae.png', hit: 3, dodge: 4, startPos: [5, 0] },
            'doven_wolf': { team: RED, type: '多芬狼', moveType: BISHOP, imgUrl: 'https://i.imgur.com/ZFlCjHS.png', hit: 4, dodge: 3, startPos: [2, 0] },
            'sadalahn': { team: RED, type: '沙達拉恩號', moveType: KING, imgUrl: 'https://i.imgur.com/ww7Jj1G.png', hit: 5, dodge: 2, startPos: [4, 0] },
            'sazabi': { team: RED, type: '沙薩比', moveType: QUEEN, imgUrl: 'https://i.imgur.com/90O9E1o.png', hit: 4, dodge: 4, startPos: [3, 0] }
        };
        
        // Image URLs for preloading
        const imageUrls = Object.values(pieceDefinitions).map(piece => piece.imgUrl);
        
        // DOM elements
        const coverPage = document.getElementById('cover-page');
        const singleplayerBtn = document.getElementById('singleplayer-cover-btn');
        // 多人模式按鈕已被移除，不需要獲取該元素
        // const multiplayerBtn = document.getElementById('multiplayer-cover-btn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingBar = document.getElementById('loading-bar');
        const loadingPercentage = document.getElementById('loading-percentage');
        const loadingTime = document.getElementById('loading-time');
        const multiplayerSetup = document.getElementById('multiplayer-setup');
        const createTab = document.getElementById('create-tab');
        const joinTab = document.getElementById('join-tab');
        const createRoomPanel = document.getElementById('create-room-panel');
        const joinRoomPanel = document.getElementById('join-room-panel');
        const backToCoverBtn = document.getElementById('back-to-cover-btn');
        const resetConfirm = document.getElementById('reset-confirm');
        const resetMessage = document.getElementById('reset-message');
        const resetCancelBtn = document.getElementById('reset-cancel');
        const resetConfirmBtn = document.getElementById('reset-confirm-btn');
        const resetWaiting = document.getElementById('reset-waiting');
        const gameUI = document.getElementById('game-ui');
        
        const chessBoard = document.getElementById('chess-board');
        const turnIndicator = document.getElementById('turn-indicator');
        const turnText = document.getElementById('turn-text');
        const statusMessage = document.getElementById('status-message');
        const resetBtn = document.getElementById('reset-btn');
        const blueCapturedEl = document.getElementById('blue-captured');
        const redCapturedEl = document.getElementById('red-captured');
        const blueCapturedMobileEl = document.getElementById('blue-captured-mobile');
        const redCapturedMobileEl = document.getElementById('red-captured-mobile');
        const connectingOverlay = document.getElementById('connecting-overlay');
        const connectionMessage = document.getElementById('connection-message');
        const networkStatus = document.getElementById('network-status');
        const toast = document.getElementById('toast');
        const myRoomIdEl = document.getElementById('my-room-id');
        const copyIdBtn = document.getElementById('copy-id-btn');
        const joinRoomIdEl = document.getElementById('join-room-id');
        const connectBtn = document.getElementById('connect-btn');
        const connectionStatus = document.getElementById('connection-status');
        
        // Combat elements
        const combatOverlay = document.getElementById('combat-overlay');
        const combatContainer = document.getElementById('combat-container');
        const combatInfo = document.getElementById('combat-info');
        const combatTimer = document.getElementById('combat-timer');
        const crosshair = document.getElementById('crosshair');
        const defender = document.getElementById('defender');
        const defenderTarget = document.getElementById('defender-target');
        const spaceBackground = document.getElementById('space-background');
        const combatResult = document.getElementById('combat-result');
        const attackerRole = document.getElementById('attacker-role');
        const defenderRole = document.getElementById('defender-role');
        const attackerInstruction = document.getElementById('attacker-instruction');
        const defenderInstruction = document.getElementById('defender-instruction');
        
        // Victory overlay elements
        const victoryOverlay = document.getElementById('victory-overlay');
        const victoryCard = document.getElementById('victory-card');
        const victoryTitle = document.getElementById('victory-title');
        const victoryMessage = document.getElementById('victory-message');
        const victoryReset = document.getElementById('victory-reset');
        const victoryIcon = document.getElementById('victory-icon');
        
        // New combat info panel elements
        const attackerImage = document.getElementById('attacker-image');
        const defenderImage = document.getElementById('defender-image');
        const attackerName = document.getElementById('attacker-name');
        const defenderName = document.getElementById('defender-name');
        const attackerHitBar = document.getElementById('attacker-hit-bar');
        const defenderDodgeBar = document.getElementById('defender-dodge-bar');
        
        // Setup cover page space background
        function setupSpaceBackground(container) {
            // Clear any existing stars
            container.innerHTML = '';
            
            // Add stars
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                // Different star sizes
                const size = Math.random() * 2.5 + 1;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // Different star brightness
                star.style.opacity = Math.random() * 0.7 + 0.3;
                
                container.appendChild(star);
            }
            
            // Add shooting stars
            for (let i = 0; i < 5; i++) {
                createShootingStar(container);
            }
        }
        
        // Create shooting star with random properties
        function createShootingStar(container) {
            const shootingStar = document.createElement('div');
            shootingStar.className = 'shooting-star';
            
            // Random position and angle
            const startX = Math.random() * 100;
            const startY = Math.random() * 100;
            const angle = Math.random() * 60 - 30; // -30 to 30 degrees
            
            shootingStar.style.left = `${startX}%`;
            shootingStar.style.top = `${startY}%`;
            shootingStar.style.width = `${Math.random() * 100 + 50}px`;
            shootingStar.style.transform = `rotate(${angle}deg)`;
            
            // Random delay and duration
            const delay = Math.random() * 15;
            shootingStar.style.animationDelay = `${delay}s`;
            
            container.appendChild(shootingStar);
            
            // Replace the shooting star after animation
            setTimeout(() => {
                if (container.contains(shootingStar)) {
                    container.removeChild(shootingStar);
                    createShootingStar(container);
                }
            }, (delay + 3) * 1000); // 3s is the animation duration
        }
        
        // Preload all game images with progress tracking
        function preloadImages(imageUrls) {
            return new Promise((resolve) => {
                if (imageUrls.length === 0) {
                    resolve();
                    return;
                }
                
                const uniqueUrls = [...new Set(imageUrls)]; // Remove duplicates
                let loadedCount = 0;
                let startTime = Date.now();
                let lastUpdateTime = startTime;
                let loadingRates = [];
                
                // Update loading progress
                function updateProgress() {
                    const progress = loadedCount / uniqueUrls.length;
                    loadingBar.style.width = `${progress * 100}%`;
                    loadingPercentage.textContent = `${Math.round(progress * 100)}%`;
                    
                    // Calculate estimated time remaining
                    const currentTime = Date.now();
                    const elapsedTime = (currentTime - lastUpdateTime) / 1000; // in seconds
                    lastUpdateTime = currentTime;
                    
                    // Only calculate loading rate if some images have loaded
                    if (loadedCount > 0 && elapsedTime > 0) {
                        const loadingRate = 1 / elapsedTime; // images per second
                        loadingRates.push(loadingRate);
                        
                        // Only use the last 5 rates for a rolling average
                        if (loadingRates.length > 5) {
                            loadingRates.shift();
                        }
                        
                        // Calculate average loading rate
                        const avgLoadingRate = loadingRates.reduce((a, b) => a + b, 0) / loadingRates.length;
                        
                        // Estimate remaining time
                        const remainingImages = uniqueUrls.length - loadedCount;
                        const estimatedSeconds = remainingImages / avgLoadingRate;
                        
                        // Display estimated time
                        if (estimatedSeconds < 60) {
                            loadingTime.textContent = `預計剩餘時間: ${Math.round(estimatedSeconds)} 秒`;
                        } else {
                            const minutes = Math.floor(estimatedSeconds / 60);
                            const seconds = Math.round(estimatedSeconds % 60);
                            loadingTime.textContent = `預計剩餘時間: ${minutes} 分 ${seconds} 秒`;
                        }
                    }
                }
                
                // Load each image
                uniqueUrls.forEach(url => {
                    const img = new Image();
                    img.onload = img.onerror = () => {
                        loadedCount++;
                        updateProgress();
                        
                        if (loadedCount === uniqueUrls.length) {
                            // Add a short delay to show 100%
                            setTimeout(resolve, 500);
                        }
                    };
                    img.src = url;
                });
                
                // Initial progress update
                updateProgress();
            });
        }
        
        // Single player mode button click
        singleplayerBtn.addEventListener('click', async () => {
            coverPage.classList.add('hide');
            loadingOverlay.classList.add('show');
            
            // Preload images
            await preloadImages(imageUrls);
            
            // Hide loading overlay and show game UI
            loadingOverlay.classList.remove('show');
            gameUI.style.display = 'block';
            
            // Initialize game
            gameState.gameMode = 'single-player';
            createBoard();
            initializeGame();
        });
        
        // 多人模式按鈕已被移除，相關事件監聽器也應移除
        // multiplayerBtn.addEventListener('click', () => {
        //     coverPage.classList.add('hide');
        //     multiplayerSetup.classList.add('show');
        //     
        //     // Initialize peer if not already done
        //     if (!peer) {
        //         initPeer();
        //     }
        // });
        
        // Back to cover button click
        backToCoverBtn.addEventListener('click', () => {
            multiplayerSetup.classList.remove('show');
            coverPage.classList.remove('hide');
            
            // Reset connection status
            connectionStatus.textContent = '';
            
            // Destroy peer connection if exists
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            if (connection) {
                connection.close();
                connection = null;
            }
        });
        
        // Tab switching in multiplayer setup
        createTab.addEventListener('click', () => {
            createTab.className = 'multiplayer-tab active-tab';
            joinTab.className = 'multiplayer-tab inactive-tab';
            createRoomPanel.classList.add('show-panel');
            joinRoomPanel.classList.remove('show-panel');
        });
        
        joinTab.addEventListener('click', () => {
            joinTab.className = 'multiplayer-tab active-tab';
            createTab.className = 'multiplayer-tab inactive-tab';
            joinRoomPanel.classList.add('show-panel');
            createRoomPanel.classList.remove('show-panel');
        });
        
        // Copy room ID button
        copyIdBtn.addEventListener('click', () => {
            myRoomIdEl.select();
            navigator.clipboard.writeText(myRoomIdEl.value)
                .then(() => {
                    connectionStatus.textContent = "房間ID已複製到剪貼板!";
                    setTimeout(() => {
                        connectionStatus.textContent = "";
                    }, 3000);
                })
                .catch(err => {
                    connectionStatus.textContent = "複製失敗: " + err;
                });
        });
        
        // Connect button
        connectBtn.addEventListener('click', () => {
            const roomId = joinRoomIdEl.value.trim();
            if (roomId) {
                connectingOverlay.classList.remove('hidden');
                connectionMessage.textContent = "正在連接到對手...";
                
                connectToPeer(roomId);
            } else {
                connectionStatus.textContent = "請輸入房間ID";
            }
        });
        
        // Reset confirmation dialog
        resetBtn.addEventListener('click', () => {
            if (gameState.gameMode === 'single-player') {
                // In single player, no confirmation needed, go back to cover page
                resetGame();
                showCoverPage();
            } else {
                // In multiplayer, show confirmation dialog
                resetMessage.textContent = "您確定要重置遊戲嗎？對方也需同意才能重置。";
                resetConfirm.classList.add('show');
                resetWaiting.style.display = 'none';
                resetRequestSent = false;
            }
        });
        
        // Reset cancel button
        resetCancelBtn.addEventListener('click', () => {
            resetConfirm.classList.remove('show');
            
            // If we received a request, reject it
            if (resetRequestReceived) {
                resetRequestReceived = false;
                
                // Send rejection to peer
                if (connection && connection.open) {
                    connection.send({
                        type: 'resetResponse',
                        accepted: false
                    });
                }
            }
        });
        
        // Reset confirm button
        resetConfirmBtn.addEventListener('click', () => {
            if (resetRequestReceived) {
                // If we received a request, accept it
                resetRequestReceived = false;
                resetConfirm.classList.remove('show');
                
                // Send acceptance to peer
                if (connection && connection.open) {
                    connection.send({
                        type: 'resetResponse',
                        accepted: true
                    });
                }
                
                // Reset game and go to cover page
                resetGame();
                showCoverPage();
            } else {
                // Send reset request to peer
                if (connection && connection.open) {
                    connection.send({
                        type: 'resetRequest'
                    });
                    
                    resetRequestSent = true;
                    resetWaiting.style.display = 'block';
                    resetConfirmBtn.disabled = true;
                    resetConfirmBtn.style.opacity = 0.5;
                    resetMessage.textContent = "請等待對方確認...";
                }
            }
        });
        
        // Victory reset button
        victoryReset.addEventListener('click', () => {
            victoryOverlay.classList.remove('show');
            
            // In singleplayer, go to cover page
            if (gameState.gameMode === 'single-player') {
                resetGame();
                showCoverPage();
            } else {
                // In multiplayer, reset the game and show the reset confirmation for the opponent
                resetMessage.textContent = "您確定要重置遊戲嗎？對方也需同意才能重置。";
                resetConfirm.classList.add('show');
            }
        });
        
        // Create chess board UI
        function createBoard() {
            chessBoard.innerHTML = '';
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cellElement = document.createElement('div');
                    cellElement.className = `chess-cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;
                    
                    // Add coordinates for reference
                    const coordElement = document.createElement('div');
                    coordElement.className = 'coordinate top-left';
                    coordElement.textContent = `${String.fromCharCode(97 + col)}${8 - row}`;
                    cellElement.appendChild(coordElement);
                    
                    chessBoard.appendChild(cellElement);
                }
            }
            
            // Add event listeners to cells
            const cells = document.querySelectorAll('.chess-cell');
            cells.forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }
        
        // Initialize game board with pieces
        function initializeGame() {
            // Reset game state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: gameState.gameMode,
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null
            };
            
            // Hide any active victory overlay
            victoryOverlay.classList.remove('show');
            
            // Setup the captured toggle functionality
            setupCapturedToggle();
            
            // Reset combat mode
            combatMode = {
                active: false,
                attacker: null,
                defender: null,
                attackerPos: null,
                defenderPos: null,
                timer: 3,
                timeRemaining: 3000,
                timerInterval: null,
                frameRequest: null,
                lastFrameTime: 0,
                mouseX: 0,
                mouseY: 0,
                defenderX: 0,
                defenderY: 0,
                defenderTargetX: 0,
                defenderTargetY: 0,
                defenderMoving: false,
                defenderSpeed: 0,
                crosshairSize: 0,
                defenderSize: 100, // Fixed at 100px
                isPlayerAttacker: false,
                isPlayerDefender: false,
                bulletFired: false,
                result: null
            };
            
            // Place pieces on board
            Object.keys(pieceDefinitions).forEach(pieceId => {
                const piece = pieceDefinitions[pieceId];
                const [col, row] = piece.startPos;
                
                gameState.board[row][col] = {
                    id: pieceId,
                    team: piece.team,
                    type: piece.type,
                    moveType: piece.moveType,
                    imgUrl: piece.imgUrl,
                    hit: piece.hit,
                    dodge: piece.dodge,
                    hasMoved: false
                };
            });
            
            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();
            
            statusMessage.textContent = "遊戲準備就緒。藍方先行。";
            
            // Send initial gameState to peer if in multiplayer mode
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendGameState();
            }
        }
        
        // Reset the game completely
        function resetGame() {
            resetRequestSent = false;
            resetRequestReceived = false;
            
            // Reset all game elements to initial state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: 'single-player', // Default to single player when resetting
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null
            };
            
            victoryOverlay.classList.remove('show');
            combatOverlay.classList.add('hidden');
            resetConfirm.classList.remove('show');
        }
        
        // Show the cover page
        function showCoverPage() {
            gameUI.style.display = 'none';
            coverPage.classList.remove('hide');
            
            // Close any peer connections
            if (gameState.gameMode === 'multiplayer' && connection) {
                connection.close();
                connection = null;
            }
            
            if (peer) {
                peer.destroy();
                peer = null;
            }
        }
        
        // Update the visual representation of the board
        function updateBoardDisplay() {
            // Clear all pieces
            const cells = document.querySelectorAll('.chess-cell');
            cells.forEach(cell => {
                // Remove piece images and indicators
                const existingImg = cell.querySelector('.piece-img');
                if (existingImg) cell.removeChild(existingImg);
                
                const indicators = cell.querySelectorAll('.valid-move-indicator');
                indicators.forEach(indicator => cell.removeChild(indicator));
                
                cell.classList.remove('selected');
            });
            
            // Determine if we should flip the board perspective (for red player in multiplayer mode)
            const shouldFlipPerspective = gameState.gameMode === 'multiplayer' && !isHost;
            
            // Place pieces according to current board state
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        // Apply perspective flip for red player in multiplayer
                        let displayRow = row;
                        let displayCol = col;
                        
                        if (shouldFlipPerspective) {
                            // Flip coordinates for red player's perspective
                            displayRow = BOARD_SIZE - 1 - row;
                            displayCol = BOARD_SIZE - 1 - col;
                        }
                        
                        const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                        
                        // Create piece image
                        const img = document.createElement('img');
                        img.src = piece.imgUrl;
                        img.alt = piece.type;
                        img.className = 'piece-img';
                        img.dataset.pieceId = piece.id;
                        
                        // 紅色棋子水平翻轉
                        if (piece.team === RED) {
                            img.style.transform = 'scaleX(-1)';
                        }
                        
                        cell.appendChild(img);
                        
                        // Highlight selected piece
                        if (gameState.selectedPiece && 
                            gameState.selectedPiece.row === row && 
                            gameState.selectedPiece.col === col) {
                            cell.classList.add('selected');
                        }
                    }
                }
            }
            
            // Show valid moves if a piece is selected
            if (gameState.selectedPiece) {
                gameState.validMoves.forEach(move => {
                    let displayRow = move.row;
                    let displayCol = move.col;
                    
                    if (shouldFlipPerspective) {
                        // Flip coordinates for red player's perspective
                        displayRow = BOARD_SIZE - 1 - move.row;
                        displayCol = BOARD_SIZE - 1 - move.col;
                    }
                    
                    const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'valid-move-indicator';
                    
                    // If there's a piece at this position (capture)
                    if (gameState.board[move.row][move.col]) {
                        indicator.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                    } else {
                        indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
                    }
                    
                    cell.appendChild(indicator);
                });
            }
            
            // Set up piece hover events after updating the board
            setupPieceHoverEvents();
        }
        
        // Update turn indicator
        function updateTurnIndicator() {
            turnIndicator.style.backgroundColor = gameState.currentTurn === BLUE ? '#4169E1' : '#DC143C';
            turnText.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合`;
        }
        
        // Update captured pieces display
        function updateCapturedPieces() {
            // Clear existing captured pieces
            blueCapturedEl.innerHTML = '';
            redCapturedEl.innerHTML = '';
            blueCapturedMobileEl.innerHTML = '';
            redCapturedMobileEl.innerHTML = '';
            
            // Add blue captured pieces
            gameState.blueCaptured.forEach(piece => {
                const img = document.createElement('img');
                img.src = piece.imgUrl;
                img.alt = piece.type;
                img.title = piece.type;
                img.className = 'w-8 h-8 object-contain';
                
                blueCapturedEl.appendChild(img.cloneNode(true));
                blueCapturedMobileEl.appendChild(img);
            });
            
            // Add red captured pieces
            gameState.redCaptured.forEach(piece => {
                const img = document.createElement('img');
                img.src = piece.imgUrl;
                img.alt = piece.type;
                img.title = piece.type;
                img.className = 'w-8 h-8 object-contain';
                
                redCapturedEl.appendChild(img.cloneNode(true));
                redCapturedMobileEl.appendChild(img);
            });
        }
        
        // 設置棋子懸停事件，顯示能力參數
        function setupPieceHoverEvents() {
            const pieceImages = document.querySelectorAll('.piece-img');
            const pieceInfoDefault = document.getElementById('piece-info-default');
            const pieceInfoContent = document.getElementById('piece-info-content');
            const pieceInfoImage = document.getElementById('piece-info-image');
            const pieceInfoName = document.getElementById('piece-info-name');
            const pieceInfoType = document.getElementById('piece-info-type');
            const pieceInfoHit = document.getElementById('piece-info-hit');
            const pieceInfoDodge = document.getElementById('piece-info-dodge');
            const pieceInfoHitValue = document.getElementById('piece-info-hit-value');
            const pieceInfoDodgeValue = document.getElementById('piece-info-dodge-value');
            
            pieceImages.forEach(img => {
                img.addEventListener('mouseenter', function() {
                    const pieceId = this.dataset.pieceId;
                    const pieceInfo = pieceDefinitions[pieceId];
                    
                    if (pieceInfo) {
                        // 顯示棋子資訊
                        pieceInfoDefault.classList.add('hidden');
                        pieceInfoContent.classList.remove('hidden');
                        
                        // 設置資訊內容
                        pieceInfoImage.src = pieceInfo.imgUrl;
                        pieceInfoName.textContent = pieceInfo.type;
                        
                        // 移動類型翻譯
                        let moveTypeText = "";
                        switch(pieceInfo.moveType) {
                            case PAWN: moveTypeText = "步兵"; break;
                            case ROOK: moveTypeText = "城堡"; break;
                            case KNIGHT: moveTypeText = "騎士"; break;
                            case BISHOP: moveTypeText = "主教"; break;
                            case QUEEN: moveTypeText = "皇后"; break;
                            case KING: moveTypeText = "國王"; break;
                        }
                        pieceInfoType.textContent = `移動類型: ${moveTypeText}`;
                        
                        // 設置能力條和數值顯示
                        const maxValue = 5; // 假設最大值是5
                        const hitPercentage = (pieceInfo.hit / maxValue) * 100;
                        const dodgePercentage = (pieceInfo.dodge / maxValue) * 100;
                        
                        pieceInfoHit.style.width = `${hitPercentage}%`;
                        pieceInfoDodge.style.width = `${dodgePercentage}%`;
                        
                        // 設置實數值顯示
                        pieceInfoHitValue.textContent = pieceInfo.hit;
                        pieceInfoDodgeValue.textContent = pieceInfo.dodge;
                    }
                });
                
                img.addEventListener('mouseleave', function() {
                    // 重置為默認狀態
                    pieceInfoDefault.classList.remove('hidden');
                    pieceInfoContent.classList.add('hidden');
                });
            });
        }
        
        // 設置已捕獲棋子的折疊功能
        function setupCapturedToggle() {
            const capturedHeader = document.getElementById('captured-header');
            const capturedToggle = document.getElementById('captured-toggle');
            const capturedContent = document.getElementById('captured-content');
            
            if (capturedHeader && capturedToggle && capturedContent) {
                capturedHeader.addEventListener('click', function() {
                    capturedContent.classList.toggle('hidden');
                    capturedToggle.classList.toggle('rotate-180');
                });
            }
        }
        
        // Show victory screen function
        function showVictoryScreen(winnerTeam) {
            // Set victory card appearance based on winner
            if (winnerTeam === BLUE) {
                victoryCard.className = "victory-card blue-victory";
                victoryTitle.textContent = "藍方勝利！";
                victoryMessage.textContent = "藍方成功擊敗了紅方！恭喜藍方玩家！";
                victoryIcon.textContent = "🏆";
            } else {
                victoryCard.className = "victory-card red-victory";
                victoryTitle.textContent = "紅方勝利！";
                victoryMessage.textContent = "紅方成功擊敗了藍方！恭喜紅方玩家！";
                victoryIcon.textContent = "🏆";
            }
            
            // Create confetti effect
            createConfetti(winnerTeam);
            
            // Show the victory overlay
            victoryOverlay.classList.add('show');
        }
        
        // Create confetti animation
        function createConfetti(winnerTeam) {
            // Clear any existing confetti
            const existingConfetti = document.querySelectorAll('.victory-confetti');
            existingConfetti.forEach(c => c.remove());
            
            // Colors based on winner
            const colors = winnerTeam === BLUE 
                ? ['#4169E1', '#6495ED', '#1E90FF', '#00BFFF', '#87CEFA', '#B0E0E6'] 
                : ['#DC143C', '#FF0000', '#CD5C5C', '#FF4500', '#FF6347', '#FFA07A'];
                
            // Create new confetti pieces
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'victory-confetti';
                
                // Random position
                confetti.style.left = `${Math.random() * 100}%`;
                
                // Random color from winner's colors
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Random shape
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                
                // Random size
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size * (Math.random() + 0.5)}px`;
                
                // Random animation duration
                const duration = Math.random() * 3 + 2;
                confetti.style.animationDuration = `${duration}s`;
                
                // Random delay
                confetti.style.animationDelay = `${Math.random() * 5}s`;
                
                // Add to overlay
                victoryCard.appendChild(confetti);
            }
        }
        
        // Handle cell click
        function handleCellClick(event) {
            if (gameState.gameOver || combatMode.active) return;
            
            // If it's multiplayer and not your turn, ignore
            if (gameState.gameMode === 'multiplayer') {
                const isMyTurn = (isHost && gameState.currentTurn === BLUE) ||
                    (!isHost && gameState.currentTurn === RED);
                if (!isMyTurn) {
                    showToast("現在不是您的回合");
                    return;
                }
            }
            
            const cell = event.currentTarget;
            let row = parseInt(cell.dataset.row);
            let col = parseInt(cell.dataset.col);
            
            // If we're in multiplayer and this is the red player, flip coordinates
            if (gameState.gameMode === 'multiplayer' && !isHost) {
                row = BOARD_SIZE - 1 - row;
                col = BOARD_SIZE - 1 - col;
            }
            
            const piece = gameState.board[row][col];
            
            // If a piece is already selected
            if (gameState.selectedPiece) {
                const selectedPiece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                
                // Check if clicked on same piece (deselect)
                if (row === gameState.selectedPiece.row && col === gameState.selectedPiece.col) {
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                    return;
                }
                
                // Check if clicked on another piece of same team (change selection)
                if (piece && piece.team === selectedPiece.team) {
                    if (piece.team === gameState.currentTurn) {
                        gameState.selectedPiece = { row, col };
                        gameState.validMoves = calculateValidMoves(row, col);
                        updateBoardDisplay();
                    }
                    return;
                }
                
                // Check if the move is valid
                const validMove = gameState.validMoves.find(move => move.row === row && move.col === col);
                if (validMove) {
                    // Check if this is a capture move (there's an opponent's piece)
                    if (piece && piece.team !== selectedPiece.team) {
                        // Start the combat minigame
                        startCombat(selectedPiece, piece, 
                                    { row: gameState.selectedPiece.row, col: gameState.selectedPiece.col }, 
                                    { row, col });
                    } else {
                        // Regular move
                        movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                    }
                }
            } 
            // No piece selected yet, select a piece if it belongs to current player
            else if (piece && piece.team === gameState.currentTurn) {
                gameState.selectedPiece = { row, col };
                gameState.validMoves = calculateValidMoves(row, col);
                updateBoardDisplay();
            }
        }
        
        // Calculate valid moves for a piece
        function calculateValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];
            
            let moves = [];
            
            switch (piece.moveType) {
                case PAWN:
                    moves = calculatePawnMoves(row, col, piece);
                    break;
                case ROOK:
                    moves = calculateRookMoves(row, col, piece);
                    break;
                case KNIGHT:
                    moves = calculateKnightMoves(row, col, piece);
                    break;
                case BISHOP:
                    moves = calculateBishopMoves(row, col, piece);
                    break;
                case QUEEN:
                    moves = calculateQueenMoves(row, col, piece);
                    break;
                case KING:
                    moves = calculateKingMoves(row, col, piece);
                    break;
            }
            
            // Filter out moves that would put the king in check
            return moves.filter(move => {
                // Create a deep copy of the board for simulation
                const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                
                // Simulate the move
                tempBoard[move.row][move.col] = tempBoard[row][col];
                tempBoard[row][col] = null;
                
                // Find the king
                let kingPos = null;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const p = tempBoard[r][c];
                        if (p && p.team === piece.team && p.moveType === KING) {
                            kingPos = { row: r, col: c };
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                // If king not found (unlikely), allow the move
                if (!kingPos) return true;
                
                // Check if the king would be in check after the move
                return !isInCheck(tempBoard, kingPos.row, kingPos.col, piece.team);
            });
        }
        
        // Check if a position is under attack
        function isInCheck(board, kingRow, kingCol, team) {
            const enemyTeam = team === BLUE ? RED : BLUE;
            
            // Check all opponent pieces to see if any can attack the king
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = board[row][col];
                    if (!piece || piece.team !== enemyTeam) continue;
                    
                    // Get potential attack moves for this piece
                    let attackMoves;
                    switch (piece.moveType) {
                        case PAWN:
                            attackMoves = calculatePawnAttacks(row, col, piece);
                            break;
                        case ROOK:
                            attackMoves = calculateRookMoves(row, col, piece);
                            break;
                        case KNIGHT:
                            attackMoves = calculateKnightMoves(row, col, piece);
                            break;
                        case BISHOP:
                            attackMoves = calculateBishopMoves(row, col, piece);
                            break;
                        case QUEEN:
                            attackMoves = calculateQueenMoves(row, col, piece);
                            break;
                        case KING:
                            attackMoves = calculateKingMoves(row, col, piece, true);
                            break;
                    }
                    
                    // If any move can reach the king's position, the king is in check
                    if (attackMoves.some(move => move.row === kingRow && move.col === kingCol)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Calculate pawn moves
        function calculatePawnMoves(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1; // Blue moves up, Red moves down
            
            // Forward move
            if (isValidPosition(row + direction, col) && !gameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // Double move from starting position
                const startRow = piece.team === BLUE ? 6 : 1;
                if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
            
            // Capture moves (diagonally)
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    const targetPiece = gameState.board[row + direction][captureCol];
                    if (targetPiece && targetPiece.team !== piece.team) {
                        moves.push({ row: row + direction, col: captureCol });
                    }
                }
            });
            
            return moves;
        }
        
        // Calculate pawn attack pattern (for check detection)
        function calculatePawnAttacks(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1;
            
            // Pawns attack diagonally
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    moves.push({ row: row + direction, col: captureCol });
                }
            });
            
            return moves;
        }
        
        // Calculate rook moves
        function calculateRookMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: 0 }, // up
                { rowDelta: 1, colDelta: 0 },  // down
                { rowDelta: 0, colDelta: -1 }, // left
                { rowDelta: 0, colDelta: 1 }   // right
            ];
            
            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;
                
                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];
                    
                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }
                    
                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });
            
            return moves;
        }
        
        // Calculate knight moves
        function calculateKnightMoves(row, col, piece) {
            const moves = [];
            const knightMoves = [
                { rowDelta: -2, colDelta: -1 },
                { rowDelta: -2, colDelta: 1 },
                { rowDelta: -1, colDelta: -2 },
                { rowDelta: -1, colDelta: 2 },
                { rowDelta: 1, colDelta: -2 },
                { rowDelta: 1, colDelta: 2 },
                { rowDelta: 2, colDelta: -1 },
                { rowDelta: 2, colDelta: 1 }
            ];
            
            knightMoves.forEach(move => {
                const newRow = row + move.rowDelta;
                const newCol = col + move.colDelta;
                
                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    
                    if (!targetPiece || targetPiece.team !== piece.team) {
                        // Empty square or enemy piece
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });
            
            return moves;
        }
        
        // Calculate bishop moves
        function calculateBishopMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: -1 }, // up-left
                { rowDelta: -1, colDelta: 1 },  // up-right
                { rowDelta: 1, colDelta: -1 },  // down-left
                { rowDelta: 1, colDelta: 1 }    // down-right
            ];
            
            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;
                
                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];
                    
                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }
                    
                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });
            
            return moves;
        }
        
        // Calculate queen moves (combination of rook and bishop)
        function calculateQueenMoves(row, col, piece) {
            return [
                ...calculateRookMoves(row, col, piece),
                ...calculateBishopMoves(row, col, piece)
            ];
        }
        
        // Calculate king moves
        function calculateKingMoves(row, col, piece, forCheckDetection = false) {
            const moves = [];
            
            // King moves one square in any direction
            for (let rowDelta = -1; rowDelta <= 1; rowDelta++) {
                for (let colDelta = -1; colDelta <= 1; colDelta++) {
                    // Skip the current position
                    if (rowDelta === 0 && colDelta === 0) continue;
                    
                    const newRow = row + rowDelta;
                    const newCol = col + colDelta;
                    
                    if (isValidPosition(newRow, newCol)) {
                        const targetPiece = gameState.board[newRow][newCol];
                        
                        if (!targetPiece || targetPiece.team !== piece.team) {
                            // For regular move calculation, ensure the king doesn't move into check
                            if (forCheckDetection) {
                                moves.push({ row: newRow, col: newCol });
                            } else {
                                // Check if the new position would be in check
                                const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                tempBoard[newRow][newCol] = tempBoard[row][col];
                                tempBoard[row][col] = null;
                                
                                if (!isInCheck(tempBoard, newRow, newCol, piece.team)) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                            }
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // Helper to check if a position is valid (on the board)
        function isValidPosition(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
        }
        
        // Move a piece without afterimage effect
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // If capturing a piece, add to captured list
            if (capturedPiece) {
                if (capturedPiece.team === BLUE) {
                    gameState.blueCaptured.push(capturedPiece);
                } else {
                    gameState.redCaptured.push(capturedPiece);
                }
                
                // Check if captured piece is a king (game over)
                if (capturedPiece.moveType === KING) {
                    gameState.gameOver = true;
                    gameState.winner = piece.team;
                }
            }
            
            // Move the piece in the game state
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            // Mark the piece as moved (important for pawns)
            piece.hasMoved = true;
            
            // Clear selection and valid moves
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            
            // Switch turns
            gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;
            
            // 在日誌中發出回合轉換通知
            console.log(`回合轉換：現在是${gameState.currentTurn === BLUE ? '藍方' : '紅方'}的回合`);
            
            // Update UI
            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();
            
            // Update status message and show victory overlay if game is over
            if (gameState.gameOver) {
                const winnerTeam = gameState.winner === BLUE ? '藍方' : '紅方';
                statusMessage.textContent = `遊戲結束！${winnerTeam}勝利！`;
                
                // Show victory overlay with animation
                showVictoryScreen(gameState.winner);
            } else {
                statusMessage.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合。`;
            }
            
            // Send updated game state to peer if in multiplayer mode
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendGameState();
            }
            
            // If single player mode and it's AI's turn
            if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                // 清除任何可能存在的之前的計時器
                if (aiMoveTimer) {
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }
                
                const aiDelay = 500;
                console.log(`安排AI移動（延遲: ${aiDelay}毫秒）...`);
                aiMoveTimer = setTimeout(makeAIMove, aiDelay);
            }
        }
        
        // Initialize the combat shooting minigame
        function initSpaceBackground() {
            spaceBackground.innerHTML = '';
            
            // Create stars
            for (let i = 0; i < 150; i++) { // Increased star count
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.opacity = Math.random() * 0.7 + 0.3;
                
                spaceBackground.appendChild(star);
            }
            
            // Create nebulae
            for (let i = 0; i < 8; i++) { // Increased nebula count
                const nebula = document.createElement('div');
                nebula.className = 'nebula';
                nebula.style.left = `${Math.random() * 100}%`;
                nebula.style.top = `${Math.random() * 100}%`;
                nebula.style.width = `${Math.random() * 250 + 150}px`;
                nebula.style.height = nebula.style.width;
                
                // Enhanced nebula colors
                const colors = [
                    '#4169E1', '#9370DB', '#FF6347', '#20B2AA', '#FFD700', 
                    '#FF1493', '#00CED1', '#9932CC'
                ];
                nebula.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                spaceBackground.appendChild(nebula);
            }
        }
        
        // 添加戰鬥前的介紹彈窗HTML元素
        const combatIntroHTML = `
            <div id="combat-intro-overlay" class="fixed inset-0 bg-black bg-opacity-75 z-[150] flex items-center justify-center transition-opacity duration-500 opacity-0">
                <div class="relative max-w-3xl w-full bg-gradient-to-b from-gray-900 to-gray-800 rounded-lg p-6 text-white overflow-hidden shadow-2xl">
                    <div class="absolute inset-0 overflow-hidden">
                        <div class="stars-bg absolute inset-0"></div>
                    </div>
                    <div class="relative z-10">
                        <h2 class="text-center text-3xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-blue-500">戰鬥即將開始!</h2>
                        
                        <div class="flex flex-col md:flex-row justify-between items-center space-y-8 md:space-y-0 md:space-x-4">
                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-red-500 to-pink-600 text-white py-2 px-4 rounded-t-lg font-bold">
                                    攻擊方
                                </div>
                                <div class="bg-gray-900 p-4 rounded-b-lg border-2 border-t-0 border-pink-500">
                                    <img id="intro-attacker-img" src="" alt="攻擊機體" class="w-40 h-40 object-contain mx-auto mb-3">
                                    <h3 id="intro-attacker-name" class="text-xl font-bold mb-1 text-pink-300">攻擊機體名稱</h3>
                                    <p id="intro-attacker-type" class="text-sm mb-3 text-gray-300">移動類型</p>
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-pink-400 font-bold">命中:</span>
                                        <span id="intro-attacker-hit" class="font-mono font-bold text-pink-300">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-2 mb-3 rounded-full overflow-hidden">
                                        <div id="intro-attacker-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-cyan-400 font-bold">迴避:</span>
                                        <span id="intro-attacker-dodge" class="font-mono font-bold text-cyan-300">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden">
                                        <div id="intro-attacker-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="relative">
                                <div class="w-16 h-16 bg-gradient-to-r from-pink-500 to-blue-500 rounded-full flex items-center justify-center text-white font-bold text-xl">
                                    VS
                                </div>
                                <div class="absolute -top-3 -left-3 w-6 h-6 bg-yellow-400 rounded-full animate-ping opacity-70"></div>
                                <div class="absolute -bottom-3 -right-3 w-6 h-6 bg-blue-400 rounded-full animate-ping opacity-70 animation-delay-500"></div>
                            </div>
                            
                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-cyan-500 to-blue-600 text-white py-2 px-4 rounded-t-lg font-bold">
                                    防守方
                                </div>
                                <div class="bg-gray-900 p-4 rounded-b-lg border-2 border-t-0 border-cyan-500">
                                    <img id="intro-defender-img" src="" alt="防守機體" class="w-40 h-40 object-contain mx-auto mb-3">
                                    <h3 id="intro-defender-name" class="text-xl font-bold mb-1 text-cyan-300">防守機體名稱</h3>
                                    <p id="intro-defender-type" class="text-sm mb-3 text-gray-300">移動類型</p>
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-pink-400 font-bold">命中:</span>
                                        <span id="intro-defender-hit" class="font-mono font-bold text-pink-300">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-2 mb-3 rounded-full overflow-hidden">
                                        <div id="intro-defender-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-cyan-400 font-bold">迴避:</span>
                                        <span id="intro-defender-dodge" class="font-mono font-bold text-cyan-300">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden">
                                        <div id="intro-defender-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="text-center mt-6">
                            <div id="intro-countdown" class="hidden">3</div>
                            <p class="text-gray-300 text-lg font-bold animate-pulse">準備進入戰鬥!</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // 添加CSS樣式
        const introCombatStyle = document.createElement('style');
        introCombatStyle.textContent = `
            .stars-bg {
                background-image: 
                    radial-gradient(2px 2px at 20px 30px, #eee, rgba(0,0,0,0)),
                    radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)),
                    radial-gradient(1px 1px at 90px 40px, #ddd, rgba(0,0,0,0)),
                    radial-gradient(2px 2px at 160px 120px, #fff, rgba(0,0,0,0));
                background-repeat: repeat;
                background-size: 200px 200px;
                animation: stars-scrolling 8s linear infinite;
                opacity: 0.6;
            }
            
            @keyframes stars-scrolling {
                from {
                    background-position: 0 0;
                }
                to {
                    background-position: 0 200px;
                }
            }
            
            .animation-delay-500 {
                animation-delay: 500ms;
            }
        `;
        document.head.appendChild(introCombatStyle);
        
        // Start combat mode with introduction window
        function startCombat(attackerPiece, defenderPiece, attackerPos, defenderPos) {
            // Store combat information
            combatMode.active = true;
            combatMode.attacker = attackerPiece;
            combatMode.defender = defenderPiece;
            combatMode.attackerPos = attackerPos;
            combatMode.defenderPos = defenderPos;
            
            // Determine if player is attacker or defender
            if (gameState.gameMode === 'single-player') {
                combatMode.isPlayerAttacker = attackerPiece.team === BLUE;
                combatMode.isPlayerDefender = defenderPiece.team === BLUE;
            } else if (gameState.gameMode === 'multiplayer') {
                // In multiplayer, host is blue team, client is red team
                combatMode.isPlayerAttacker = (isHost && attackerPiece.team === BLUE) || 
                                             (!isHost && attackerPiece.team === RED);
                combatMode.isPlayerDefender = (isHost && defenderPiece.team === BLUE) || 
                                             (!isHost && defenderPiece.team === RED);
            }
            
            // 創建並顯示介紹彈窗
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = combatIntroHTML;
            const introOverlay = tempDiv.firstElementChild;
            document.body.appendChild(introOverlay);
            
            // 暗化棋盤元素
            const boardDim = document.createElement('div');
            boardDim.id = 'board-dim';
            boardDim.className = 'fixed inset-0 bg-black bg-opacity-60 z-[140] transition-opacity duration-500 opacity-0';
            document.body.appendChild(boardDim);
            
            // 取得移動類型的中文名稱
            function getMoveTypeText(moveType) {
                switch(moveType) {
                    case PAWN: return "步兵";
                    case ROOK: return "城堡";
                    case KNIGHT: return "騎士";
                    case BISHOP: return "主教";
                    case QUEEN: return "皇后";
                    case KING: return "國王";
                    default: return "";
                }
            }
            
            // 填充介紹視窗數據
            const maxValue = 5; // 假設最大值是5
            
            // 攻擊方數據
            document.getElementById('intro-attacker-img').src = attackerPiece.imgUrl;
            document.getElementById('intro-attacker-name').textContent = attackerPiece.type;
            document.getElementById('intro-attacker-type').textContent = `移動類型: ${getMoveTypeText(attackerPiece.moveType)}`;
            document.getElementById('intro-attacker-hit').textContent = attackerPiece.hit;
            document.getElementById('intro-attacker-dodge').textContent = attackerPiece.dodge;
            document.getElementById('intro-attacker-hit-bar').style.width = `${(attackerPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-attacker-dodge-bar').style.width = `${(attackerPiece.dodge / maxValue) * 100}%`;
            
            // 防守方數據
            document.getElementById('intro-defender-img').src = defenderPiece.imgUrl;
            document.getElementById('intro-defender-name').textContent = defenderPiece.type;
            document.getElementById('intro-defender-type').textContent = `移動類型: ${getMoveTypeText(defenderPiece.moveType)}`;
            document.getElementById('intro-defender-hit').textContent = defenderPiece.hit;
            document.getElementById('intro-defender-dodge').textContent = defenderPiece.dodge;
            document.getElementById('intro-defender-hit-bar').style.width = `${(defenderPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-defender-dodge-bar').style.width = `${(defenderPiece.dodge / maxValue) * 100}%`;
            
            // 延遲顯示元素，創造淡入效果
            setTimeout(() => {
                introOverlay.style.opacity = '1';
                boardDim.style.opacity = '1';
            }, 50);
            
            // 倒數計時
            let countdown = 3;
            const countdownEl = document.getElementById('intro-countdown');
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    
                    // 淡出介紹視窗和暗化層
                    introOverlay.style.opacity = '0';
                    boardDim.style.opacity = '0';
                    
                    // 移除元素並開始戰鬥
                    setTimeout(() => {
                        if (introOverlay.parentNode) introOverlay.parentNode.removeChild(introOverlay);
                        if (boardDim.parentNode) boardDim.parentNode.removeChild(boardDim);
                        
                        // 初始化戰鬥模式
                        initCombat();
                    }, 500); // 等待淡出動畫完成
                } else {
                    countdownEl.textContent = countdown;
                }
            }, 1000);
            
            // 實際初始化戰鬥
            function initCombat() {
                // Reset combat state 
                combatMode.timer = 3;
                combatMode.timeRemaining = 3000;
                combatMode.lastFrameTime = 0;
                combatMode.bulletFired = false;
                combatMode.defenderMoving = false;
                combatMode.result = null;
                
                // Show appropriate role information
                attackerRole.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                defenderRole.style.display = combatMode.isPlayerDefender ? 'block' : 'none';
                attackerInstruction.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                defenderInstruction.style.display = combatMode.isPlayerDefender ? 'block' : 'none';
                
                // Set crosshair size based on the formula
                // Formula: (攻方命中值 - 2)*50 + 100 px
                combatMode.crosshairSize = (attackerPiece.hit - 2) * 50 + 100;
                crosshair.style.width = `${combatMode.crosshairSize}px`;
                crosshair.style.height = `${combatMode.crosshairSize}px`;
                
                // Set inner crosshair size to 3/4 of outer size
                const innerSize = combatMode.crosshairSize * 0.75;
                crosshair.querySelector('.crosshair-inner').style.width = `${innerSize}px`;
                crosshair.querySelector('.crosshair-inner').style.height = `${innerSize}px`;
                
                // Make crosshair lines match the size
                crosshair.querySelector('.crosshair-horizontal').style.width = `${combatMode.crosshairSize}px`;
                crosshair.querySelector('.crosshair-vertical').style.height = `${combatMode.crosshairSize}px`;
                
                // Set defender size to fixed 100px (already in combatMode initialization)
                defender.style.width = `${combatMode.defenderSize}px`;
                defender.style.height = `${combatMode.defenderSize}px`;
                
                // Set defender speed based on the formula
                // Formula: (守方回避值 - 2)*5 + 10 px / frame
                combatMode.defenderSpeed = (defenderPiece.dodge - 2) * 5 + 10;
                
                // Update combat info panel
                attackerName.textContent = attackerPiece.type;
                defenderName.textContent = defenderPiece.type;
                attackerImage.src = attackerPiece.imgUrl;
                defenderImage.src = defenderPiece.imgUrl;
                
                // Set stat bars
                const maxHit = 5; // Assume 5 is max hit value
                const maxDodge = 5; // Assume 5 is max dodge value
                
                const hitPercentage = (attackerPiece.hit / maxHit) * 100;
                const dodgePercentage = (defenderPiece.dodge / maxDodge) * 100;
                
                attackerHitBar.style.width = `${hitPercentage}%`;
                defenderDodgeBar.style.width = `${dodgePercentage}%`;
                
                // Set combat info text
                combatInfo.textContent = `${attackerPiece.type} vs ${defenderPiece.type}`;
                
                // Set defender image
                defender.innerHTML = `<img src="${defenderPiece.imgUrl}" alt="${defenderPiece.type}">`;
                
                // Set initial positions
                const containerRect = combatContainer.getBoundingClientRect();
                
                // Generate random offsets within specified ranges (250-550px for X, 150-450px for Y)
                const offsetX = Math.floor(Math.random() * (550 - 250 + 1)) + 250; // 250-550之間的隨機值
                const offsetY = Math.floor(Math.random() * (450 - 150 + 1)) + 150; // 150-450之間的隨機值
                
                // Set defender position using center coordinates plus random offsets
                combatMode.defenderX = containerRect.width / 2 + offsetX;  // 中央X座標 + 隨機偏移
                combatMode.defenderY = containerRect.height / 2 + offsetY; // 中央Y座標 + 隨機偏移
                
                defender.style.left = `${combatMode.defenderX}px`;
                defender.style.top = `${combatMode.defenderY}px`;
                
                // Start crosshair near the defender but not directly on it
                if (combatMode.isPlayerAttacker) {
                    combatMode.mouseX = containerRect.width / 2 + 50;
                    combatMode.mouseY = containerRect.height / 2 + 50;
                } else {
                    // For AI, initialize offscreen until game starts
                    combatMode.mouseX = -100;
                    combatMode.mouseY = -100;
                }
                crosshair.style.left = `${combatMode.mouseX}px`;
                crosshair.style.top = `${combatMode.mouseY}px`;
                
                // Hide result text
                combatResult.classList.remove('show');
                
                // Initialize the space background
                initSpaceBackground();
                
                // Show the combat overlay
                combatOverlay.classList.remove('hidden');
                
                // Add event listeners for combat
                if (combatMode.isPlayerAttacker) {
                    combatContainer.addEventListener('mousemove', handleAttackerMouseMove);
                    combatContainer.addEventListener('click', handleAttackerClick);
                    combatContainer.addEventListener('touchmove', handleAttackerTouchMove);
                    combatContainer.addEventListener('touchstart', handleAttackerTouch);
                }
                
                if (combatMode.isPlayerDefender) {
                    combatContainer.addEventListener('mousemove', handleDefenderMouseMove);
                    combatContainer.addEventListener('click', handleDefenderClick);
                    combatContainer.addEventListener('touchmove', handleDefenderTouchMove);
                    combatContainer.addEventListener('touchstart', handleDefenderTouch);
                    
                    // Show the defender target indicator
                    defenderTarget.style.display = 'block';
                }
                
                // Start AI if needed
                if (!combatMode.isPlayerAttacker) {
                    setTimeout(startAIAttacker, 1000); // Slight delay before AI attacks
                }
                
                if (!combatMode.isPlayerDefender) {
                    startAIDefender();
                }
                
                // Start combat animation frame loop
                requestAnimationFrame(updateCombat);
            }
        }
        
        // Handle attacker mouse movement
        function handleAttackerMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;
            
            const rect = combatContainer.getBoundingClientRect();
            
            // Get mouse position relative to container
            combatMode.mouseX = e.clientX - rect.left;
            combatMode.mouseY = e.clientY - rect.top;
            
            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
            
            // Send position to opponent in multiplayer
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendCombatAction('mouseMove', { x: combatMode.mouseX, y: combatMode.mouseY });
            }
        }
        
        // Handle attacker touch movement
        function handleAttackerTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();
            
            // Get touch position relative to container
            combatMode.mouseX = touch.clientX - rect.left;
            combatMode.mouseY = touch.clientY - rect.top;
            
            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
            
            // Send position to opponent in multiplayer
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendCombatAction('mouseMove', { x: combatMode.mouseX, y: combatMode.mouseY });
            }
        }
        
        // Handle attacker click (shooting)
        function handleAttackerClick(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            shootLaser();
        }
        
        // Handle attacker touch (shooting)
        function handleAttackerTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            e.preventDefault();
            shootLaser();
        }
        
        // Handle defender mouse movement
        function handleDefenderMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;
            
            const rect = combatContainer.getBoundingClientRect();
            
            // Record target position for click to move
            combatMode.defenderTargetX = e.clientX - rect.left;
            combatMode.defenderTargetY = e.clientY - rect.top;
            
            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }
        
        // Handle defender touch movement
        function handleDefenderTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();
            
            // Record target position for touch to move
            combatMode.defenderTargetX = touch.clientX - rect.left;
            combatMode.defenderTargetY = touch.clientY - rect.top;
            
            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }
        
        // Handle defender click (evasive move)
        function handleDefenderClick(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            startDefenderMovement();
        }
        
        // Handle defender touch (evasive move)
        function handleDefenderTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            e.preventDefault();
            startDefenderMovement();
        }
        
        // Start the defender movement to target
        function startDefenderMovement() {
            combatMode.defenderMoving = true;
            
            // Reset defender movement after 200ms (was 500ms)
            setTimeout(() => {
                combatMode.defenderMoving = false;
            }, 200); // 200ms maximum move time as requested
            
            // Send to opponent in multiplayer
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendCombatAction('defenderMove', { 
                    startX: combatMode.defenderX,
                    startY: combatMode.defenderY,
                    targetX: combatMode.defenderTargetX,
                    targetY: combatMode.defenderTargetY
                });
            }
        }
        
        // Shooting laser (one shot only) - ENHANCED!
        function shootLaser() {
            if (combatMode.bulletFired) return;
            
            combatMode.bulletFired = true;
            
            const containerRect = combatContainer.getBoundingClientRect();
            
            // Create multiple laser beams for a more spectacular effect
            for (let i = 0; i < 6; i++) { // Increased from 4 to 6 lasers
                setTimeout(() => {
                    // Main laser beam
                    const laser = document.createElement('div');
                    laser.className = 'laser';
                    
                    // Position laser at crosshair
                    laser.style.left = `${combatMode.mouseX}px`;
                    laser.style.top = `${combatMode.mouseY}px`;
                    
                    // Random angle for visual variety
                    const baseAngle = i * 60; // Spread evenly around 360 degrees
                    const angle = baseAngle + (Math.random() * 20 - 10); // Small random variation
                    const length = containerRect.width * 1.5; // Longer laser
                    
                    laser.style.width = `${length}px`;
                    laser.style.height = `${Math.random() * 3 + 5}px`; // Thicker lasers (5-8px)
                    laser.style.transform = `rotate(${angle}deg)`;
                    
                    combatContainer.appendChild(laser);
                    
                    // Add a glow effect behind the laser
                    const glow = document.createElement('div');
                    glow.className = 'laser-glow';
                    glow.style.left = `${combatMode.mouseX}px`;
                    glow.style.top = `${combatMode.mouseY}px`;
                    glow.style.width = `${length}px`;
                    glow.style.height = `${Math.random() * 10 + 20}px`; // Thicker glow
                    glow.style.transform = `rotate(${angle}deg)`;
                    
                    combatContainer.appendChild(glow);
                    
                    // Remove after animation
                    setTimeout(() => {
                        if (laser.parentNode) laser.parentNode.removeChild(laser);
                        if (glow.parentNode) glow.parentNode.removeChild(glow);
                    }, 300);
                }, i * 40); // Stagger the laser beams
            }
            
            // Check hit detection
            checkHit();
            
            // Send to opponent in multiplayer
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendCombatAction('shoot', { x: combatMode.mouseX, y: combatMode.mouseY });
            }
            
            // If missed, end combat after a short delay
            if (!combatMode.result) {
                setTimeout(() => {
                    endCombat('defender');
                }, 500);
            }
        }
        
        // Check if laser hit the defender
        function checkHit() {
            // Get positions and sizes
            const defenderRect = {
                x: combatMode.defenderX - (combatMode.defenderSize / 2),
                y: combatMode.defenderY - (combatMode.defenderSize / 2),
                width: combatMode.defenderSize,
                height: combatMode.defenderSize
            };
            
            const crosshairRect = {
                x: combatMode.mouseX - (combatMode.crosshairSize / 2),
                y: combatMode.mouseY - (combatMode.crosshairSize / 2),
                width: combatMode.crosshairSize,
                height: combatMode.crosshairSize
            };
            
            // Simple rectangle collision detection
            if (
                crosshairRect.x < defenderRect.x + defenderRect.width &&
                crosshairRect.x + crosshairRect.width > defenderRect.x &&
                crosshairRect.y < defenderRect.y + defenderRect.height &&
                crosshairRect.y + crosshairRect.height > defenderRect.y
            ) {
                // Hit! Create explosion effect
                createExplosion(combatMode.defenderX, combatMode.defenderY);
                
                // Attacker wins
                endCombat('attacker');
            }
        }
        
        // Create explosion effect - ENHANCED!
        function createExplosion(x, y) {
            // Main explosion
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = `${x}px`;
            explosion.style.top = `${y}px`;
            combatContainer.appendChild(explosion);
            
            // Create spark particles - MORE AND PRETTIER
            for (let i = 0; i < 40; i++) { // Doubled from 20 to 40 particles
                const spark = document.createElement('div');
                spark.className = 'spark';
                
                // Random position around explosion center
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 70 + 30; // Increased distance
                const sparkX = x + Math.cos(angle) * distance;
                const sparkY = y + Math.sin(angle) * distance;
                
                spark.style.left = `${sparkX}px`;
                spark.style.top = `${sparkY}px`;
                
                // Enhanced color palette
                const colors = [
                    '#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB', '#FFFFFF',
                    '#FF00FF', '#DA70D6', '#EE82EE', '#FF77FF', '#FFD700'
                ];
                const color = colors[Math.floor(Math.random() * colors.length)];
                spark.style.backgroundColor = color;
                spark.style.color = color; // For box-shadow glow
                
                // Animation
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkSpeed = Math.random() * 150 + 100; // Faster particles
                const sparkDuration = Math.random() * 600 + 600; // Longer duration
                
                combatContainer.appendChild(spark);
                
                // Animate the spark
                let startTime = null;
                function animateSpark(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = (timestamp - startTime) / sparkDuration;
                    
                    if (progress < 1) {
                        const moveX = Math.cos(sparkAngle) * sparkSpeed * progress;
                        const moveY = Math.sin(sparkAngle) * sparkSpeed * progress;
                        
                        spark.style.left = `${sparkX + moveX}px`;
                        spark.style.top = `${sparkY + moveY}px`;
                        spark.style.opacity = 1 - progress;
                        
                        requestAnimationFrame(animateSpark);
                    } else {
                        if (spark.parentNode) {
                            spark.parentNode.removeChild(spark);
                        }
                    }
                }
                
                requestAnimationFrame(animateSpark);
            }
            
            // Secondary explosions for more spectacular effect
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const secondaryExplosion = document.createElement('div');
                    secondaryExplosion.className = 'explosion';
                    // Position secondary explosions slightly offset from main explosion
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = (Math.random() - 0.5) * 60;
                    secondaryExplosion.style.left = `${x + offsetX}px`;
                    secondaryExplosion.style.top = `${y + offsetY}px`;
                    // Make secondary explosions smaller
                    secondaryExplosion.style.transform = 'translate(-50%, -50%) scale(0.7)';
                    combatContainer.appendChild(secondaryExplosion);
                    
                    // Remove secondary explosion after animation
                    setTimeout(() => {
                        if (secondaryExplosion.parentNode) {
                            secondaryExplosion.parentNode.removeChild(secondaryExplosion);
                        }
                    }, 600);
                }, i * 200); // Stagger the secondary explosions
            }
            
            // Remove explosion after animation
            setTimeout(() => {
                if (explosion.parentNode) {
                    explosion.parentNode.removeChild(explosion);
                }
            }, 600);
        }
        
        // Update combat state
        function updateCombat(timestamp) {
            if (!combatMode.active) return;
            
            // First frame initialization
            if (!combatMode.lastFrameTime) {
                combatMode.lastFrameTime = timestamp;
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
                return;
            }
            
            const deltaTime = timestamp - combatMode.lastFrameTime;
            combatMode.lastFrameTime = timestamp;
            
            // Update timer
            if (!combatMode.result && !combatMode.bulletFired) {
                combatMode.timeRemaining -= deltaTime;
                combatMode.timer = Math.max(0, Math.ceil(combatMode.timeRemaining / 1000));
                combatTimer.textContent = combatMode.timer;
                
                // Check if time's up
                if (combatMode.timeRemaining <= 0) {
                    // Defender wins if time runs out
                    endCombat('defender');
                }
            }
            
            // Update defender position
            if (combatMode.defenderMoving && !combatMode.result) {
                // Calculate direction vector
                const dx = combatMode.defenderTargetX - combatMode.defenderX;
                const dy = combatMode.defenderTargetY - combatMode.defenderY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) { // Stop moving when close to target
                    // Normalize and apply speed
                    const moveX = (dx / distance) * combatMode.defenderSpeed;
                    const moveY = (dy / distance) * combatMode.defenderSpeed;
                    
                    combatMode.defenderX += moveX;
                    combatMode.defenderY += moveY;
                    
                    // Keep defender within bounds
                    const containerRect = combatContainer.getBoundingClientRect();
                    combatMode.defenderX = Math.max(combatMode.defenderSize / 2, 
                                                   Math.min(containerRect.width - combatMode.defenderSize / 2, 
                                                           combatMode.defenderX));
                    combatMode.defenderY = Math.max(combatMode.defenderSize / 2, 
                                                   Math.min(containerRect.height - combatMode.defenderSize / 2, 
                                                           combatMode.defenderY));
                    
                    // Update defender position
                    defender.style.left = `${combatMode.defenderX}px`;
                    defender.style.top = `${combatMode.defenderY}px`;
                    
                } else {
                    // Reached target, stop moving
                    combatMode.defenderMoving = false;
                }
            }
            
            // Continue animation
            if (combatMode.active) {
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
            }
        }
        
        // AI for defender movement
        function startAIDefender() {
            if (!combatMode.active) return;
            
            const containerRect = combatContainer.getBoundingClientRect();
            
            // Set initial target for AI defender
            combatMode.defenderTargetX = combatMode.defenderX;
            combatMode.defenderTargetY = combatMode.defenderY;
            
            const chooseEvasiveDirection = () => {
                if (!combatMode.active || combatMode.result || combatMode.defenderMoving) return;
                
                // Calculate random movement distance based on dodge value
                // Formula: (守方回避值 - 2)*25 + 50 px
                const moveDistance = (combatMode.defender.dodge - 2) * 25 + 50;
                
                // Choose a random direction to move
                const angle = Math.random() * Math.PI * 2;
                
                // Use the new moveDistance formula instead of random distance
                combatMode.defenderTargetX = containerRect.width / 2 + Math.cos(angle) * moveDistance;
                combatMode.defenderTargetY = containerRect.height / 2 + Math.sin(angle) * moveDistance;
                
                // Keep within bounds
                combatMode.defenderTargetX = Math.max(combatMode.defenderSize / 2, 
                                                    Math.min(containerRect.width - combatMode.defenderSize / 2, 
                                                            combatMode.defenderTargetX));
                combatMode.defenderTargetY = Math.max(combatMode.defenderSize / 2, 
                                                    Math.min(containerRect.height - combatMode.defenderSize / 2, 
                                                            combatMode.defenderTargetY));
                
                // Start movement
                startDefenderMovement();
            };
            
            // Perform evasive movement occasionally
            const aiInterval = setInterval(() => {
                if (!combatMode.active) {
                    clearInterval(aiInterval);
                    return;
                }
                
                chooseEvasiveDirection();
            }, 800);
            
            // Initial evasion
            setTimeout(chooseEvasiveDirection, 500);
        }
        
        // AI for attacker (aiming and shooting)
        function startAIAttacker() {
            if (!combatMode.active || combatMode.bulletFired) return;
            
            const containerRect = combatContainer.getBoundingClientRect();
            
            // Set initial crosshair position
            combatMode.mouseX = containerRect.width / 2;
            combatMode.mouseY = containerRect.height / 2;
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
            
            // Start tracking defender - 跟蹤間隔從100毫秒改為300毫秒
            const trackInterval = setInterval(() => {
                if (!combatMode.active || combatMode.bulletFired) {
                    clearInterval(trackInterval);
                    return;
                }
                
                // Move crosshair toward defender with some error margin
                const difficultyFactor = 1 - (combatMode.attacker.hit * 0.1);
                // 瞄準誤差公式從 * 100 改為 * 200，使AI瞄準更不精確
                const errorX = (Math.random() - 0.5) * 200 * difficultyFactor;
                const errorY = (Math.random() - 0.5) * 200 * difficultyFactor;
                
                combatMode.mouseX = combatMode.defenderX + errorX;
                combatMode.mouseY = combatMode.defenderY + errorY;
                
                crosshair.style.left = `${combatMode.mouseX}px`;
                crosshair.style.top = `${combatMode.mouseY}px`;
            }, 300);
            
            // Wait a random time before shooting
            const shootDelay = 1000 + Math.random() * 1500;
            setTimeout(() => {
                if (combatMode.active && !combatMode.bulletFired) {
                    shootLaser();
                }
                clearInterval(trackInterval);
            }, shootDelay);
        }
        
        // End combat
        function endCombat(winner) {
            if (combatMode.result) return; // Already ended
            
            combatMode.result = winner;
            
            // Show result
            combatResult.textContent = winner === 'attacker' 
                ? `${combatMode.attacker.type} 勝利！` 
                : `${combatMode.defender.type} 成功閃避！`;
            
            combatResult.classList.add('show');
            
            // Remove event listeners
            combatContainer.removeEventListener('mousemove', handleAttackerMouseMove);
            combatContainer.removeEventListener('click', handleAttackerClick);
            combatContainer.removeEventListener('touchmove', handleAttackerTouchMove);
            combatContainer.removeEventListener('touchstart', handleAttackerTouch);
            
            combatContainer.removeEventListener('mousemove', handleDefenderMouseMove);
            combatContainer.removeEventListener('click', handleDefenderClick);
            combatContainer.removeEventListener('touchmove', handleDefenderTouchMove);
            combatContainer.removeEventListener('touchstart', handleDefenderTouch);
            
            // Send result to opponent in multiplayer
            if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                sendCombatAction('combatEnd', { winner });
            }
            
            // End combat and update game state after a delay
            setTimeout(() => {
                combatOverlay.classList.add('hidden');
                combatMode.active = false;
                
                if (combatMode.frameRequest) {
                    cancelAnimationFrame(combatMode.frameRequest);
                    combatMode.frameRequest = null;
                }
                
                // 在更改遊戲狀態前，確保清除任何可能排隊的AI移動計時器
                if (aiMoveTimer) {
                    console.log("戰鬥結束時清除了待執行的AI移動計時器");
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }
                
                // Update game state based on combat result
                if (winner === 'attacker') {
                    // Attacker wins - complete the capture
                    const { attackerPos, defenderPos } = combatMode;
                    movePiece(attackerPos.row, attackerPos.col, defenderPos.row, defenderPos.col);
                } else {
                    // Defender wins - pieces stay where they are, but turn changes
                    gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;
                    updateTurnIndicator();
                    statusMessage.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合。`;
                    
                    // Send updated game state to peer if in multiplayer mode
                    if (gameState.gameMode === 'multiplayer' && connection && connection.open) {
                        sendGameState();
                    }
                    
                    // Clear selection
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                }
                
                // If AI's turn after combat, schedule its move
                if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                    // 使用全局aiMoveTimer變量來控制延遲執行
                    console.log("戰鬥結束後安排新的AI移動");
                    aiMoveTimer = setTimeout(makeAIMove, 500);
                }
            }, 1500);
        }
        
        // AI Move Logic
        function makeAIMove() {
            // 確保是AI的回合再執行移動 - 新增檢查以防止錯誤回合移動
            if (gameState.gameOver || combatMode.active || gameState.currentTurn !== RED) {
                console.log(`AI移動被取消 - 原因: ${gameState.gameOver ? '遊戲結束' : combatMode.active ? '戰鬥模式中' : '不是紅方回合'}`);
                return;
            }
            
            const now = Date.now();
            aiMoveCount++;
            
            // 計算並記錄AI移動間隔時間
            if (lastAIMoveTime !== 0) {
                const interval = now - lastAIMoveTime;
                console.log(`AI移動間隔 #${aiMoveCount}: ${interval}毫秒`);
            }
            lastAIMoveTime = now;
            
            console.log(`AI開始決策移動... (時間戳: ${now}, 當前回合: ${gameState.currentTurn})`);
            
            // Find all pieces of current team (RED for AI)
            const aiTeam = RED;
            let allPossibleMoves = [];
            
            // Collect all possible moves
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.team === aiTeam) {
                        const validMoves = calculateValidMoves(row, col);
                        validMoves.forEach(move => {
                            allPossibleMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                piece: piece,
                                targetPiece: gameState.board[move.row][move.col]
                            });
                        });
                    }
                }
            }
            
            // If no moves, game over - but we don't show victory screen for this case
            if (allPossibleMoves.length === 0) {
                gameState.gameOver = true;
                gameState.winner = BLUE;
                statusMessage.textContent = `遊戲結束！藍方通過將軍獲勝！`;
                // 移除勝利畫面的顯示，只改變遊戲狀態和訊息
                return;
            }
            
            // Prioritize moves
            allPossibleMoves.sort((a, b) => {
                // Prioritize captures over non-captures
                if (a.targetPiece && !b.targetPiece) return -1;
                if (!a.targetPiece && b.targetPiece) return 1;
                
                // For captures, prioritize higher value pieces
                if (a.targetPiece && b.targetPiece) {
                    const aValue = getPieceValue(a.targetPiece.moveType);
                    const bValue = getPieceValue(b.targetPiece.moveType);
                    if (aValue !== bValue) return bValue - aValue;
                }
                
                // Add some randomness
                return Math.random() - 0.5;
            });
            
            // Choose the best move
            const chosenMove = allPossibleMoves[0];
            
            console.log(`AI選擇移動: ${chosenMove.piece.type} 從 [${chosenMove.fromRow},${chosenMove.fromCol}] 到 [${chosenMove.toRow},${chosenMove.toCol}] ${chosenMove.targetPiece ? '（捕獲目標）' : '（普通移動）'}`);
            
            // If move is a capture, initiate combat
            if (chosenMove.targetPiece) {
                gameState.selectedPiece = { row: chosenMove.fromRow, col: chosenMove.fromCol };
                startCombat(chosenMove.piece, chosenMove.targetPiece, 
                            { row: chosenMove.fromRow, col: chosenMove.fromCol }, 
                            { row: chosenMove.toRow, col: chosenMove.toCol });
            } else {
                // Regular move
                movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
            }
        }
        
        // Helper to get piece values for AI decision making
        function getPieceValue(moveType) {
            switch(moveType) {
                case PAWN: return 1;
                case KNIGHT: return 3;
                case BISHOP: return 3;
                case ROOK: return 5;
                case QUEEN: return 9;
                case KING: return 100;
                default: return 0;
            }
        }
        
        // Show toast notification
        function showToast(message, duration = 2000) {
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }
        
        // P2P functions
        function initPeer() {
            if (peer) {
                peer.destroy();
            }
            
            // Generate a random room ID (6 characters)
            const generateRoomId = () => {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            };
            
            const roomId = generateRoomId();
            const peerId = `gundam-chess-${roomId}`;
            
            // Create peer with specific ID for easier room management
            peer = new Peer(peerId);
            
            peer.on('open', (id) => {
                console.log("Peer opened with ID:", id);
                myRoomIdEl.value = roomId;
                connectionStatus.textContent = "房間ID已生成。將此ID分享給對手進行連接。";
            });
            
            peer.on('connection', (conn) => {
                console.log("Received connection from:", conn.peer);
                connection = conn;
                remotePeerId = conn.peer;
                isHost = true;
                
                setupConnectionHandlers();
                connectionStatus.textContent = "對手已連接！即將進入遊戲...";
                
                // Show game UI after a brief delay
                setTimeout(() => {
                    multiplayerSetup.classList.remove('show');
                    gameUI.style.display = 'block';
                    
                    // Initialize game
                    gameState.gameMode = 'multiplayer';
                    createBoard();
                    initializeGame();
                    
                    showNetworkStatus('已連接為主機 (藍隊)', 'bg-green-500');
                }, 1500);
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                
                let errorMessage = "連接錯誤";
                if (err.type === 'peer-unavailable') {
                    errorMessage = "找不到該房間ID，請確認ID正確";
                } else if (err.type === 'network') {
                    errorMessage = "網絡連接錯誤，請檢查您的網絡";
                } else if (err.type === 'server-error') {
                    errorMessage = "服務器錯誤，請稍後再試";
                } else if (err.type === 'browser-incompatible') {
                    errorMessage = "瀏覽器不支持此功能";
                }
                
                connectionStatus.textContent = errorMessage;
                showNetworkStatus('連接錯誤', 'bg-red-500');
            });
        }
        
        function connectToPeer(roomId) {
            if (!peer || !peer.id) {
                connectionStatus.textContent = "請等待您的Peer ID生成";
                return;
            }
            
            if (roomId === myRoomIdEl.value) {
                connectionStatus.textContent = "您不能連接到自己的房間";
                return;
            }
            
            // Create target peer ID from room ID
            const targetPeerId = `gundam-chess-${roomId}`;
            
            connectingOverlay.classList.remove('hidden');
            connectionMessage.textContent = "正在連接到對手...";
            
            console.log("Attempting to connect to:", targetPeerId);
            
            try {
                connection = peer.connect(targetPeerId, {
                    reliable: true
                });
                
                if (!connection) {
                    connectionStatus.textContent = "無法建立連接，請稍後再試";
                    connectingOverlay.classList.add('hidden');
                    return;
                }
                
                remotePeerId = targetPeerId;
                isHost = false;
                
                setupConnectionHandlers();
            } catch (err) {
                console.error("Connection error:", err);
                connectionStatus.textContent = "連接錯誤: " + err.message;
                connectingOverlay.classList.add('hidden');
            }
        }
        
        function setupConnectionHandlers() {
            if (!connection) return;
            
            connection.on('open', () => {
                connectionStatus.textContent = "已連接到對手！即將進入遊戲...";
                connectingOverlay.classList.add('hidden');
                
                if (!isHost) {
                    // If client (red player), show game UI after a brief delay
                    setTimeout(() => {
                        multiplayerSetup.classList.remove('show');
                        gameUI.style.display = 'block';
                        
                        // Initialize game
                        gameState.gameMode = 'multiplayer';
                        createBoard();
                        initializeGame();
                        
                        showNetworkStatus('已連接為客戶端 (紅隊)', 'bg-green-500');
                    }, 1500);
                }
            });
            
            connection.on('data', (data) => {
                if (data.type === 'gameState') {
                    gameState = data.state;
                    updateBoardDisplay();
                    updateTurnIndicator();
                    updateCapturedPieces();
                    
                    // Check if game is over and show victory screen if needed
                    if (gameState.gameOver) {
                        statusMessage.textContent = `遊戲結束！${gameState.winner === BLUE ? '藍方' : '紅方'}勝利！`;
                        showVictoryScreen(gameState.winner);
                    } else {
                        statusMessage.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合。`;
                    }
                } else if (data.type === 'combatAction') {
                    // Handle combat synchronization in multiplayer
                    handleRemoteCombatAction(data);
                } else if (data.type === 'resetRequest') {
                    // Handle reset request
                    resetRequestReceived = true;
                    resetMessage.textContent = "對方請求重置遊戲並返回主畫面。您同意嗎？";
                    resetConfirm.classList.add('show');
                } else if (data.type === 'resetResponse') {
                    // Handle reset response
                    if (data.accepted) {
                        // Reset and return to cover page
                        resetGame();
                        showCoverPage();
                    } else {
                        // Reset rejected
                        resetMessage.textContent = "對方拒絕了重置請求。";
                        resetConfirmBtn.disabled = false;
                        resetConfirmBtn.style.opacity = 1;
                        resetWaiting.style.display = 'none';
                        
                        // Auto-hide after delay
                        setTimeout(() => {
                            resetConfirm.classList.remove('show');
                        }, 2000);
                    }
                }
            });
            
            connection.on('close', () => {
                connectionStatus.textContent = "連接已關閉";
                showNetworkStatus('已斷開連接', 'bg-red-500');
                connection = null;
                
                // Alert user and show option to return to main menu
                if (gameState.gameMode === 'multiplayer') {
                    resetMessage.textContent = "連接已斷開。對手離開了遊戲。是否返回主畫面？";
                    resetConfirm.classList.add('show');
                    resetRequestReceived = true; // Treat as received request for UX purposes
                }
            });
            
            connection.on('error', (err) => {
                console.error('Connection error:', err);
                connectionStatus.textContent = `連接錯誤: ${err}`;
                showNetworkStatus('連接錯誤', 'bg-red-500');
            });
        }
        
        function sendGameState() {
            if (connection && connection.open) {
                connection.send({
                    type: 'gameState',
                    state: gameState
                });
            }
        }
        
        // Handle remote combat actions in multiplayer
        function handleRemoteCombatAction(data) {
            if (!combatMode.active) return;
            
            switch (data.action) {
                case 'mouseMove':
                    if (!combatMode.isPlayerAttacker) {
                        combatMode.mouseX = data.x;
                        combatMode.mouseY = data.y;
                        crosshair.style.left = `${combatMode.mouseX}px`;
                        crosshair.style.top = `${combatMode.mouseY}px`;
                    }
                    break;
                    
                case 'shoot':
                    if (!combatMode.isPlayerAttacker && !combatMode.bulletFired) {
                        combatMode.mouseX = data.x;
                        combatMode.mouseY = data.y;
                        crosshair.style.left = `${combatMode.mouseX}px`;
                        crosshair.style.top = `${combatMode.mouseY}px`;
                        shootLaser();
                    }
                    break;
                    
                case 'defenderMove':
                    if (!combatMode.isPlayerDefender) {
                        combatMode.defenderX = data.startX;
                        combatMode.defenderY = data.startY;
                        combatMode.defenderTargetX = data.targetX;
                        combatMode.defenderTargetY = data.targetY;
                        combatMode.defenderMoving = true;
                        
                        // Reset defender movement after 200ms (was 500ms)
                        setTimeout(() => {
                            combatMode.defenderMoving = false;
                        }, 200);
                    }
                    break;
                    
                case 'combatEnd':
                    endCombat(data.winner);
                    break;
            }
        }
        
        // Send combat actions to opponent in multiplayer
        function sendCombatAction(action, data = {}) {
            if (gameState.gameMode !== 'multiplayer' || !connection || !connection.open) return;
            
            connection.send({
                type: 'combatAction',
                action,
                ...data
            });
        }
        
        function showNetworkStatus(message, bgClass) {
            networkStatus.textContent = message;
            networkStatus.className = networkStatus.className.replace(/bg-\w+-\d+/, '');
            networkStatus.classList.add(bgClass);
            networkStatus.classList.remove('hidden');
        }
        
        // Initialize the cover page space background
        setupSpaceBackground(document.getElementById('cover-space-bg'));
    </script>

</body></html>