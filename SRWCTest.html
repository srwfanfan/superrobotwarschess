<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://qph.cf2.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content; report-uri https://www.quora.com/poe_api/csp_report_3RD_PARTY_POST; report-to csp-endpoint;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ë∂ÖÁ¥öÊ©üÊ¢∞‰∫∫Â§ßÊà∞Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // Ê∑ªÂä†ÂÖ®Â±ÄË®àÊôÇÂô®ÔºåË®òÈåÑÈ†ÅÈù¢Âä†ËºâÈñãÂßãÊôÇÈñì
        window.gameLoadStartTime = Date.now();

        // ÂÖ®Â±ÄÈåØË™§ËôïÁêÜÂáΩÊï∏
        window.onerror = function(message, source, lineno, colno, error) {
            // ËøîÂõûfalseËÆìÁÄèË¶ΩÂô®ÁπºÁ∫åÈ°ØÁ§∫ÈåØË™§
            return false;
        };

        // ÂÆâÂÖ®ÁöÑinnerHTMLË®≠ÁΩÆÂáΩÊï∏
        function safeSetInnerHTML(element, html) {
            if (!element) {
                return false;
            }
            element.innerHTML = html;
            return true;
        }

        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'primary': '#5D5CDE',
                        'board-light': '#f0d9b5',
                        'board-dark': '#b58863',
                        'highlight': 'rgba(93, 92, 222, 0.5)',
                        'valid-move': 'rgba(0, 255, 0, 0.3)',
                        'attack-move': 'rgba(255, 0, 0, 0.3)'
                    }
                }
            }
        }
    </script>
    <style>
        /* Cover Page Styles */
        .cover-page {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #000428, #004e92);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 5vh;
            transition: 0.5s ease opacity;
        }

        .cover-page.hide {
            opacity: 0;
            pointer-events: none;
        }

        .cover-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: white;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            to { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(93, 92, 222, 0.6); }
        }

        .cover-buttons {
            display: grid;
            grid-template: auto auto / 1fr 1fr;
            gap: 1rem;
            width: 100%;
            max-width: 500px;
        }

        .cover-button {
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .cover-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Space Background */
        .space-bg {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 1px;
            height: 1px;
            background: white;
            border-radius: 50%;
        }

        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 50%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transform-origin: right center;
            animation: shoot 3s ease-out infinite;
        }

        @keyframes shoot {
            0% {
                opacity: 0;
                transform: translateX(0) rotate(0deg);
            }
            15% {
                opacity: 1;
            }
            30% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
        }

        /* Game Board Styles */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            background-image: url('https://i.imgur.com/po1uZL5.png');
            background-size: cover;
            background-position: center;
        }

        .chess-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }

        .chess-board .light, .chess-board .dark,
        .dark .chess-board .light, .dark .chess-board .dark {
            background-color: transparent;
        }

        .piece-img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            position: relative;
            z-index: 10;
            transition: all 0.2s ease;
        }

        .piece-overlay {
            position: absolute;
            inset: 0;
            z-index: 11;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none;
        }

        .blue-overlay {
            background-color: rgba(0, 0, 255, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
        }

        .red-overlay {
            background-color: rgba(255, 0, 0, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            transform: scaleX(-1);
        }

        .valid-move-indicator {
            position: absolute;
            width: 40%;
            height: 40%;
            border-radius: 50%;
            opacity: 0.7;
            z-index: 5;
        }

        .coordinate {
            position: absolute;
            font-size: 0.7rem;
            opacity: 0;
            z-index: 5;
            display: none;
        }

        .top-left {
            top: 2px;
            left: 2px;
        }

        .selected {
            animation: blink 1s infinite;
            box-shadow: inset 0 0 0 4px rgba(93, 92, 222, 0.7);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Victory Overlay */
        .victory-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10vh;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            visibility: hidden;
        }

        .victory-overlay.show {
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }

        .victory-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            max-width: 90%;
            width: 600px;
            transform: scale(0.8);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .victory-overlay.show .victory-card {
            transform: scale(1);
        }

        .victory-card::before {
            content: '';
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            background: linear-gradient(
                135deg,
                transparent,
                rgba(255, 255, 255, 0.05),
                transparent,
                transparent
            );
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% {
                left: -100%;
                top: -100%;
            }
            50%, 100% {
                left: 100%;
                top: 100%;
            }
        }

        .victory-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px currentColor;
            animation: pulse 2s infinite;
        }

        .blue-victory {
            color: #4169E1;
            background: linear-gradient(135deg, #000428, #004e92);
        }

        .blue-victory .victory-title {
            color: #4169E1;
        }

        .red-victory {
            color: #DC143C;
            background: linear-gradient(135deg, #16222A, #3A1C71);
        }

        .red-victory .victory-title {
            color: #DC143C;
        }

        .victory-message {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: white;
        }

        .victory-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(-20px);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
            50% {
                opacity: 0.8;
                text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
        }

        .victory-reset {
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .victory-reset:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .victory-confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            opacity: 0.7;
            animation: confetti-fall linear forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh)) rotate(90deg);
                opacity: 0;
            }
        }

        /* Combat Mini-Game Styles */
        .combat-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            padding-top: 20px;
        }

        .combat-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 25px rgba(93, 92, 222, 0.8);
            cursor: default;
        }

        .combat-info-panel {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 800px;
            height: auto;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 15px rgba(93, 92, 222, 0.6);
            overflow: hidden;
            margin-bottom: 10px;
        }

        .attacker-info, .defender-info {
            display: flex;
            align-items: center;
            padding: 1.5% 2%;
            position: relative;
            height: 24%;
            box-sizing: border-box;
        }

        .attacker-info {
            background: linear-gradient(to bottom, rgba(255,0,85,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .defender-info {
            background: linear-gradient(to top, rgba(0,255,200,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .unit-image {
            height: 20%;
            width: 20%;
            object-fit: contain;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.7));
        }

        .unit-stats {
            display: flex;
            flex-direction: column;
            margin: 0 10px;
            color: white;
        }

        .unit-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        .stat-bar {
            width: 150px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            margin: 3px 0;
            overflow: hidden;
            position: relative;
        }

        .hit-stat {
            background: linear-gradient(90deg, #FF1493 0%, #FF69B4 100%);
        }

        .dodge-stat {
            background: linear-gradient(90deg, #00CED1 0%, #40E0D0 100%);
        }

        .attacker-role, .defender-role {
            position: absolute;
            top: -40px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .attacker-role {
            left: 10px;
            background: linear-gradient(90deg, #FF1493 0%, #C71585 100%);
        }

        .defender-role {
            right: 10px;
            background: linear-gradient(90deg, #20B2AA 0%, #5F9EA0 100%);
        }

        .attacker-instruction, .defender-instruction {
            position: absolute;
            bottom: 10px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            width: 45%;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .attacker-instruction {
            left: 10px;
        }

        .defender-instruction {
            right: 10px;
        }

        .space-background {
            position: absolute;
            inset: 0;
            background: rgba(85, 85, 85, 0.05); /* Á¥îÁÅ∞Ëâ≤ËÉåÊôØÔºå5%ÈÄèÊòéÂ∫¶ */
            overflow: hidden;
        }

        .combat-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .timer {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            background: linear-gradient(135deg, #ff0099, #493240);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,0,153,0.5);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }

        .crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -50%);
        }

        .crosshair-horizontal, .crosshair-vertical {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0) 100%);
        }

        .crosshair-horizontal {
            top: 50%;
            left: 0;
            height: 4px;
            width: 100%; /* Ê∑ªÂä†Ê≠§Ë°åÔºåÁ°Æ‰øùÊ∞¥Âπ≥Á∫øÂç†Êª°ÂÆπÂô®ÂÆΩÂ∫¶ */
            transform: translateY(-50%);
        }

        .crosshair-vertical {
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            transform: translateX(-50%);
        }

        .crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: rgba(255, 20, 147, 0.5);
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
            animation: pulse 1.5s infinite;
            width: 10px; /* Ê∑ªÂä†Ê≠§Ë°åÔºåÁªôÂÜÖÂúÜ‰∏Ä‰∏™ÈªòËÆ§ÂÆΩÂ∫¶ */
            height: 10px; /* Ê∑ªÂä†Ê≠§Ë°åÔºåÁªôÂÜÖÂúÜ‰∏Ä‰∏™ÈªòËÆ§È´òÂ∫¶ */
        }

        .defender {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 8;
            transition: top 0.05s linear, left 0.05s linear;
        }

        .defender img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(0,255,200,0.7));
        }

        .defender-target {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px dashed rgba(0, 255, 200, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 7;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 10px rgba(0,255,200,0.5);
            animation: targetPulse 1.5s infinite;
        }

        @keyframes targetPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(0.8); }
        }

        .laser {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0.5) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0.5) 100%);
            transform-origin: center left;
            z-index: 9;
            opacity: 0;
            animation: laser-pulse 0.3s ease-out;
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
            height: 0.625%;
        }

        .laser-glow {
            position: absolute;
            background: rgba(255,20,147,0.1);
            transform-origin: center left;
            z-index: 8;
            opacity: 0;
            animation: laser-glow 0.5s ease-out;
            filter: blur(10px);
            height: 2.5%;
        }

        @keyframes laser-pulse {
            0% { opacity: 0.7; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes laser-glow {
            0% { opacity: 0.3; transform: scale(1, 3); }
            50% { opacity: 0.5; transform: scale(1, 5); }
            100% { opacity: 0; transform: scale(1, 2); }
        }

        .explosion {
            position: absolute;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,105,180,0.8) 30%, rgba(255,20,147,0.6) 70%, rgba(0,0,0,0) 100%);
            z-index: 20;
            transform: translate(-50%, -50%);
            animation: explode 0.6s forwards;
            box-shadow: 0 0 30px #FF1493, 0 0 60px #FF1493;
        }

        @keyframes explode {
            0% { width: 0; height: 0; opacity: 1; }
            70% { opacity: 1; }
            100% { width: 31.25%; height: 31.25%; opacity: 0; }
        }

        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            z-index: 19;
            opacity: 1;
            box-shadow: 0 0 5px currentColor;
        }

        .combat-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 0 30px rgba(255,20,147,0.7);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }

        .combat-result.show {
            opacity: 1;
            animation: resultPulse 2s infinite;
        }

        @keyframes resultPulse {
            0% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
            50% { box-shadow: 0 0 50px rgba(255,20,147,1); }
            100% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
        }

        /* Level System Styles */
        .level-info-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 400;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            overflow-y: auto;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .level-info-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .level-info-card {
            background: linear-gradient(135deg, #000428, #004e92);
            max-width: 800px;
            width: 90%;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(93, 92, 222, 0.5);
            overflow: hidden;
            transform: translateY(-20px);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white;
            transform: scale(0.7);
            font-size: 70%;
        }

        .level-info-overlay.show .level-info-card {
            transform: translateY(0);
        }

        .level-header {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            position: relative;
        }

        .level-title {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: left;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 10px rgba(93, 92, 222, 0.8);
        }

        .level-subtitle {
            font-size: 1.1rem;
            text-align: left;
            color: #ccc;
        }

        .level-content {
            padding: 20px;
        }

        .level-image-container {
            width: 100%;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .level-image {
            max-width: 80%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .level-story {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .level-story-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .level-story-content {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ddd;
        }

        .level-conditions {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .level-conditions-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .victory-condition {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            color: #4ADE80;
        }

        .defeat-condition {
            display: flex;
            align-items: center;
            color: #F87171;
        }

        .condition-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }

        .level-footer {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        .start-level-btn {
            background: linear-gradient(135deg, #5D5CDE, #4338CA);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 8px 20px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.4);
        }

        .start-level-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(93, 92, 222, 0.6);
        }

        /* Event Dialog */
        .event-dialog {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5D5CDE;
            border-radius: 10px;
            padding: 15px;
            z-index: 350;
            display: none;
            color: white;
            box-shadow: 0 0 20px rgba(93, 92, 222, 0.5);
        }

        .dialog-character {
            font-weight: bold;
            margin-bottom: 8px;
            color: #5D5CDE;
        }

        .dialog-content {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .dialog-next {
            text-align: right;
            font-style: italic;
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Mission Popup */
        .mission-popup {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-left: 4px solid #5D5CDE;
            padding: 10px 15px;
            color: white;
            border-radius: 5px;
            z-index: 300;
            max-width: 80%;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mission-popup.show {
            opacity: 1;
        }

        .mission-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }

        .mission-title i {
            margin-right: 8px;
            color: #5D5CDE;
        }

        .mission-desc {
            font-size: 0.9rem;
            color: #ddd;
        }

        /* Angel Gundam Confirm */
        .angel-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .angel-confirm-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .angel-confirm-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            transition: transform 0.5s ease, opacity 0.5s ease;
            opacity: 0;
            position: relative;
            overflow: hidden;
        }

        .angel-confirm-overlay.show .angel-confirm-card {
            transform: translateY(0);
            opacity: 1;
        }

        .angel-confirm-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0) 70%);
            animation: angel-pulse 3s infinite;
        }

        @keyframes angel-pulse {
            0% { opacity: 0.1; }
            50% { opacity: 0.3; }
            100% { opacity: 0.1; }
        }

        .angel-header {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .angel-image {
            width: 120px;
            height: 120px;
            object-fit: contain;
            animation: angel-float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.7));
        }

        @keyframes angel-float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        .angel-title {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .angel-desc {
            font-size: 1.2rem;
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .angel-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .angel-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #ccc;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .angel-stat-hit .stat-value {
            color: #FF69B4;
        }

        .angel-stat-dodge .stat-value {
            color: #40E0D0;
        }

        .angel-stat-type .stat-value {
            color: #9370DB;
            font-size: 1.2rem;
        }

        .angel-confirm-btn {
            background: linear-gradient(135deg, #5D5CDE, #4338CA);
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 12px 40px;
            border-radius: 50px;
            border: none;
            display: block;
            margin: 0 auto;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .angel-confirm-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(45deg);
            animation: angel-btn-shine 3s infinite;
        }

        @keyframes angel-btn-shine {
            0% { left: -100%; }
            30%, 100% { left: 100%; }
        }

        .angel-confirm-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        /* Settings */
        .stars-bg {
            background-image:
                radial-gradient(2px 2px at 20px 30px, #eee, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 90px 40px, #ddd, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 160px 120px, #fff, rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 200px 200px;
            animation: stars-scrolling 8s linear infinite;
            opacity: 0.6;
        }

        @keyframes stars-scrolling {
            from {
                background-position: 0 0;
            }
            to {
                background-position: 0 200px;
            }
        }

        .animation-delay-500 {
            animation-delay: 500ms;
        }

        /* Reset Confirm Dialog */
        .reset-confirm {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1002;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .reset-confirm.show {
            opacity: 1;
            pointer-events: auto;
        }

        .reset-dialog {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            max-width: 90%;
            width: 400px;
            text-align: center;
        }

        .reset-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
        }

        .reset-message {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            color: #555;
        }

        .reset-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .reset-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .confirm-btn {
            background: #5D5CDE;
            color: white;
        }

        .confirm-btn:hover {
            background: #4A49B0;
        }

        .cancel-btn {
            background: #f3f4f6;
            color: #333;
        }

        .cancel-btn:hover {
            background: #e5e7eb;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .cover-title {
                font-size: 2rem;
            }

            .cover-buttons {
                max-width: 250px;
            }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        /* Turn Indicator */
        .turn-indicator {
            width: 20px;
            height: 20px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
        }

        /* Network Status */
        #network-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50;
        }

        /* Loader */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #5D5CDE;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* CSVÂä†ËºâÊèêÁ§∫Ê°ÜÊ®£Âºè */
        .csv-loading-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .csv-loading-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            width: 400px;
            text-align: center;
            color: white;
        }

        .csv-loading-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .csv-loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }

        /* Ê∑ªÂä†Êñ∞ÁöÑÊîªÊìäÈ°ûÂûãÊåáÁ§∫Âô®Ê®£Âºè */
        .attack-type-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            z-index: 15;
        }

        .attack-type-1 {
            background-color: rgba(255, 0, 0, 0.7);
        }

        .attack-type-2 {
            background-color: rgba(0, 0, 255, 0.7);
        }

        .attack-type-3 {
            background-color: rgba(0, 255, 0, 0.7);
        }

        /* ÂõûÂêàËΩ¨Êç¢ÊèêÁ§∫Ê†∑Âºè */
        .turn-transition-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .turn-transition-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .turn-transition-card {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 50, 0.8));
            border-radius: 15px;
            padding: 30px 60px;
            transform: scale(0.8) translateY(-30px);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .turn-transition-overlay.show .turn-transition-card {
            transform: scale(1) translateY(0);
        }

        .turn-transition-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        .blue-turn .turn-transition-title {
            color: #4169E1;
            text-shadow: 0 0 10px rgba(65, 105, 225, 0.7);
        }

        .red-turn .turn-transition-title {
            color: #DC143C;
            text-shadow: 0 0 10px rgba(220, 20, 60, 0.7);
        }

        .turn-transition-subtitle {
            font-size: 1.2rem;
            color: white;
            opacity: 0.8;
            position: relative;
            z-index: 10;
        }

        /* Âä®ÁîªÊïàÊûú */
        .turn-transition-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(45deg);
            animation: shine 1.5s forwards ease-out;
            z-index: 1;
        }

        @keyframes shine {
            0% {
                transform: rotate(45deg) translateX(-100%) translateY(-100%);
            }
            100% {
                transform: rotate(45deg) translateX(100%) translateY(100%);
            }
        }

        /* ËæπÊ°ÜÊïàÊûú */
        .blue-turn .turn-transition-card {
            box-shadow: 0 0 30px rgba(65, 105, 225, 0.5);
            border: 1px solid rgba(65, 105, 225, 0.5);
        }

        .red-turn .turn-transition-card {
            box-shadow: 0 0 30px rgba(220, 20, 60, 0.5);
            border: 1px solid rgba(220, 20, 60, 0.5);
        }

        /* ËÉåÊôØÂÖÉÁ¥† */
        .turn-transition-bg-element {
            position: absolute;
            border-radius: 50%;
            opacity: 0.15;
            filter: blur(10px);
            z-index: 1;
            animation: float 3s ease-in-out infinite alternate;
        }

        .blue-turn .turn-transition-bg-element {
            background: radial-gradient(circle, #4169E1, transparent);
        }

        .red-turn .turn-transition-bg-element {
            background: radial-gradient(circle, #DC143C, transparent);
        }

        @keyframes float {
            0% {
                transform: translateY(0) scale(1);
            }
            100% {
                transform: translateY(-10px) scale(1.05);
            }
        }

        /* Êï∞Â≠óËÆ°Êï∞Âä®Áîª */
        .turn-counter-anim {
            position: absolute;
            left: 45%;
            transform: translateX(-50%);
            top: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            z-index: 10;
            opacity: 0;
            animation: countFade 1.5s forwards;
        }

        @keyframes countFade {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(0);
            }
            20% {
                opacity: 1;
            }
            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(-15px);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px);
            }
        }

        /* Â∞ÜÂÜõË≠¶ÂëäÊ†∑Âºè */
        #check-warning.show {
          opacity: 1;
          visibility: visible;
          animation: pulse-warning 2s infinite;
          pointer-events: all;
        }

        @keyframes pulse-warning {
           0%, 100% {
            transform: translateX(-50%) scale(1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
          }
          50% {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
          }
        }

    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen p-4">
    <!-- Cover Page -->
    <div id="cover-page" class="cover-page">
        <div class="space-bg" id="cover-space-bg"></div>
        <div class="flex justify-center w-full mb-4">
            <img src="./images/BluePlanet.png" alt="ÊòüÁêÉ" class="max-w-[240px] h-auto">
        </div>
        <div class="flex justify-center w-full">
            <img src="./images/SRWCLogo.png" alt="Ë∂ÖÁ¥öÊ©üÊ¢∞‰∫∫Â§ßÊà∞Chess" class="max-w-[90%] h-auto mb-8">
        </div>
        <div class="cover-buttons">
            <button id="singleplayer-cover-btn" class="cover-button">ÈñãÂßãÈÅäÊà≤</button>
            <button id="tutorial-cover-btn" class="cover-button">È´îÈ©óÊà∞È¨•</button>
            <button id="settings-cover-btn" class="cover-button">ÈÅäÊà≤Ë®≠ÂÆö</button>
            <a id="contact-cover-btn" href="https://www.instagram.com/srwfanfan" target="_blank" class="cover-button">ËÅØÁµ°‰ΩúËÄÖ</a>
        </div>
    </div>

    <!-- Victory Overlay -->
    <div id="victory-overlay" class="victory-overlay">
        <div id="victory-card" class="victory-card">
            <div id="victory-icon" class="victory-icon">üèÜ</div>
            <h2 id="victory-title" class="victory-title">ÂãùÂà©ÔºÅ</h2>
            <p id="victory-message" class="victory-message">ÊÅ≠ÂñúÊÇ®Áç≤ÂæóÂãùÂà©ÔºÅ</p>
            <div class="flex justify-center space-x-4">
                <button id="save-progress-btn" class="victory-reset">ÂÑ≤Â≠òÈÄ≤Â∫¶</button>
                <button id="victory-reset" class="victory-reset">ËøîÂõû‰∏ªÁï´Èù¢</button>
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[1000] flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-300">
        <div class="relative max-w-md w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform transition-all duration-500">
            <div class="absolute inset-0 overflow-hidden opacity-20">
                <div class="stars-bg absolute inset-0"></div>
            </div>

            <div class="relative p-6 md:p-8">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">ÈÅäÊà≤Ë®≠ÂÆö</h2>
                </div>

                <div class="space-y-6 text-gray-300">
                    <!-- Êà∞È¨•AIÈõ£Â∫¶ -->
                    <div>
                        <label class="block mb-2 font-medium">Êà∞È¨•AIÈõ£Â∫¶</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm">Á∞°ÂñÆ</span>
                            <input type="range" id="combat-ai-difficulty" min="1" max="5" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm">Âõ∞Èõ£</span>
                        </div>
                    </div>

                    <!-- ‰∏ãÊ£ãAIÈõ£Â∫¶ -->
                    <div>
                        <label class="block mb-2 font-medium">‰∏ãÊ£ãAIÈõ£Â∫¶</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm">Á∞°ÂñÆ</span>
                            <input type="range" id="chess-ai-difficulty" min="1" max="5" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm">Âõ∞Èõ£</span>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end mt-8">
                    <button id="settings-close-btn" class="px-6 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none">
                        ÈóúÈñâ
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Combat Mini-Game Overlay -->
    <div id="combat-overlay" class="combat-overlay hidden">
        <div id="attacker-role" class="attacker-role">‰Ω†ÊòØÊîªÊìäËÄÖ</div>
        <div id="defender-role" class="defender-role">‰Ω†ÊòØÈò≤ÂÆàËÄÖ</div>

        <div class="combat-wrapper mx-auto" style="width: 80%; max-width: 640px;">
            <!-- Attacker Info Panel -->
            <div class="combat-info-panel">
                <div class="attacker-info">
                    <img id="attacker-image" class="unit-image" src="" alt="ÊîªÊìäÊ©üÈ´î">
                    <div class="unit-stats">
                        <div id="attacker-name" class="unit-name">ÊîªÊìäËÄÖÊ©üÈ´î</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-pink-300">ÂëΩ‰∏≠:</span>
                            <div class="stat-bar">
                                <div id="attacker-hit-bar" class="hit-stat" style="width: 60%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="combat-container" id="combat-container">
                <div class="space-background" id="space-background"></div>
                <div class="combat-info" id="combat-info">ÊîªÊìäËÄÖ vs Èò≤ÂÆàËÄÖ</div>
                <div class="timer" id="combat-timer">3</div>

                <div class="attacker-instruction" id="attacker-instruction">ÁßªÂãïÊªëÈº†ÁûÑÊ∫ñÔºåÈªûÊìäÂ∑¶ÈçµÂ∞ÑÊìäÔºàÂÉÖ‰∏ÄÊ¨°Ê©üÊúÉÔºâ</div>
                <div class="defender-instruction" id="defender-instruction">ÁßªÂãïÊªëÈº†ÈÅ∏ÊìáÊñπÂêëÔºåÈªûÊìäÂ∑¶ÈçµÈÄ≤Ë°åÈñÉÈÅø</div>

                <div class="crosshair" id="crosshair">
                    <div class="crosshair-horizontal"></div>
                    <div class="crosshair-vertical"></div>
                    <div class="crosshair-inner"></div>
                </div>

                <div class="defender" id="defender">
                    <!-- Defender image will be set dynamically -->
                </div>

                <div class="defender-target" id="defender-target"></div>

                <div class="combat-result" id="combat-result">ÊîªÊìäËÄÖÂãùÂà©ÔºÅ</div>
            </div>

            <!-- Defender Info Panel -->
            <div class="combat-info-panel mt-2">
                <div class="defender-info">
                    <div class="unit-stats">
                        <div id="defender-name" class="unit-name">Èò≤ÂÆàËÄÖÊ©üÈ´î</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-cyan-300">Ëø¥ÈÅø:</span>
                            <div class="stat-bar">
                                <div id="defender-dodge-bar" class="dodge-stat" style="width: 80%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                    <img id="defender-image" class="unit-image" src="" alt="Èò≤ÂÆàÊ©üÈ´î">
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Main Game UI -->
    <div class="max-w-7xl mx-auto" id="game-ui" style="display: none;">
        <div class="grid md:grid-cols-3 gap-8">
            <!-- Chess Board -->
            <div class="md:col-span-2">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow aspect-square flex items-center justify-center">
                    <div id="board-container" class="w-[93%] h-[93%] flex items-center justify-center">
                        <div class="chess-board" id="chess-board"></div>
                    </div>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="md:col-span-1 space-y-6">
                <!-- Piece Information Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">ËÉΩÂäõÂèÉÊï∏</h2>
                    <div id="piece-info" class="p-3 bg-gray-100 dark:bg-gray-700 rounded-lg h-[150px] flex flex-col justify-center items-center">
                        <div id="piece-info-default" class="text-center text-gray-500 dark:text-gray-400">
                            ÊªëÈº†ÁßªËá≥Ê£ãÂ≠ê‰∏äÊñπÊü•ÁúãË©≥Á¥∞Ë≥áË®ä
                        </div>
                        <div id="piece-info-content" class="w-full hidden">
                            <div class="flex items-center mb-2">
                                <img id="piece-info-image" src="" alt="" class="w-16 h-16 object-contain mr-3">
                                <div>
                                    <h3 id="piece-info-name" class="font-bold"></h3>
                                    <p id="piece-info-type" class="text-sm"></p>
                                    <p id="piece-info-crosshair" class="text-sm text-purple-500 dark:text-purple-400"></p>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-pink-500 dark:text-pink-400">ÂëΩ‰∏≠ÂÄº:</span>
                                        <span id="piece-info-hit-value" class="text-sm font-bold text-pink-500 dark:text-pink-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-hit" class="bg-pink-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-cyan-500 dark:text-cyan-400">Ëø¥ÈÅøÂÄº:</span>
                                        <span id="piece-info-dodge-value" class="text-sm font-bold text-cyan-500 dark:text-cyan-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-dodge" class="bg-cyan-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Status Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow overflow-hidden">
                    <h2 class="text-xl font-semibold mb-3">ÈÅäÊà≤ÁãÄÊÖã</h2>
                    <div class="hidden">
                        <span class="turn-indicator" id="turn-indicator"></span>
                        <span id="turn-text">ËóçÊñπÂõûÂêà</span>
                    </div>
                    <div id="status-message" class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 dark:from-blue-700 dark:to-purple-800 text-white rounded-lg min-h-[60px] flex items-center justify-center font-bold text-center shadow-lg text-lg mb-4">
                        ÈÅäÊà≤Ê∫ñÂÇôÂ∞±Á∑í„ÄÇËóçÊñπÂÖàË°å„ÄÇ
                    </div>

                    <!-- Turn Counter -->
                    <div class="mb-4 p-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-center">
                        <span class="text-lg font-bold">ÂõûÂêàÊï∏Ôºö</span>
                        <span id="turn-count" class="text-lg font-bold text-primary">0</span>
                    </div>
                </div>

                <!-- Game Controls Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">ÈÅäÊà≤ÊéßÂà∂</h2>
                    <div class="flex justify-center space-x-4 mt-4">
                        <button id="load-progress-btn" class="px-6 py-3 bg-blue-500 text-white rounded-lg font-bold text-lg hover:bg-blue-600 transition">ËºâÂÖ•ÈÄ≤Â∫¶</button>
                        <button id="reset-btn" class="px-6 py-3 bg-red-500 text-white rounded-lg font-bold text-lg hover:bg-red-600 transition">ÈáçÁΩÆÈÅäÊà≤</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Info Overlay -->
    <div id="level-info-overlay" class="level-info-overlay">
        <div class="level-info-card">
            <div class="level-header">
                <h1 id="level-title" class="level-title">Á¨¨‰∏ÄË©±</h1>
                <h2 id="level-subtitle" class="level-subtitle"></h2>
            </div>

            <div class="level-content">
                <div class="level-image-container">
                    <img id="level-image" class="level-image" src="" alt="ÈóúÂç°ÂúñÁâá">
                </div>

                <div class="level-story">
                    <h3 class="level-story-title">ÊïÖ‰∫ãÁ∞°‰ªã</h3>
                    <p id="level-story-content" class="level-story-content"></p>
                </div>

                <div class="level-conditions">
                    <h3 class="level-conditions-title">‰ªªÂãôÊ¢ù‰ª∂</h3>
                    <div id="victory-condition" class="victory-condition">
                        <span class="condition-icon">‚úì</span>
                        <span id="victory-text">ÂãùÂà©Ê¢ù‰ª∂ÔºöÂêÉÊéâÂ∞çÊñπÁöÑÂúãÁéãÊ£ã</span>
                    </div>
                    <div id="defeat-condition" class="defeat-condition">
                        <span class="condition-icon">‚úó</span>
                        <span id="defeat-text">Êà∞ÊïóÊ¢ù‰ª∂ÔºöÂúãÁéãÊ£ãË¢´Â∞çÊñπÂêÉÊéâ</span>
                    </div>
                </div>
            </div>

            <div class="level-footer">
                <button id="start-level-btn" class="start-level-btn">ÈñãÂßã‰ªªÂãô</button>
            </div>
        </div>
    </div>

    <!-- Â∞ÜÂÜõË≠¶ÂëäÊ∂àÊÅØ -->
    <div id="check-warning" class="fixed top-[10%] left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-red-600 to-red-800 text-white py-4 px-6 rounded-lg shadow-lg z-[1000] flex items-center justify-center text-2xl font-bold opacity-0 invisible transition-all duration-500 pointer-events-none">
        <div class="text-3xl mr-3">‚ö†Ô∏è</div>
        <div class="check-warning-text">ÊÇ®Ë¢´Â∞áËªç‰∫ÜÔºÅË´ãÁ´ãÂç≥ÊáâÂ∞çÔºÅ</div>
    </div>
    
    <!-- Event Dialog -->
    <div id="event-dialog" class="event-dialog">
        <div id="dialog-character" class="dialog-character">„Ç≠„É£„É©„ÇØ„Çø„Éº</div>
        <div id="dialog-content" class="dialog-content">Â∞çË©±ÂÖßÂÆπÂ∞áÈ°ØÁ§∫Âú®ÈÄôË£°...</div>
        <div class="dialog-next">ÈªûÊìäÁπºÁ∫å</div>
    </div>

    <!-- Mission Popup -->
    <div id="mission-popup" class="mission-popup">
        <div class="mission-title">
            <i>‚òÖ</i>
            <span>Êñ∞‰ªªÂãô</span>
        </div>
        <div id="mission-desc" class="mission-desc">‰ªªÂãôÊèèËø∞Â∞áÈ°ØÁ§∫Âú®ÈÄôË£°...</div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[1100] flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-500"></div>

    <!-- CSVÂä†ËºâÊèêÁ§∫Ê°Ü -->
    <div id="csv-loading-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[2000] flex items-center justify-center" style="display: none;">
        <div class="relative max-w-md w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform" style="margin-top: 0; top: 50%; left: 50%; transform: translate(-50%, -50%); position: fixed;">
            <div class="absolute inset-0 overflow-hidden opacity-20">
                <div class="stars-bg absolute inset-0"></div>
            </div>
            <div class="relative p-6 md:p-8 text-center">
                <div class="w-16 h-16 mx-auto mb-4 border-4 border-t-primary border-r-transparent border-b-transparent border-l-transparent rounded-full animate-spin"></div>
                <h3 class="text-xl font-bold text-white mb-2">Ê≠£Âú®ËºâÂÖ•ÈóúÂç°Êï∏Êìö</h3>
                <p id="csv-loading-message" class="text-gray-300">Ê≠£Âú®ÂæûÂ§ñÈÉ®Êï∏ÊìöÊ∫êÁç≤ÂèñÈóúÂç°‰ø°ÊÅØ...</p>
            </div>
        </div>
    </div>

    <!-- ÂõûÂêàËΩ¨Êç¢ÊèêÁ§∫ -->
    <div id="turn-transition-overlay" class="turn-transition-overlay">
        <div id="turn-transition-card" class="turn-transition-card">
            <!-- ËÉåÊôØÂÖÉÁ¥† -->
            <div class="turn-transition-bg-element" style="width: 100px; height: 100px; top: -30px; left: -30px;"></div>
            <div class="turn-transition-bg-element" style="width: 80px; height: 80px; bottom: -20px; right: -20px;"></div>

            <!-- ÂõûÂêàËÆ°Êï∞Âô®Âä®Áîª -->
            <div id="turn-counter-anim" class="turn-counter-anim">Á¨¨ <span id="turn-number-anim">0</span> ÂõûÂêà</div>

            <!-- ‰∏ªË¶ÅÂÜÖÂÆπ -->
            <h2 id="turn-transition-title" class="turn-transition-title">ËóçÊñπÂõûÂêà</h2>
            <p id="turn-transition-subtitle" class="turn-transition-subtitle">Ë´ãÊåáÊèÆÊÇ®ÁöÑÊ©üÈ´îË°åÂãï</p>
        </div>
    </div>

    <script>
        // È†êË®≠‰ΩøÁî®Dark Mode
        document.documentElement.classList.add('dark');

        // ‰ªçÁÑ∂Áõ£ËÅΩÁ≥ªÁµ±ÂÅèÂ•ΩËÆäÂåñÔºå‰ΩÜÈ†êË®≠‰øùÊåÅdark mode
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            // ‰∏çÁÆ°Á≥ªÁµ±ÂÅèÂ•ΩÂ¶Ç‰ΩïÔºå‰øùÊåÅdark mode
            document.documentElement.classList.add('dark');
        });

        // Game state and constants
        const BOARD_SIZE = 8;
        const BLUE = 'blue';
        const RED = 'red';

        // Piece movement types
        const PAWN = 'pawn';
        const ROOK = 'rook';
        const KNIGHT = 'knight';
        const BISHOP = 'bishop';
        const QUEEN = 'queen';
        const KING = 'king';

        // Combat mode state
        let combatMode = {
            active: false,
            attacker: null,
            defender: null,
            attackerPos: null,
            defenderPos: null,
            timer: 3,
            timeRemaining: 3000, // in milliseconds
            timerInterval: null,
            frameRequest: null,
            lastFrameTime: 0,
            mouseX: 0,
            mouseY: 0,
            defenderX: 0,
            defenderY: 0,
            defenderTargetX: 0,
            defenderTargetY: 0,
            defenderMoving: false,
            defenderSpeed: 0, // will be set based on defender's dodge value as percentage of container
            crosshairSize: 0, // will be set based on attacker's hit value as percentage of container
            defenderSizePercent: 20, // Fixed defender size: 20% of container width
            isPlayerAttacker: false,
            isPlayerDefender: false,
            bulletFired: false,
            result: null // 'attacker' or 'defender'
        };

        // Èö±ËóèË¶ÅÁ¥†Áõ∏Èóú‰ª£Á¢º
        let Get_fa_gundam = 0;
        
        // Ê∑ªÂä†BGMÂèäSEÁõ∏Èóú‰ª£Á¢º
        let battleBgmPlayer = null;
        let introMusicPlayer = null;
        let boardBgmPlayer = null;
        let currentBattleBgmType = null;

        let beamGunSound = null;
        let beamSaberSound = null;
        let cosmoNovaSound = null;
        let thunderSound = null;
        let explosionSound = null;
        let soundsLoaded = false;

        // Game state
        let gameState = {
            board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
            currentTurn: BLUE,
            selectedPiece: null,
            validMoves: [],
            gameMode: 'single-player',
            blueCaptured: [],
            redCaptured: [],
            gameOver: false,
            winner: null,
            turnCount: 0 // ÂàùÂßãÂåñÂõûÂêàË®àÊï∏
        };

        // AIÁßªÂãïÊôÇÈñìËøΩËπ§
        let lastAIMoveTime = 0;
        let aiMoveCount = 0;

        // AIÁßªÂãïË®àÊôÇÂô®ÂºïÁî® - Áî®ÊñºÁÆ°ÁêÜÂíåÊ∏ÖÈô§Ë®àÊôÇÂô®
        let aiMoveTimer = null;

        // ÂàùÂßãÂåñÁ©∫ÁöÑÈóúÂç°Êï∏ÊìöÔºåÂ∞áÂæûCSVËºâÂÖ•
        let levelData = [];

        // Êí≠ÊîæÊà∞È¨•BGM
        function playBattleBGM(bgmtype) {
            // Â¶ÇÊûúË¶ÅÊí≠ÊîæÁöÑÈü≥‰πê‰∏éÂΩìÂâçÊ≠£Âú®Êí≠ÊîæÁöÑÁõ∏ÂêåÔºå‰∏çÂÅö‰ªª‰ΩïÊîπÂèò
            if (currentBattleBgmType === bgmtype && battleBgmPlayer) {
                console.log('Áõ∏ÂêåBGMÂ∑≤Âú®Êí≠Êîæ‰∏≠ÔºåÁªßÁª≠Êí≠Êîæ');
                return;
            }

            // Â¶ÇÊûúÂ∑≤Á∂ìÊúâÂú®Êí≠ÊîæÁöÑBGMÔºåÂÖàÂÅúÊ≠¢
            if (battleBgmPlayer) {
                battleBgmPlayer.pause();
                battleBgmPlayer = null;
            }

            // Ê†πÊìöbgmtypeÈÅ∏ÊìáÈü≥Ê®ÇURL
            let bgmUrl = '';
            switch(bgmtype) {
                case 'Gundam':
                    bgmUrl = './audio/SRWCBGM_Gundam.mp3';
                    break;
                case 'Wingzero':
                    bgmUrl = './audio/SRWCBGM_Wingzero.mp3';
                    break;
                case 'Cybuster':
                    bgmUrl = './audio/SRWCBGM_Cybuster.mp3';
                    break;
                case 'GetterRobot':
                    bgmUrl = './audio/SRWCBGM_GetterRobot.mp3';
                    break;
                default:
                    return; // Ê≤íÊúâÂåπÈÖçÁöÑBGMÈ°ûÂûãÔºå‰∏çÊí≠Êîæ
            }

            // Êõ¥Êñ∞ÂΩìÂâçÊí≠ÊîæÁöÑBGMÁ±ªÂûã
            currentBattleBgmType = bgmtype;

            // ÂâµÂª∫Êñ∞ÁöÑÈü≥È†ªÊí≠ÊîæÂô®
            battleBgmPlayer = new Audio(bgmUrl);
            battleBgmPlayer.loop = true; // Ë®≠ÁΩÆÂæ™Áí∞Êí≠Êîæ

            // ÂòóË©¶Êí≠ÊîæÈü≥Ê®Ç
            try {
                battleBgmPlayer.play().catch(err => {
                    console.log('ÁÑ°Ê≥ïËá™ÂãïÊí≠ÊîæBGM:', err);
                    // Â§öÊï∏ÁÄèË¶ΩÂô®ÈúÄË¶ÅÁî®Êà∂‰∫§‰∫íÊâçËÉΩÊí≠ÊîæÈü≥È†ªÔºåÊ≠§ÈåØË™§ÂèØ‰ª•‰∏çËôïÁêÜ
                });
            } catch (e) {
                console.error('Êí≠ÊîæBGMÂá∫ÈåØ:', e);
            }
        }

        // ÂÅúÊ≠¢Êà∞È¨•BGM
        function stopBattleBGM() {
            if (battleBgmPlayer) {
                battleBgmPlayer.pause();
                battleBgmPlayer.currentTime = 0;
                battleBgmPlayer = null;
            }
            // ÈáçÁΩÆÂΩìÂâçBGMÁ±ªÂûã
            currentBattleBgmType = null;
            beamGunSound = null;
            explosionSound = null;
            soundsLoaded = false;
        }

        // Êí≠ÊîæÈÅäÊà≤‰ªãÁ¥πÈü≥Ê®Ç
        function playIntroMusic() {
            // Â¶ÇÊûúÂ∑≤Á∂ìÊúâÂú®Êí≠ÊîæÁöÑÈü≥Ê®ÇÔºåÂÖàÂÅúÊ≠¢
            if (introMusicPlayer) {
                introMusicPlayer.pause();
                introMusicPlayer = null;
            }

            // ÊåáÂÆö‰ªãÁ¥πÈü≥Ê®ÇÁöÑURL
            const introMusicUrl = './audio/SRWCBGM_Intro.mp3';

            // ÂâµÂª∫Êñ∞ÁöÑÈü≥È†ªÊí≠ÊîæÂô®
            introMusicPlayer = new Audio(introMusicUrl);
            introMusicPlayer.loop = true; // Ë®≠ÁΩÆÂæ™Áí∞Êí≠Êîæ

            // ÂòóË©¶Êí≠ÊîæÈü≥Ê®Ç
            try {
                introMusicPlayer.play().catch(err => {
                    console.log('ÁÑ°Ê≥ïËá™ÂãïÊí≠Êîæ‰ªãÁ¥πÈü≥Ê®Ç:', err);
                    // Â§öÊï∏ÁÄèË¶ΩÂô®ÈúÄË¶ÅÁî®Êà∂‰∫§‰∫íÊâçËÉΩÊí≠ÊîæÈü≥È†ªÔºåÊ≠§ÈåØË™§ÂèØ‰ª•‰∏çËôïÁêÜ
                });
            } catch (e) {
                console.error('Êí≠Êîæ‰ªãÁ¥πÈü≥Ê®ÇÂá∫ÈåØ:', e);
            }
        }

        // ÂÅúÊ≠¢‰ªãÁ¥πÈü≥Ê®Ç
        function stopIntroMusic() {
            if (introMusicPlayer) {
                introMusicPlayer.pause();
                introMusicPlayer.currentTime = 0;
                introMusicPlayer = null;
            }
        }

        // Êí≠ÊîæÈóúÂç°ËÉåÊôØÈü≥Ê®Ç - Ê∑ªÂä†Âú® playIntroMusic Âíå stopIntroMusic ÂáΩÊï∏Âæå
        function playBoardBGM(bgmUrl) {
            // Â¶ÇÊûúÊ≤íÊúâÊèê‰æõURLÔºåÁõ¥Êé•ËøîÂõû
            if (!bgmUrl) return;

            // ÂÖàÂÅúÊ≠¢ÊâÄÊúâÂèØËÉΩÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥Ê®Ç
            stopIntroMusic();
            stopBattleBGM();
            stopBoardBGM();

            // ÂâµÂª∫Êñ∞ÁöÑÈü≥È†ªÊí≠ÊîæÂô®
            boardBgmPlayer = new Audio(bgmUrl);
            boardBgmPlayer.loop = true; // Ë®≠ÁΩÆÂæ™Áí∞Êí≠Êîæ

            // ÂòóË©¶Êí≠ÊîæÈü≥Ê®Ç
            try {
                boardBgmPlayer.play().catch(err => {
                    console.log('ÁÑ°Ê≥ïËá™ÂãïÊí≠ÊîæÈóúÂç°ËÉåÊôØÈü≥Ê®Ç:', err);
                    // Â§öÊï∏ÁÄèË¶ΩÂô®ÈúÄË¶ÅÁî®Êà∂‰∫§‰∫íÊâçËÉΩÊí≠ÊîæÈü≥È†ªÔºåÊ≠§ÈåØË™§ÂèØ‰ª•‰∏çËôïÁêÜ
                });
            } catch (e) {
                console.error('Êí≠ÊîæÈóúÂç°ËÉåÊôØÈü≥Ê®ÇÂá∫ÈåØ:', e);
            }
        }

        // ÂÅúÊ≠¢ÈóúÂç°ËÉåÊôØÈü≥Ê®Ç
        function stopBoardBGM() {
            if (boardBgmPlayer) {
                boardBgmPlayer.pause();
                boardBgmPlayer.currentTime = 0;
                boardBgmPlayer = null;
            }
        }

        // È¢ÑÂä†ËΩΩÊàòÊñóÈü≥Êïà
        function preloadCombatSounds() {
            // Âä†ËΩΩÊøÄÂÖâÊû™Èü≥Êïà
            beamGunSound = new Audio('./soundeffects/SRWCSE_BeamGun.mp3');
            beamGunSound.load();

            // Âä†ËΩΩÁàÜÁÇ∏Èü≥Êïà
            explosionSound = new Audio('./soundeffects/SRWCSE_Explosion.mp3');
            explosionSound.load();

            // Âä†ËΩΩÂÖâÊùüÂâëÈü≥Êïà
            beamSaberSound = new Audio('./soundeffects/SRWCSE_BeamSaber.mp3');
            beamSaberSound.load();

            cosmoNovaSound = new Audio('./soundeffects/SRWCSE_CosmoNova.mp3');
            cosmoNovaSound.load();

            thunderSound = new Audio('./soundeffects/SRWCSE_Thunder.mp3');
            thunderSound.load();

            // ËÆæÁΩÆÂä†ËΩΩÂÆåÊàêÊ†áÂøó
            soundsLoaded = true;

            console.log('ÊàòÊñóÈü≥ÊïàÈ¢ÑÂä†ËΩΩÂÆåÊàê');
        }

        // Êí≠ÊîæÈü≥ÊïàÁöÑÈÄöÁî®ÂáΩÊï∞
        function playCombatSound(sound) {
            if (!sound || !soundsLoaded) return;

            try {
                // ÂÖãÈöÜÈü≥ÊïàÂØπË±°‰ª•ÊîØÊåÅÈáçÂè†Êí≠Êîæ
                const soundClone = sound.cloneNode();
                soundClone.volume = 0.7; // ËÆæÁΩÆÈü≥Èáè‰∏∫70%
                soundClone.play().catch(err => {
                    console.log('Êó†Ê≥ïÊí≠ÊîæÈü≥Êïà:', err);
                });
            } catch (e) {
                console.error('Êí≠ÊîæÈü≥ÊïàÂá∫Èîô:', e);
            }
        }

        // ‰øùÂ≠òËøõÂ∫¶Âà∞CSVÊñá‰ª∂
        function saveProgress() {
            // Ëé∑ÂèñÂΩìÂâçÈÄöÂÖ≥ÁöÑÂÖ≥Âç°Êï∞
            const completedLevel = levelManager ? levelManager.currentLevel : 0;
    
            // ÁîüÊàêÁ¨¨‰∏ÄË°å10‰ΩçÊï∞Â≠óÁªÑÂêà - ÂÖ≥Âç°ËøõÂ∫¶
            let hiddenCode1 = "";
            // Á¨¨‰∏Ä‰ΩçÊòØÈöèÊú∫Êï∞Â≠ó
            hiddenCode1 += Math.floor(Math.random() * 10);
            // Á¨¨‰∫å‰ΩçÊòØÂ∑≤ÂÆåÊàêÂÖ≥Âç°Êï∞ÂÄº
            hiddenCode1 += completedLevel;
            // ÂêéÈù¢8‰ΩçÊòØÈöèÊú∫Êï∞Â≠ó
            for (let i = 0; i < 8; i++) {
                hiddenCode1 += Math.floor(Math.random() * 10);
            }
    
            // ÁîüÊàêÁ¨¨‰∫åË°å10‰ΩçÊï∞Â≠óÁªÑÂêà - FA GundamÁä∂ÊÄÅ
            let hiddenCode2 = "";
            // Ââç9‰ΩçÊòØ0-1ÁöÑÈöèÊú∫Êï¥Êï∞
            for (let i = 0; i < 9; i++) {
                hiddenCode2 += Math.floor(Math.random() * 2);
            }
            // ÊúÄÂêé‰∏Ä‰ΩçÊòØGet_fa_gundamÁöÑÂÄº
            hiddenCode2 += Get_fa_gundam;
    
            // ÂàõÂª∫CSVÂÜÖÂÆπÔºåÂåÖÂê´‰∏§Ë°åÊï∞ÊçÆ
            const csvContent = "game_code\n" + hiddenCode1 + "\n" + hiddenCode2;
    
            // ÂàõÂª∫BlobÂØπË±°
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    
            // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
    
            // ËÆæÁΩÆÈìæÊé•Â±ûÊÄß
            link.setAttribute("href", url);
            link.setAttribute("download", "srwcsave.csv");
            link.style.visibility = 'hidden';
    
            // Ê∑ªÂä†Âà∞ÊñáÊ°£Âπ∂Ëß¶ÂèëÁÇπÂáª
            document.body.appendChild(link);
            link.click();
    
            // Ê∏ÖÁêÜ
            document.body.removeChild(link);
    
            // ÊòæÁ§∫ÊèêÁ§∫
            showToast("ÈÄ≤Â∫¶Â∑≤‰øùÂ≠ò");
        }

        // Âä†ËΩΩËøõÂ∫¶
        function loadProgress() {
            // ÂàõÂª∫Êñá‰ª∂ËæìÂÖ•ÂÖÉÁ¥†
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            // Ê∑ªÂä†Âà∞ÊñáÊ°£
            document.body.appendChild(fileInput);
    
            // ËÆæÁΩÆÊñá‰ª∂ÈÄâÊã©Â§ÑÁêÜ
            fileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) {
                    document.body.removeChild(fileInput);
                    return;
                }
        
                // ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
                const loadingOverlay = document.getElementById('csv-loading-overlay');
                loadingOverlay.style.display = 'flex';
                document.getElementById('csv-loading-message').textContent = "Ê≠£Âú®ËºâÂÖ•ÈÄ≤Â∫¶...";
        
                // ËØªÂèñÊñá‰ª∂
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const lines = content.split('\n');
            
                    // Á°Æ‰øùÊñá‰ª∂Ê†ºÂºèÊ≠£Á°Æ - Ëá≥Â∞ëÊúâ3Ë°å(Ê†áÈ¢òË°å+‰∏§Ë°åÊï∞ÊçÆ)
                    if (lines.length < 3) {
                        document.getElementById('csv-loading-message').textContent = "ÈÄ≤Â∫¶Ê™îÊ°àÊ†ºÂºèÈåØË™§";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // Ëé∑ÂèñÂÖ≥Âç°ËøõÂ∫¶‰ª£Á†ÅÂíåFA GundamÁä∂ÊÄÅ‰ª£Á†Å
                    const levelCode = lines[1].trim();
                    const gundamCode = lines[2].trim();
                
                    // È™åËØÅÂ≠òÊ°£‰ª£Á†ÅÊ†ºÂºè - Â∫îËØ•ÈÉΩÊòØ10‰ΩçÊï∞Â≠ó
                    if (!/^\d{10}$/.test(levelCode) || !/^\d{10}$/.test(gundamCode)) {
                        document.getElementById('csv-loading-message').textContent = "ÈÄ≤Â∫¶Ê™îÊ°àÂÖßÂÆπÈåØË™§";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // ‰ªéÁ¨¨‰∏Ä‰∏™‰ª£Á†ÅÁöÑÁ¨¨‰∫å‰ΩçÊèêÂèñÂ∑≤ÂÆåÊàêÂÖ≥Âç°Êï∞
                    const completedLevel = parseInt(levelCode.charAt(1), 10);
                    if (isNaN(completedLevel)) {
                        document.getElementById('csv-loading-message').textContent = "ÈÄ≤Â∫¶Ê™îÊ°àÂÖßÂÆπÈåØË™§";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // ‰ªéÁ¨¨‰∫å‰∏™‰ª£Á†ÅÁöÑÊúÄÂêé‰∏Ä‰ΩçÊèêÂèñGet_fa_gundamÂÄº
                    const faGundamValue = parseInt(gundamCode.charAt(9), 10);
                    if (isNaN(faGundamValue)) {
                        document.getElementById('csv-loading-message').textContent = "ÈÄ≤Â∫¶Ê™îÊ°àÂÖßÂÆπÈåØË™§";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // ËÆæÁΩÆÂÖ®Â±ÄÂèòÈáèGet_fa_gundam
                    Get_fa_gundam = faGundamValue;
                    console.log("‰ªéÂ≠òÊ°£ËØªÂèñFA GundamÁä∂ÊÄÅ:", Get_fa_gundam);
            
                    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆåÊàêÊâÄÊúâÂèØÁî®ÂÖ≥Âç°
                    if (completedLevel < 5) {
                        // Ê†πÊçÆÂÆåÊàêÁöÑÂÖ≥Âç°Êï∞Âä†ËΩΩ‰∏ã‰∏ÄÂÖ≥
                        let nextLevelId = completedLevel + 1;
                        loadLevelById(nextLevelId, loadingOverlay);
                    } else {
                        // Â∑≤ÂÆåÊàêÊâÄÊúâÂÖ≥Âç°ÔºåÊòæÁ§∫Ê∂àÊÅØ
                        document.getElementById('csv-loading-message').textContent = "ÊÇ®Â∑≤ÂÆåÊàêÊâÄÊúâÂèØÁî®ÈóúÂç°ÔºÅ";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                            // ÂèØÈÄâÔºöËøîÂõû‰∏ªËèúÂçï
                            showCoverPage();
                        }, 3000);
                    }
                };
        
                reader.onerror = function() {
                    document.getElementById('csv-loading-message').textContent = "ËÆÄÂèñÊ™îÊ°àÊôÇÁôºÁîüÈåØË™§";
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 2000);
                };
        
                // ÂºÄÂßãËØªÂèñÊñá‰ª∂
                reader.readAsText(file);
        
                // Ê∏ÖÁêÜ
                document.body.removeChild(fileInput);
            };
    
            // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
            fileInput.click();
        }

        // Ê†πÊçÆÂÖ≥Âç°IDÂä†ËΩΩÂÖ≥Âç°
        function loadLevelById(levelId, loadingOverlay) {
            // Ê†πÊçÆÂÖ≥Âç°IDÂÜ≥ÂÆöÂä†ËΩΩÂì™‰∏™CSVÊñá‰ª∂
            let csvUrl = "";
            if (levelId === 1) {
                csvUrl = "./stages/SRWCStage01.csv"; // Á¨¨‰∏ÄÂÖ≥
            } else if (levelId === 2) {
                csvUrl = "./stages/SRWCStage02.csv"; // Á¨¨‰∫åÂÖ≥
            } else if (levelId === 3) {
                csvUrl = "./stages/SRWCStage03.csv"; // Á¨¨‰∏âÂÖ≥
            } else if (levelId === 4) {
                csvUrl = "./stages/SRWCStage04.csv"; // Á¨¨ÂõõÂÖ≥
            } else {
                // ÈªòËÆ§ÊàñÊú™Êù•ÂÖ≥Âç°
                document.getElementById('csv-loading-message').textContent = "Êú™ÊâæÂà∞Â∞çÊáâÈóúÂç°ÊàñÈóúÂç°ÈñãÁôº‰∏≠";
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 2000);
                return;
            }
    
            // Âä†ËΩΩÂÖ≥Âç°
            loadLevelsFromURL(csvUrl).then(success => {
                if (success) {
                    // Êõ¥Êñ∞Âä†ËΩΩÊ∂àÊÅØ
                    document.getElementById('csv-loading-message').textContent = "Ê≠£Âú®È†êËºâÂúñÁâáË≥áÊ∫ê...";
            
                    // È¢ÑÂä†ËΩΩÂõæÁâá
                    const imagesToLoad = getAllImageURLsFromLevelData();
                    preloadImages(imagesToLoad).then(() => {
                        // ÈöêËóèÂä†ËΩΩÁïåÈù¢
                        loadingOverlay.style.display = 'none';
                
                        // Ê∏ÖÁêÜÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅ
                        gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                        gameState.blueCaptured = [];
                        gameState.redCaptured = [];
                        gameState.currentTurn = BLUE;
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        gameState.gameOver = false;
                        gameState.winner = null;
                        gameState.turnCount = 0;
                    
                        // Êõ¥Êñ∞UI
                        updateBoardDisplay();
                        updateCapturedPieces();
                        updateTurnIndicator();
                        updateTurnCountDisplay();
                
                        // ÈöêËóèÂ∞ÅÈù¢È°µÈù¢
                        coverPage.classList.add('hide');
                
                        // ÊòæÁ§∫Ê∏∏ÊàèUI
                        gameUI.style.display = 'block';
                
                        // Âä†ËΩΩÂÖ≥Âç°
                        const nextLevelId = window.levelData.length > 0 ? window.levelData[0].id : 1;
                        if (levelManager) {
                            levelManager.loadLevel(nextLevelId);
                        }
                    });
                } else {
                    // Âä†ËΩΩÂ§±Ë¥•
                    document.getElementById('csv-loading-message').textContent = "ÁÑ°Ê≥ïËºâÂÖ•ÈóúÂç°Êï∏Êìö";
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 2000);
                }
            }).catch(error => {
                console.error("ËºâÂÖ•ÈóúÂç°ÊôÇÂá∫ÈåØ:", error);
                document.getElementById('csv-loading-message').textContent = "ËºâÂÖ•ÈóúÂç°ÊôÇÂá∫ÈåØ: " + error.message;
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 2000);
            });
        }        
        
        /**
         * Â∞ÜÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤ËΩ¨Êç¢‰∏∫rgbaÊ†ºÂºè
         * @param {string} hexColor - ÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤ÂÄº (#RRGGBB Êàñ #RGB Ê†ºÂºè)
         * @param {number} alpha - ÈÄèÊòéÂ∫¶ (0-1)
         * @return {string} rgbaÊ†ºÂºèÁöÑÈ¢úËâ≤
         */
        function hexToRgba(hexColor, alpha = 1) {
            // Ê£ÄÊü•ÊòØÂê¶‰∏∫Á©∫ÊàñÊó†ÊïàÂÄº
            if (!hexColor || typeof hexColor !== 'string') {
                return `rgba(255, 20, 147, ${alpha})`; // ÈªòËÆ§ËøîÂõûÊ∑±Á≤âÁ∫¢Ëâ≤
            }

            // ÁßªÈô§#Âè∑Âπ∂Ê†áÂáÜÂåñÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤
            let hex = hexColor.replace('#', '').trim();

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊïàÁöÑÂçÅÂÖ≠ËøõÂà∂ÂÄº
            if (!/^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/.test(hex)) {
                return `rgba(255, 20, 147, ${alpha})`; // Êó†ÊïàÊó∂ËøîÂõûÈªòËÆ§È¢úËâ≤
            }

            // Â§ÑÁêÜÁÆÄÂÜôÂΩ¢Âºè (#RGB)
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }

            // Ëß£ÊûêRGBÂÄº
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            // ËøîÂõûrgbaÊ†ºÂºè
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // =================== Â§öËæπÂΩ¢Á¢∞ÊíûÊ£ÄÊµãÂ∑•ÂÖ∑ÂáΩÊï∞ ===================

        /**
         * ÂàõÂª∫‰∏Ä‰∏™Â§öËæπÂΩ¢ÂØπË±°
         * @param {Array} points - Â§öËæπÂΩ¢È°∂ÁÇπÊï∞ÁªÑÔºåÊ†ºÂºè‰∏∫ [{x, y}, {x, y}, ...]
         * @param {number} x - Â§öËæπÂΩ¢‰∏≠ÂøÉxÂùêÊ†á
         * @param {number} y - Â§öËæπÂΩ¢‰∏≠ÂøÉyÂùêÊ†á
         * @param {number} rotation - ÊóãËΩ¨ËßíÂ∫¶ÔºàÂ∫¶Ôºâ
         * @return {Object} Â§öËæπÂΩ¢ÂØπË±°
         */
        function createPolygon(points, x, y, rotation = 0) {
            return {
                points: points,
                x: x,
                y: y,
                rotation: rotation,

                // Ëé∑ÂèñÂèòÊç¢ÂêéÁöÑÁÇπ
                getTransformedPoints: function() {
                    // ËßíÂ∫¶ËΩ¨ÂºßÂ∫¶
                    const rad = (this.rotation * Math.PI) / 180;
                    const cos = Math.cos(rad);
                    const sin = Math.sin(rad);

                    return this.points.map(point => {
                        // Â∫îÁî®ÊóãËΩ¨
                        const rotatedX = point.x * cos - point.y * sin;
                        const rotatedY = point.x * sin + point.y * cos;

                        // Â∫îÁî®Âπ≥Áßª
                        return {
                            x: rotatedX + this.x,
                            y: rotatedY + this.y
                        };
                    });
                }
            };
        }

        /**
         * Ê£ÄÊµãÂ§öËæπÂΩ¢‰πãÈó¥ÊòØÂê¶Á¢∞ÊíûÔºà‰ΩøÁî®ÂàÜÁ¶ªËΩ¥ÂÆöÁêÜSATÔºâ
         * @param {Object} polygonA - Á¨¨‰∏Ä‰∏™Â§öËæπÂΩ¢ÂØπË±°
         * @param {Object} polygonB - Á¨¨‰∫å‰∏™Â§öËæπÂΩ¢ÂØπË±°
         * @return {boolean} ÊòØÂê¶Á¢∞Êíû
         */
        function polygonsCollide(polygonA, polygonB) {
            const pointsA = polygonA.getTransformedPoints();
            const pointsB = polygonB.getTransformedPoints();

            // Ëé∑ÂèñÊâÄÊúâËæπÁöÑÊ≥ïÂêëÈáè‰Ωú‰∏∫ÊäïÂΩ±ËΩ¥
            const axes = getAxes(pointsA).concat(getAxes(pointsB));

            // Âú®ÊØè‰∏™ËΩ¥‰∏äÊ£ÄÊµãÊäïÂΩ±ÊòØÂê¶ÈáçÂè†
            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                const projectionA = projectPolygon(pointsA, axis);
                const projectionB = projectPolygon(pointsB, axis);

                // Â¶ÇÊûúÂú®‰ªªÊÑèËΩ¥‰∏äÊ≤°ÊúâÈáçÂè†ÔºåÂàôÂ§öËæπÂΩ¢‰∏çÁ¢∞Êíû
                if (!projectionOverlap(projectionA, projectionB)) {
                    return false;
                }
            }

            // ÊâÄÊúâËΩ¥‰∏äÈÉΩÊúâÈáçÂè†ÔºåÂ§öËæπÂΩ¢Á¢∞Êíû
            return true;
        }

        /**
         * Ëé∑ÂèñÂ§öËæπÂΩ¢ÊâÄÊúâËæπÁöÑÊ≥ïÂêëÈáè
         * @param {Array} points - Â§öËæπÂΩ¢È°∂ÁÇπÊï∞ÁªÑ
         * @return {Array} Ê≥ïÂêëÈáèÊï∞ÁªÑ
         */
        function getAxes(points) {
            const axes = [];

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];

                // ËÆ°ÁÆóËæπÁöÑÊ≥ïÂêëÈáè
                const edge = {
                    x: p2.x - p1.x,
                    y: p2.y - p1.y
                };

                // Ê≥ïÂêëÈáèÔºàÂûÇÁõ¥‰∫éËæπÔºâ
                const normal = {
                    x: -edge.y,
                    y: edge.x
                };

                // Âçï‰ΩçÂåñ
                const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                normal.x /= length;
                normal.y /= length;

                axes.push(normal);
            }

            return axes;
        }

        /**
         * Â∞ÜÂ§öËæπÂΩ¢ÊäïÂΩ±Âà∞ËΩ¥‰∏ä
         * @param {Array} points - Â§öËæπÂΩ¢È°∂ÁÇπ
         * @param {Object} axis - ÊäïÂΩ±ËΩ¥
         * @return {Object} ÊäïÂΩ±Âå∫Èó¥ {min, max}
         */
        function projectPolygon(points, axis) {
            let min = Number.MAX_VALUE;
            let max = -Number.MAX_VALUE;

            points.forEach(point => {
                // ÁÇπÂú®ËΩ¥‰∏äÁöÑÊäïÂΩ±
                const projection = point.x * axis.x + point.y * axis.y;

                if (projection < min) min = projection;
                if (projection > max) max = projection;
            });

            return { min, max };
        }

        /**
         * Ê£ÄÊü•‰∏§‰∏™ÊäïÂΩ±ÊòØÂê¶ÈáçÂè†
         * @param {Object} projectionA - Á¨¨‰∏Ä‰∏™ÊäïÂΩ± {min, max}
         * @param {Object} projectionB - Á¨¨‰∫å‰∏™ÊäïÂΩ± {min, max}
         * @return {boolean} ÊòØÂê¶ÈáçÂè†
         */
        function projectionOverlap(projectionA, projectionB) {
            return !(projectionA.max < projectionB.min || projectionB.max < projectionA.min);
        }

        /**
         * ÂàõÂª∫ËßÑÂàôÂ§öËæπÂΩ¢
         * @param {number} sides - ËæπÊï∞
         * @param {number} radius - ÂçäÂæÑ
         * @return {Array} Â§öËæπÂΩ¢È°∂ÁÇπÊï∞ÁªÑ
         */
        function createRegularPolygon(sides, radius) {
            const points = [];
            const angleStep = (2 * Math.PI) / sides;

            for (let i = 0; i < sides; i++) {
                const angle = i * angleStep;
                points.push({
                    x: radius * Math.cos(angle),
                    y: radius * Math.sin(angle)
                });
            }

            return points;
        }

        /**
         * ‰ªéSVGË∑ØÂæÑÂàõÂª∫Â§öËæπÂΩ¢
         * @param {string} svgPath - SVGË∑ØÂæÑÂ≠óÁ¨¶‰∏≤
         * @param {number} scale - Áº©ÊîæÂõ†Â≠ê
         * @return {Array} Â§öËæπÂΩ¢È°∂ÁÇπÊï∞ÁªÑ
         */
        function createPolygonFromSVG(svgPath, scale = 1) {
            // Ê≥®ÊÑèÔºöËøôÊòØÁÆÄÂåñÁâàÔºåÂè™ÊîØÊåÅÁÆÄÂçïÁöÑÁßªÂä®ÂíåÁõ¥Á∫øÂëΩ‰ª§
            // ÂÆåÊï¥ÂÆûÁé∞ÈúÄË¶ÅSVGË∑ØÂæÑËß£ÊûêÂ∫ì
            const points = [];
            const commands = svgPath.match(/[MLZ][^MLZ]*/g) || [];

            commands.forEach(cmd => {
                const type = cmd[0];
                const coords = cmd.slice(1).trim().split(/[\s,]+/).map(Number);

                if (type === 'M' || type === 'L') {
                    for (let i = 0; i < coords.length; i += 2) {
                        if (i + 1 < coords.length) {
                            points.push({
                                x: coords[i] * scale,
                                y: coords[i + 1] * scale
                            });
                        }
                    }
                }
            });

            return points;
        }

        /**
         * ÂàõÂª∫ÊåáÂÆöÁ±ªÂûãÁöÑÂáÜÊòüÂÖÉÁ¥†
         * @param {string} type - ÂáÜÊòüÁ±ªÂûã
         * @param {string} color - ÂáÜÊòüÈ¢úËâ≤ÔºàÂçÅÂÖ≠ËøõÂà∂Ôºâ
         * @param {number} size - ÂáÜÊòüÂ§ßÂ∞è
         * @return {HTMLElement} ÂáÜÊòüDOMÂÖÉÁ¥†
         */
        function createCrosshair(type, color, size) {
            // ÂàõÂª∫ÂáÜÊòüÂÆπÂô®
            const container = document.createElement('div');
            container.className = 'crosshair';
            container.style.width = `${size}px`;
            container.style.height = `${size}px`;

            // Ëß£ÊûêÈ¢úËâ≤
            const rgbaColor = hexToRgba(color, 1);
            const rgbaColorFaint = hexToRgba(color, 0.5);

            // ËÆ°ÁÆóÂèÇÊï∞
            const lineThickness = Math.max(2, Math.floor(size / 50)); // Á∫øÊù°ÊúÄÂ∞è2px
            const outerSize = Math.round(size * 0.8); // Â§ñÊ°ÜÂ§ßÂ∞è‰∏∫ÂÆπÂô®Â§ßÂ∞èÁöÑ80%
            const borderWidth = Math.max(2, Math.floor(size / 40)); // ËæπÊ°ÜÂÆΩÂ∫¶ÊúÄÂ∞è2px
            const dotSize = Math.max(4, Math.floor(size / 15)); // ‰∏≠ÂøÉÁÇπÂ§ßÂ∞è

            switch (type) {
                case 'Beam_Rifie':
                    // ÂúÜÂΩ¢Â§ñÊ°ÜÂáÜÊòü
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize}px;
                            height: ${outerSize}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            border-radius: 50%;
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            border-radius: 50%;
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Beam_Saber':
                    // ÂûÇÁõ¥ÈïøÊñπÂΩ¢ÂáÜÊòü (ÂÆΩ:È´ò = 1:6)
                    const frameWidth = Math.round(outerSize * 0.4); // ÂáèÂ∞èÂÆΩÂ∫¶‰ª•‰øùÊåÅÂêàÁêÜÊØî‰æã
                    const frameHeight = frameWidth * 6; // È´òÂ∫¶ÊòØÂÆΩÂ∫¶ÁöÑ6ÂÄç

                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${frameWidth}px;
                            height: ${frameHeight}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Cosmo_Nova':
                    // Ëè±ÂΩ¢Â§ñÊ°ÜÂáÜÊòü
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize * 0.7}px;
                            height: ${outerSize * 0.7}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Destructive_Thunder':
                    // ‰ΩøÁî®‰∏çÂêåÁöÑÂèòÈáèÂêçÈÅøÂÖçÂÜ≤Á™Å
                    const thunderSquareSize = Math.round(outerSize * 1); // ‰ΩøÁî®100%ÁöÑÂ§ñÊ°ÜÂ§ßÂ∞è
    
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${thunderSquareSize}px;
                            height: ${thunderSquareSize}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color}, 0 0 10px ${color};
                            animation: pulse 1s infinite alternate;
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                // Ê∑ªÂä†Getter_BeamÂáÜÊòüÁ±ªÂûã
                case 'Getter_Beam':
                    // Ê∞¥Âπ≥ÈïøÊñπÂΩ¢ÂáÜÊòü(ÂÆΩ:È´ò = 6:1)
                    const frameHeight = Math.round(outerSize * 0.4); // ËæÉÁü≠ÁöÑÈ´òÂ∫¶
                    const frameWidth = frameHeight * 6; // ÂÆΩÂ∫¶ÊòØÈ´òÂ∫¶ÁöÑ6ÂÄç
            
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${frameWidth}px;
                            height: ${frameHeight}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;
                    
                case 'diamond':
                    // Ëè±ÂΩ¢Â§ñÊ°ÜÂáÜÊòü
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize * 0.7}px;
                            height: ${outerSize * 0.7}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                // ...ÂÖ∂‰ªñÂáÜÊòüÁ±ªÂûã‰øùÊåÅ‰∏çÂèò...
            }

            return container;
        }

        // ÊòæÁ§∫ÂõûÂêàËΩ¨Êç¢ÊèêÁ§∫
        function showTurnTransition(team, turnNumber) {
            const overlay = document.getElementById('turn-transition-overlay');
            const card = document.getElementById('turn-transition-card');
            const title = document.getElementById('turn-transition-title');
            const subtitle = document.getElementById('turn-transition-subtitle');
            const turnNumberAnim = document.getElementById('turn-number-anim');

            if (!overlay || !card || !title || !subtitle) return;

            // ËÆæÁΩÆÂõûÂêàÊï∞
            if (turnNumberAnim) {
                turnNumberAnim.textContent = turnNumber;
            }

            // ÈáçÁΩÆÁ±ª
            card.classList.remove('blue-turn', 'red-turn');

            // ËÆæÁΩÆÈÄÇÂΩìÁöÑÈòü‰ºçÁ±ªÂíåÊñáÊú¨
            if (team === BLUE) {
                card.classList.add('blue-turn');
                title.textContent = 'ËóçÊñπÂõûÂêà';
                subtitle.textContent = 'Ë´ãÊåáÊèÆÊÇ®ÁöÑÊ©üÈ´îË°åÂãï';
            } else {
                card.classList.add('red-turn');
                title.textContent = 'Á¥ÖÊñπÂõûÂêà';
                subtitle.textContent = 'ÊïåÊñπÊú∫‰ΩìÂºÄÂßãË°åÂä®';
            }

            // ÊòæÁ§∫ËøáÊ∏°
            overlay.classList.add('show');

            // 2ÁßíÂêéÈöêËóè
            setTimeout(() => {
                overlay.classList.remove('show');

                // ÈáçÁΩÆÂä®ÁîªÂÖÉÁ¥†‰ª•‰æø‰∏ãÊ¨°ÊòæÁ§∫
                setTimeout(() => {
                    const countElem = document.getElementById('turn-counter-anim');
                    if (countElem) {
                        // ÂÖãÈöÜÂπ∂ÊõøÊç¢ÂÖÉÁ¥†‰ª•ÈáçÁΩÆÂä®Áîª
                        const newCountElem = countElem.cloneNode(true);
                        countElem.parentNode.replaceChild(newCountElem, countElem);
                    }
                }, 500);
            }, 1000);
        }

        // CSVÂä†ËºâÁõ∏ÈóúÂäüËÉΩ
        // ÂæûURLÁç≤ÂèñCSVÊï∏Êìö
        async function fetchCSVFromURL(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error("Áç≤ÂèñCSVÊï∏ÊìöÊôÇÂá∫ÈåØ:", error);
                throw error;
            }
        }

        // Ëß£ÊûêCSVÊï∏Êìö
        function parseCSV(csvText) {
            if (!csvText) return [];

            const lines = csvText.split('\n');
            const headers = lines[0].split(',');

            return lines.slice(1).filter(line => line.trim() !== '').map(line => {
                const values = line.split(',');
                const entry = {};

                headers.forEach((header, index) => {
                    entry[header] = values[index] || '';
                });

                return entry;
            });
        }

        // ÂæûCSVÊï∏ÊìöÂâµÂª∫ÈóúÂç°
        function createLevelsFromCSV(csvEntries) {
            const levels = [];
            let currentLevel = null;

            // ÊåâCSVÊï∏ÊìöÈ°ûÂûãËôïÁêÜÊØè‰∏ÄË°å
            csvEntries.forEach(entry => {
                switch (entry.data_type) {
                    case 'level_info':
                        // ÂâµÂª∫Êñ∞ÈóúÂç°
                        currentLevel = {
                            id: parseInt(entry.id),
                            title: entry.title,
                            subtitle: entry.subtitle,
                            storyImage: entry.storyImage,
                            storyDesc: entry.storyDesc,
                            boardImage: entry.boardImage,
                            boardbgm: entry.boardbgm,
                            pieceDefinitions: {},
                            initialBoardState: [],
                            events: []
                        };
                        levels.push(currentLevel);
                        break;

                    case 'piece_definition':
                        // Ê∑ªÂä†Ê©üÈ´îÂÆöÁæ©
                        if (currentLevel) {
                            // Á¢∫‰øùteamÂ≠óÊÆµÊ≠£Á¢∫Ë®≠ÁΩÆ
                            const team = entry.team || (entry.id.includes('zaku') || entry.id.includes('red') ? RED : BLUE);

                            currentLevel.pieceDefinitions[entry.id] = {
                                team: team,
                                type: entry.type,
                                moveType: entry.moveType,
                                imgUrl: entry.imgUrl,
                                hit: parseInt(entry.hit) || 3,
                                dodge: parseInt(entry.dodge) || 3,
                                bgmtype: entry.bgmtype || '',
                                weapon_colour: entry.weapon_colour || '',
                                crosshairType: entry.crosshairType || 'Beam_Rifie' // ÂáÜÊòüÂΩ¢Áä∂Á±ªÂûã
                            };
                        }
                        break;

                    case 'initial_position':
                        // Ê∑ªÂä†ÂàùÂßã‰ΩçÁΩÆ
                        if (currentLevel) {
                            currentLevel.initialBoardState.push({
                                id: entry.id,
                                position: [parseInt(entry.position_row), parseInt(entry.position_col)]
                            });
                        }
                        break;

                    case 'condition':
                        // Ë®≠ÁΩÆÂãùÂà©/Â§±ÊïóÊ¢ù‰ª∂
                        if (currentLevel) {
                            const conditionObj = {
                                type: entry.condition_type,
                                description: entry.description
                            };

                            // Â§ÑÁêÜÁâπÂÆöÁ±ªÂûãÁöÑÊù°‰ª∂
                            if (entry.condition_type === 'surviveNTurns') {
                                // ‰ªéÊèèËø∞‰∏≠ÊèêÂèñÊï∞Â≠ó
                                const matches = entry.description.match(/\d+/);
                                const turns = matches ? parseInt(matches[0], 10) : 10; // ÈªòËÆ§ÂÄº‰∏∫3Ôºå‰ª•Èò≤ÊèêÂèñÂ§±Ë¥•
                                conditionObj.turns = turns;
                                console.log(`‰ªéÊèèËø∞ "${entry.description}" ‰∏≠ÊèêÂèñÂà∞ÂõûÂêàÊï∞: ${turns}`);
                            }

                            if (entry.id === 'victory') {
                                currentLevel.victoryCondition = conditionObj;
                            } else if (entry.id === 'defeat') {
                                currentLevel.defeatCondition = conditionObj;
                            }
                        }
                        break;

                    case 'event':
                        // Ê∑ªÂä†‰∫ã‰ª∂
                        if (currentLevel) {
                            const eventObj = {
                                type: entry.event_type,
                                condition: {},
                                action: {
                                    type: entry.action_type
                                },
                                once: entry.once === 'TRUE'
                            };

                            // Ë®≠ÁΩÆÊ¢ù‰ª∂
                            if (entry.condition_turn) eventObj.condition.turn = parseInt(entry.condition_turn);
                            if (entry.condition_team) eventObj.condition.team = entry.condition_team;
                            if (entry.condition_pieceId) eventObj.condition.pieceId = entry.condition_pieceId;
                            if (entry.condition_row) eventObj.condition.row = parseInt(entry.condition_row);
                            if (entry.condition_col) eventObj.condition.col = parseInt(entry.condition_col);

                            // Ê†πÊìöÂãï‰ΩúÈ°ûÂûãË®≠ÁΩÆÂãï‰ΩúÂèÉÊï∏
                            switch (entry.action_type) {
                                case 'spawnPiece':
                                    eventObj.action.pieceId = entry.action_pieceId;
                                    if (entry.action_findBestPosition === 'TRUE') eventObj.action.findBestPosition = true;
                                    if (entry.action_special === 'TRUE') eventObj.action.special = true;
                                    if (entry.action_title) eventObj.action.title = entry.action_title;
                                    if (entry.action_description) eventObj.action.description = entry.action_description;
                                    if (entry.action_buttonText) eventObj.action.buttonText = entry.action_buttonText;
                                    if (entry.aim_row) eventObj.action.aimRow = parseInt(entry.aim_row);
                                    if (entry.aim_col) eventObj.action.aimCol = parseInt(entry.aim_col);
                                    break;

                                // Ê∑ªÂä† replacePiece Âä®‰ΩúÁ±ªÂûãÁöÑÂ§ÑÁêÜ
                                case 'replacePiece':
                                    // ËÆæÁΩÆ replacePiece ÊâÄÈúÄÁöÑÊâÄÊúâÂèÇÊï∞
                                    if (entry.action_pieceId) eventObj.action.pieceId = entry.action_pieceId;
                                    if (entry.action_targetPieceId) eventObj.action.targetPieceId = entry.action_targetPieceId;
                                    if (entry.action_row) eventObj.action.row = parseInt(entry.action_row);
                                    if (entry.action_col) eventObj.action.col = parseInt(entry.action_col);
                                    if (entry.aim_row) eventObj.action.aimRow = parseInt(entry.aim_row);
                                    if (entry.aim_col) eventObj.action.aimCol = parseInt(entry.aim_col);
                                    if (entry.action_findBestPosition === 'TRUE') eventObj.action.findBestPosition = true;
                                    if (entry.action_special === 'TRUE') eventObj.action.special = true;
                                    if (entry.action_title) eventObj.action.title = entry.action_title;
                                    if (entry.action_description) eventObj.action.description = entry.action_description;
                                    if (entry.action_buttonText) eventObj.action.buttonText = entry.action_buttonText;
                                    break;

                                case 'dialog':
                                    eventObj.action.character = entry.action_character;
                                    eventObj.action.text = entry.action_text;
                                    break;

                                case 'removePiece':
                                    eventObj.action.position = [parseInt(entry.action_position_row), parseInt(entry.action_position_col)];
                                    eventObj.action.pieceId = entry.action_pieceId;  // Add this line to save the piece ID
                                    break;

                                case 'movePiece':
                                    eventObj.action.from = [parseInt(entry.action_from_row), parseInt(entry.action_from_col)];
                                    eventObj.action.to = [parseInt(entry.action_to_row), parseInt(entry.action_to_col)];
                                    break;

                                case 'showMission':
                                    eventObj.action.text = entry.action_text;
                                    break;
                            }

                            currentLevel.events.push(eventObj);
                        }
                        break;
                }
            });

            console.log("ÂæûCSVÂâµÂª∫ÁöÑÈóúÂç°Êï∏Êìö:", levels);
            return levels;
        }

        // ÂæûURLÂä†ËºâÈóúÂç°
        async function loadLevelsFromURL(url) {
            // È°ØÁ§∫Âä†ËºâÁïåÈù¢
            const loadingOverlay = document.getElementById('csv-loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                // Áç≤ÂèñÂíåËß£ÊûêCSVÊï∏Êìö
                const csvText = await fetchCSVFromURL(url);
                const csvEntries = parseCSV(csvText);
                const levels = createLevelsFromCSV(csvEntries);

                // ÊõøÊèõÂÖ®Â±ÄÈóúÂç°Êï∏Êìö
                console.log(levels);
                if (levels.length > 0) {
                    window.levelData = levels;
                    console.log("ÊàêÂäüÂæûURLÂä†ËºâÈóúÂç°Êï∏Êìö");
                    return true;
                } else {
                    throw new Error("Ëß£ÊûêCSVÂæåÊ≤íÊúâÁç≤ÂæóÊúâÊïàÁöÑÈóúÂç°Êï∏Êìö");
                }
            } catch (error) {
                console.error("Âä†ËºâÈóúÂç°Êï∏ÊìöÂ§±Êïó:", error);
                // È°ØÁ§∫ÈåØË™§Ë®äÊÅØ
                document.getElementById('csv-loading-message').textContent = "Âä†ËºâÈóúÂç°Êï∏ÊìöÂ§±Êïó: " + error.message;
                // 5ÁßíÂæåÈö±ËóèÂä†ËºâÁïåÈù¢
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 5000);
                return false;
            }
        }

        // Áç≤ÂèñÊâÄÊúâÈúÄË¶ÅÈ†êËºâÁöÑÂúñÁâáURL
        function getAllImageURLsFromLevelData() {
            const urls = [];

            window.levelData.forEach(level => {
                if (level.storyImage) urls.push(level.storyImage);
                if (level.boardImage) urls.push(level.boardImage);

                Object.values(level.pieceDefinitions).forEach(piece => {
                    if (piece.imgUrl) urls.push(piece.imgUrl);
                });
            });

            return [...new Set(urls)]; // ÂéªÈô§ÈáçË§áURL
        }

        // Initialize pieces and their properties
        const pieceDefinitions = {

        };

        // Image URLs for preloading
        const imageUrls = Object.values(pieceDefinitions).map(piece => piece.imgUrl);

        // DOM elements
        const coverPage = document.getElementById('cover-page');
        const singleplayerBtn = document.getElementById('singleplayer-cover-btn');
        const gameUI = document.getElementById('game-ui');

        const chessBoard = document.getElementById('chess-board');
        const turnIndicator = document.getElementById('turn-indicator');
        const turnText = document.getElementById('turn-text');
        const statusMessage = document.getElementById('status-message');
        const resetBtn = document.getElementById('reset-btn');
        const blueCapturedEl = document.getElementById('blue-captured');
        const redCapturedEl = document.getElementById('red-captured');
        const blueCapturedMobileEl = document.getElementById('blue-captured-mobile');
        const redCapturedMobileEl = document.getElementById('red-captured-mobile');
        const connectingOverlay = document.getElementById('connecting-overlay');
        const connectionMessage = document.getElementById('connection-message');
        const networkStatus = document.getElementById('network-status');
        const toast = document.getElementById('toast');
        const myRoomIdEl = document.getElementById('my-room-id');
        const copyIdBtn = document.getElementById('copy-id-btn');
        const joinRoomIdEl = document.getElementById('join-room-id');
        const connectBtn = document.getElementById('connect-btn');
        const connectionStatus = document.getElementById('connection-status');

        // Combat elements
        const combatOverlay = document.getElementById('combat-overlay');
        const combatContainer = document.getElementById('combat-container');
        const combatInfo = document.getElementById('combat-info');
        const combatTimer = document.getElementById('combat-timer');
        const crosshair = document.getElementById('crosshair');
        const defender = document.getElementById('defender');
        const defenderTarget = document.getElementById('defender-target');
        const spaceBackground = document.getElementById('space-background');
        const combatResult = document.getElementById('combat-result');
        const attackerRole = document.getElementById('attacker-role');
        const defenderRole = document.getElementById('defender-role');
        const attackerInstruction = document.getElementById('attacker-instruction');
        const defenderInstruction = document.getElementById('defender-instruction');

        // Victory overlay elements
        const victoryOverlay = document.getElementById('victory-overlay');
        const victoryCard = document.getElementById('victory-card');
        const victoryTitle = document.getElementById('victory-title');
        const victoryMessage = document.getElementById('victory-message');
        const victoryReset = document.getElementById('victory-reset');
        const victoryIcon = document.getElementById('victory-icon');

        // New combat info panel elements
        const attackerImage = document.getElementById('attacker-image');
        const defenderImage = document.getElementById('defender-image');
        const attackerName = document.getElementById('attacker-name');
        const defenderName = document.getElementById('defender-name');
        const attackerHitBar = document.getElementById('attacker-hit-bar');
        const defenderDodgeBar = document.getElementById('defender-dodge-bar');

        // Setup cover page space background
        function setupSpaceBackground(container) {
            // Clear any existing stars
            container.innerHTML = '';

            // Add stars
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;

                // Different star sizes
                const size = Math.random() * 2.5 + 1;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;

                // Different star brightness
                star.style.opacity = Math.random() * 0.7 + 0.3;

                container.appendChild(star);
            }

            // Add shooting stars
            for (let i = 0; i < 5; i++) {
                createShootingStar(container);
            }
        }

        // Create shooting star with random properties
        function createShootingStar(container) {
            const shootingStar = document.createElement('div');
            shootingStar.className = 'shooting-star';

            // Random position and angle
            const startX = Math.random() * 100;
            const startY = Math.random() * 100;
            const angle = Math.random() * 60 - 30; // -30 to 30 degrees

            shootingStar.style.left = `${startX}%`;
            shootingStar.style.top = `${startY}%`;
            shootingStar.style.width = `${Math.random() * 100 + 50}px`;
            shootingStar.style.transform = `rotate(${angle}deg)`;

            // Random delay and duration
            const delay = Math.random() * 15;
            shootingStar.style.animationDelay = `${delay}s`;

            container.appendChild(shootingStar);

            // Replace the shooting star after animation
            setTimeout(() => {
                if (container.contains(shootingStar)) {
                    container.removeChild(shootingStar);
                    createShootingStar(container);
                }
            }, (delay + 3) * 1000); // 3s is the animation duration
        }

        // Preload all game images with progress tracking
        function preloadImages(imageUrls) {
            return new Promise((resolve) => {
                if (imageUrls.length === 0) {
                    resolve();
                    return;
                }

                const uniqueUrls = [...new Set(imageUrls)]; // Remove duplicates
                let loadedCount = 0;
                let startTime = Date.now();
                let lastUpdateTime = startTime;
                let loadingRates = [];

                // Load each image
                uniqueUrls.forEach(url => {
                    const img = new Image();
                    img.onload = img.onerror = () => {
                        loadedCount++;

                        if (loadedCount === uniqueUrls.length) {
                            // Add a short delay to show 100%
                            setTimeout(resolve, 500);
                        }
                    };
                    img.src = url;
                });
            });
        }

        // Reset confirmation dialog
        resetBtn.addEventListener('click', () => {
          resetGame();
          showCoverPage();
        });

        // Victory reset button - ‰øùÁïôÂéüÂßãÂäüËÉΩÔºå‰ΩÜÂú®ÈóúÂç°Á≥ªÁµ±‰∏≠ÊúÉË¢´ÂãïÊÖã‰øÆÊîπ
        victoryReset.addEventListener('click', () => {
            victoryOverlay.classList.remove('show');
            resetGame();
            showCoverPage();
        });

        // Create chess board UI
        function createBoard() {
            chessBoard.innerHTML = '';

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cellElement = document.createElement('div');
                    cellElement.className = `chess-cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;

                    // Add coordinates for reference
                    const coordElement = document.createElement('div');
                    coordElement.className = 'coordinate top-left';
                    coordElement.textContent = `${String.fromCharCode(97 + col)}${8 - row}`;
                    cellElement.appendChild(coordElement);

                    chessBoard.appendChild(cellElement);
                }
            }

            // Add event listeners to cells
            const cells = document.querySelectorAll('.chess-cell');
            cells.forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        // Initialize game board with pieces
        function initializeGame() {
            // Reset game state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: gameState.gameMode,
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null,
                turnCount: 0 // Êñ∞Â¢ûÂõûÂêàË®àÊï∏Âô®
            };

            // Hide any active victory overlay
            victoryOverlay.classList.remove('show');

            // Reset combat mode
            combatMode = {
                active: false,
                attacker: null,
                defender: null,
                attackerPos: null,
                defenderPos: null,
                timer: 3,
                timeRemaining: 3000,
                timerInterval: null,
                frameRequest: null,
                lastFrameTime: 0,
                mouseX: 0,
                mouseY: 0,
                defenderX: 0,
                defenderY: 0,
                defenderTargetX: 0,
                defenderTargetY: 0,
                defenderMoving: false,
                defenderSpeed: 0,
                crosshairSize: 0,
                defenderSizePercent: 20, // Âõ∫ÂÆöÈò≤ÂÆàËÄÖÂ∞∫ÂØ∏
                isPlayerAttacker: false,
                isPlayerDefender: false,
                bulletFired: false,
                result: null
            };

            // ÂâµÂª∫Á¨¨‰∏ÄÈóúÁöÑÈªòË™çÂàùÂßãÊ£ãÁõ§Â∏ÉÂ±Ä
            const defaultBoardState = [

            ];

            // ‰ΩøÁî®ÈªòË™çÂ∏ÉÂ±ÄÂàùÂßãÂåñÊ£ãÁõ§
            defaultBoardState.forEach(piece => {
                const { id, position } = piece;
                const [row, col] = position;

                if (pieceDefinitions[id]) {
                    gameState.board[row][col] = {
                        id: id,
                        team: pieceDefinitions[id].team,
                        type: pieceDefinitions[id].type,
                        moveType: pieceDefinitions[id].moveType,
                        imgUrl: pieceDefinitions[id].imgUrl,
                        hit: pieceDefinitions[id].hit,
                        dodge: pieceDefinitions[id].dodge,
                        hasMoved: false
                    };
                }
            });

            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();

            statusMessage.textContent = "ÈÅäÊà≤Ê∫ñÂÇôÂ∞±Á∑í„ÄÇËóçÊñπÂÖàË°å„ÄÇ";
        }

        // Reset the game completely
        function resetGame() {
            // ÂÅúÊ≠¢ÊâÄÊúâBGM
            stopBattleBGM();
            stopIntroMusic();
            stopBoardBGM();
            showCheckWarning(false);
            Get_fa_gundam = 0;
            resetRequestSent = false;
            resetRequestReceived = false;

            // Reset all game elements to initial state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: 'single-player', // Default to single player when resetting
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null,
                turnCount: 0 // ÈáçÁΩÆÂõûÂêàË®àÊï∏
            };

            victoryOverlay.classList.remove('show');
            combatOverlay.classList.add('hidden');
        }

        // Show the cover page
        function showCoverPage() {
            // ÂÅúÊ≠¢BGM (Âú®ÈÄôË£°ÊèíÂÖ•)
            stopBattleBGM();
            stopBoardBGM();
            playIntroMusic()
            gameUI.style.display = 'none';
            coverPage.classList.remove('hide');

        }

        // Update the visual representation of the board
        function updateBoardDisplay() {
            try {
                console.log(`ÈñãÂßãÊõ¥Êñ∞Ê£ãÁõ§È°ØÁ§∫ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);

                // Clear all pieces - Ê∑ªÂä†ÂÆâÂÖ®Ê™¢Êü•
                const cells = document.querySelectorAll('.chess-cell');
                if (!cells || cells.length === 0) {
                    console.error(`Êõ¥Êñ∞Ê£ãÁõ§È°ØÁ§∫ÈåØË™§: Êú™ÊâæÂà∞Ê£ãÁõ§Ê†ºÂ≠êÂÖÉÁ¥†ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                    return;
                }

                cells.forEach(cell => {
                    try {
                        // Remove piece images and indicators
                        const existingImg = cell.querySelector('.piece-img');
                        if (existingImg) cell.removeChild(existingImg);

                        const indicators = cell.querySelectorAll('.valid-move-indicator');
                        indicators.forEach(indicator => {
                            try {
                                cell.removeChild(indicator);
                            } catch (e) {
                                console.error(`ÁßªÈô§ÊúâÊïàÁßªÂãïÊåáÁ§∫Âô®ÊôÇÂá∫ÈåØ: ${e.message}`);
                            }
                        });

                        // ÁßªÈô§ÊîªÂáªÁ±ªÂûãÊåáÁ§∫Âô®
                        const atkIndicators = cell.querySelectorAll('.attack-type-indicator');
                        atkIndicators.forEach(indicator => {
                            try {
                                cell.removeChild(indicator);
                            } catch (e) {
                                console.error(`ÁßªÈô§ÊîªÊìäÈ°ûÂûãÊåáÁ§∫Âô®ÊôÇÂá∫ÈåØ: ${e.message}`);
                            }
                        });

                        cell.classList.remove('selected');
                    } catch (error) {
                        console.error(`Ê∏ÖÁêÜÊ£ãÁõ§Ê†ºÂ≠êÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
                    }
                });

                // Determine if we should flip the board perspective (for red player in multiplayer mode)
                const shouldFlipPerspective = gameState.gameMode === 'multiplayer' && typeof isHost !== 'undefined' && !isHost;

                // Place pieces according to current board state
                if (!gameState || !gameState.board) {
                    console.error(`Êõ¥Êñ∞Ê£ãÁõ§È°ØÁ§∫ÈåØË™§: gameStateÊàñboardÊú™ÂÆöÁæ©ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                    return;
                }

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        try {
                            const piece = gameState.board[row][col];
                            if (piece) {
                                // Apply perspective flip for red player in multiplayer
                                let displayRow = row;
                                let displayCol = col;

                                if (shouldFlipPerspective) {
                                    // Flip coordinates for red player's perspective
                                    displayRow = BOARD_SIZE - 1 - row;
                                    displayCol = BOARD_SIZE - 1 - col;
                                }

                                const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                                if (!cell) {
                                    console.error(`Êú™ÊâæÂà∞Ê†ºÂ≠êÂÖÉÁ¥† [${displayRow},${displayCol}]ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                                    continue;
                                }

                                // Create piece image
                                const img = document.createElement('img');
                                img.src = piece.imgUrl;
                                img.alt = piece.type;
                                img.className = `piece-img ${piece.team === RED ? 'red-piece' : 'blue-piece'}`;
                                img.dataset.pieceId = piece.id;

                                // Á¥ÖËâ≤Ê£ãÂ≠êÊ∞¥Âπ≥ÁøªËΩâ
                                if (piece.team === RED) {
                                    img.style.transform = 'scaleX(-1)';
                                }

                                cell.appendChild(img);

                                // Highlight selected piece
                                if (gameState.selectedPiece &&
                                    gameState.selectedPiece.row === row &&
                                    gameState.selectedPiece.col === col) {
                                    cell.classList.add('selected');
                                }
                            }
                        } catch (error) {
                            console.error(`ÊîæÁΩÆÊ£ãÂ≠ê [${row},${col}] ÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
                        }
                    }
                }

                // Show valid moves if a piece is selected
                if (gameState.selectedPiece && Array.isArray(gameState.validMoves)) {
                    gameState.validMoves.forEach(move => {
                        try {
                            if (!move || typeof move.row === 'undefined' || typeof move.col === 'undefined') {
                                console.error(`ÁÑ°ÊïàÁöÑÁßªÂãïÊï∏Êìö: ${JSON.stringify(move)}`);
                                return;
                            }

                            let displayRow = move.row;
                            let displayCol = move.col;

                            if (shouldFlipPerspective) {
                                // Flip coordinates for red player's perspective
                                displayRow = BOARD_SIZE - 1 - move.row;
                                displayCol = BOARD_SIZE - 1 - move.col;
                            }

                            const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                            if (!cell) {
                                console.error(`È°ØÁ§∫ÊúâÊïàÁßªÂãïÊôÇÊú™ÊâæÂà∞Ê†ºÂ≠ê [${displayRow},${displayCol}]`);
                                return;
                            }

                            const indicator = document.createElement('div');
                            indicator.className = 'valid-move-indicator';

                            // If there's a piece at this position (capture)
                            if (gameState.board[move.row][move.col]) {
                                indicator.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            } else {
                                indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
                            }

                            cell.appendChild(indicator);
                        } catch (error) {
                            console.error(`È°ØÁ§∫ÊúâÊïàÁßªÂãïÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
                        }
                    });
                }

                // Set up piece hover events after updating the board
                try {
                    setupPieceHoverEvents();
                    console.log(`Ê£ãÁõ§È°ØÁ§∫Êõ¥Êñ∞ÂÆåÊàêÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`Ë®≠ÁΩÆÊ£ãÂ≠êÊá∏ÂÅú‰∫ã‰ª∂ÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
                }
            } catch (error) {
                console.error(`Êõ¥Êñ∞Ê£ãÁõ§È°ØÁ§∫ÊôÇÁôºÁîüÂö¥ÈáçÈåØË™§ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
            }

            // Â¶ÇÊûúÊòØÁé©ÂÆ∂ÂõûÂêàÔºåÊ£ÄÊü•Â∞ÜÂÜõÁä∂ÊÄÅ
            if (gameState.currentTurn === BLUE && !gameState.gameOver) {
                checkPlayerKingInCheck();
            }
            
        }

        // Update turn indicator
        function updateTurnIndicator() {
            try {
                // Ê™¢Êü•ÂøÖË¶ÅÁöÑDOMÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
                const turnIndicator = document.getElementById('turn-indicator');
                const turnText = document.getElementById('turn-text');

                // ÂÆâÂÖ®Âú∞Êõ¥Êñ∞UIÂÖÉÁ¥†
                if (turnIndicator) {
                    turnIndicator.style.backgroundColor = gameState.currentTurn === BLUE ? '#4169E1' : '#DC143C';
                }

                if (turnText) {
                    turnText.textContent = `${gameState.currentTurn === BLUE ? 'ËóçÊñπ' : 'Á¥ÖÊñπ'}ÂõûÂêà`;
                }
            } catch (error) {
                // ÁÑ°ËÅ≤Â§±ÊïóÔºåÈÅøÂÖç‰∏≠Êñ∑ÈÅäÊà≤ÊµÅÁ®ã
            }
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            try {
                // Ê™¢Êü•ÂøÖË¶ÅÁöÑDOMÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
                const blueCapturedEl = document.getElementById('blue-captured');
                const redCapturedEl = document.getElementById('red-captured');
                const blueCapturedMobileEl = document.getElementById('blue-captured-mobile');
                const redCapturedMobileEl = document.getElementById('red-captured-mobile');

                // Ê∏ÖÁ©∫ÁèæÊúâÁöÑÊçïÁç≤Ê£ãÂ≠ê - ÂÆâÂÖ®Âú∞Êìç‰Ωú
                if (blueCapturedEl) blueCapturedEl.innerHTML = '';
                if (redCapturedEl) redCapturedEl.innerHTML = '';
                if (blueCapturedMobileEl) blueCapturedMobileEl.innerHTML = '';
                if (redCapturedMobileEl) redCapturedMobileEl.innerHTML = '';

                if (!gameState || !Array.isArray(gameState.blueCaptured) || !Array.isArray(gameState.redCaptured)) {
                    return;
                }

                // Ê∑ªÂä†ËóçÊñπÊçïÁç≤ÁöÑÊ£ãÂ≠ê
                gameState.blueCaptured.forEach(piece => {
                    const img = document.createElement('img');
                    img.src = piece.imgUrl || '';
                    img.alt = piece.type || 'Captured';
                    img.title = piece.type || 'Captured';
                    img.className = 'w-8 h-8 object-contain';

                    if (blueCapturedEl) blueCapturedEl.appendChild(img.cloneNode(true));
                    if (blueCapturedMobileEl) blueCapturedMobileEl.appendChild(img);
                });

                // Ê∑ªÂä†Á¥ÖÊñπÊçïÁç≤ÁöÑÊ£ãÂ≠ê
                gameState.redCaptured.forEach(piece => {
                    const img = document.createElement('img');
                    img.src = piece.imgUrl || '';
                    img.alt = piece.type || 'Captured';
                    img.title = piece.type || 'Captured';
                    img.className = 'w-8 h-8 object-contain';

                    if (redCapturedEl) redCapturedEl.appendChild(img.cloneNode(true));
                    if (redCapturedMobileEl) redCapturedMobileEl.appendChild(img);
                });
            } catch (error) {
                // ÁÑ°ËÅ≤Â§±ÊïóÔºåÈÅøÂÖç‰∏≠Êñ∑ÈÅäÊà≤ÊµÅÁ®ã
            }
        }

        // Ë®≠ÁΩÆÊ£ãÂ≠êÊá∏ÂÅú‰∫ã‰ª∂ÔºåÈ°ØÁ§∫ËÉΩÂäõÂèÉÊï∏
        function setupPieceHoverEvents() {
            const pieceImages = document.querySelectorAll('.piece-img');
            const pieceInfoDefault = document.getElementById('piece-info-default');
            const pieceInfoContent = document.getElementById('piece-info-content');
            const pieceInfoImage = document.getElementById('piece-info-image');
            const pieceInfoName = document.getElementById('piece-info-name');
            const pieceInfoType = document.getElementById('piece-info-type');
            const pieceInfoCrosshair = document.getElementById('piece-info-crosshair');
            const pieceInfoHit = document.getElementById('piece-info-hit');
            const pieceInfoDodge = document.getElementById('piece-info-dodge');
            const pieceInfoHitValue = document.getElementById('piece-info-hit-value');
            const pieceInfoDodgeValue = document.getElementById('piece-info-dodge-value');

            pieceImages.forEach(img => {
                img.addEventListener('mouseenter', function() {
                    const pieceId = this.dataset.pieceId;

                    let pieceInfo = null;
                    if (window.levelData && levelManager && levelManager.currentLevel) {
                        const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                        if (currentLevelData && currentLevelData.pieceDefinitions && currentLevelData.pieceDefinitions[pieceId]) {
                            pieceInfo = currentLevelData.pieceDefinitions[pieceId];
                        }
                    }

                    if (!pieceInfo && pieceDefinitions[pieceId]) {
                        pieceInfo = pieceDefinitions[pieceId];
                    }

                    if (!pieceInfo) {
                        // Âú®Ê£ãÁõ§‰∏äÂ∞ãÊâæÈÄôÂÄãÊ£ãÂ≠êÁç≤ÂèñÂÖ∂Áõ¥Êé•Â±¨ÊÄß
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                const piece = gameState.board[row][col];
                                if (piece && piece.id === pieceId) {
                                    pieceInfo = piece;
                                    break;
                                }
                            }
                            if (pieceInfo) break;
                        }
                    }

                    if (pieceInfo) {
                        // È°ØÁ§∫Ê£ãÂ≠êË≥áË®ä
                        pieceInfoDefault.classList.add('hidden');
                        pieceInfoContent.classList.remove('hidden');

                        // Ë®≠ÁΩÆË≥áË®äÂÖßÂÆπ
                        pieceInfoImage.src = pieceInfo.imgUrl;
                        pieceInfoName.textContent = pieceInfo.type;

                        // ÁßªÂãïÈ°ûÂûãÁøªË≠Ø
                        let moveTypeText = "";
                        switch(pieceInfo.moveType) {
                            case PAWN: moveTypeText = "Ê≠•ÂÖµ"; break;
                            case ROOK: moveTypeText = "ÂüéÂ†°"; break;
                            case KNIGHT: moveTypeText = "È®éÂ£´"; break;
                            case BISHOP: moveTypeText = "‰∏ªÊïô"; break;
                            case QUEEN: moveTypeText = "ÁöáÂêé"; break;
                            case KING: moveTypeText = "ÂúãÁéã"; break;
                        }

                        // Ë®≠ÁΩÆÁßªÂãïÈ°ûÂûã
                        pieceInfoType.textContent = `ÁßªÂãïÈ°ûÂûã: ${moveTypeText}`;

                        // Ë®≠ÁΩÆÊ≠¶Âô®Á±ªÂûã/Ê∫ñÊòüÁ±ªÂûã
                        if (pieceInfo.crosshairType) {
                            // ÁøªË≠ØÊ∫ñÊòüÈ°ûÂûã
                            let crosshairTypeText = "";
                            switch(pieceInfo.crosshairType) {
                                case "Beam_Rifie": crosshairTypeText = "ÂÖâÊùüÊ≠•Êßç"; break;
                                case "Beam_Saber": crosshairTypeText = "ÂÖâÊùüÂäç"; break;
                                case "Cosmo_Nova": crosshairTypeText = "ÂÆáÂÆôÊñ∞Êòü"; break;
                                case "Destructive_Thunder": crosshairTypeText = "Á†¥Â£ûÈõ∑Èõª"; break;
                                case "diamond": crosshairTypeText = "ÈëΩÁü≥ÂÖâÊùü"; break;
                                case "triangle": crosshairTypeText = "‰∏âËßíÂÖâÊùü"; break;
                                case "custom": crosshairTypeText = "Ëá™ÂÆöÁæ©Ê≠¶Âô®"; break;
                                default: crosshairTypeText = pieceInfo.crosshairType;
                            }
                            pieceInfoCrosshair.textContent = `Ê≠¶Âô®È°ûÂûã: ${crosshairTypeText}`;
                            pieceInfoCrosshair.style.display = "block";
                        } else {
                            pieceInfoCrosshair.style.display = "none";
                        }

                        // Ë®≠ÁΩÆËÉΩÂäõÊ¢ùÂíåÊï∏ÂÄºÈ°ØÁ§∫
                        const maxValue = 5; // ÂÅáË®≠ÊúÄÂ§ßÂÄºÊòØ5
                        const hitPercentage = (pieceInfo.hit / maxValue) * 100;
                        const dodgePercentage = (pieceInfo.dodge / maxValue) * 100;

                        pieceInfoHit.style.width = `${hitPercentage}%`;
                        pieceInfoDodge.style.width = `${dodgePercentage}%`;

                        // Ë®≠ÁΩÆÂØ¶Êï∏ÂÄºÈ°ØÁ§∫
                        pieceInfoHitValue.textContent = pieceInfo.hit;
                        pieceInfoDodgeValue.textContent = pieceInfo.dodge;
                    }
                });

                img.addEventListener('mouseleave', function() {
                    // ÈáçÁΩÆÁÇ∫ÈªòË™çÁãÄÊÖã
                    pieceInfoDefault.classList.remove('hidden');
                    pieceInfoContent.classList.add('hidden');
                });
            });
        }

        // Ë®≠ÁΩÆÂ∑≤ÊçïÁç≤Ê£ãÂ≠êÁöÑÊäòÁñäÂäüËÉΩ
        function setupCapturedToggle() {
            const capturedHeader = document.getElementById('captured-header');
            const capturedToggle = document.getElementById('captured-toggle');
            const capturedContent = document.getElementById('captured-content');

            if (capturedHeader && capturedToggle && capturedContent) {
                capturedHeader.addEventListener('click', function() {
                    capturedContent.classList.toggle('hidden');
                    capturedToggle.classList.toggle('rotate-180');
                });
            }
        }

        // Show victory screen function
        function showVictoryScreen(winnerTeam) {
            // Set victory card appearance based on winner
            if (winnerTeam === BLUE) {
                victoryCard.className = "victory-card blue-victory";
                victoryTitle.textContent = "ÂãùÂà©ÔºÅ";
                victoryMessage.textContent = "ÊÇ®ÊàêÂäüÈÅîÂà∞ÂãùÂà©Ê¢ù‰ª∂ÔºÅÂèØ‰ª•ÈÄ≤ÂÖ•‰∏ã‰∏ÄË©±‰∫ÜÔºÅ";
                victoryIcon.textContent = "üèÜ";
            } else {
                victoryCard.className = "victory-card red-victory";
                victoryTitle.textContent = "Êà∞Êïó‰∫ÜÔºÅ";
                victoryMessage.textContent = "ÊÇ®Ë¢´ÊïµÊñπÊìäÊïó‰∫ÜÔºÅÂÜçÊé•ÂÜçÂé≤ÂêßÔºÅ";
                victoryIcon.textContent = "üèÜ";
            }

            // Create confetti effect
            createConfetti(winnerTeam);

            // Show the victory overlay
            victoryOverlay.classList.add('show');
        }

        // Create confetti animation
        function createConfetti(winnerTeam) {
            // Clear any existing confetti
            const existingConfetti = document.querySelectorAll('.victory-confetti');
            existingConfetti.forEach(c => c.remove());

            // Colors based on winner
            const colors = winnerTeam === BLUE
                ? ['#4169E1', '#6495ED', '#1E90FF', '#00BFFF', '#87CEFA', '#B0E0E6']
                : ['#DC143C', '#FF0000', '#CD5C5C', '#FF4500', '#FF6347', '#FFA07A'];

            // Create new confetti pieces
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'victory-confetti';

                // Random position
                confetti.style.left = `${Math.random() * 100}%`;

                // Random color from winner's colors
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                // Random shape
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';

                // Random size
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size * (Math.random() + 0.5)}px`;

                // Random animation duration
                const duration = Math.random() * 3 + 2;
                confetti.style.animationDuration = `${duration}s`;

                // Random delay
                confetti.style.animationDelay = `${Math.random() * 5}s`;

                // Add to overlay
                victoryCard.appendChild(confetti);
            }
        }

        // Handle cell click
        function handleCellClick(event) {
            if (gameState.gameOver || combatMode.active) return;

            const cell = event.currentTarget;
            let row = parseInt(cell.dataset.row);
            let col = parseInt(cell.dataset.col);
            let originalRow = row, originalCol = col;

            // If we're in multiplayer and this is the red player, flip coordinates
            if (gameState.gameMode === 'multiplayer' && !isHost) {
                row = BOARD_SIZE - 1 - row;
                col = BOARD_SIZE - 1 - col;
                console.log(`ÈªûÊìäÊ£ãÁõ§Ê†ºÂ≠ê: [${originalRow},${originalCol}] ‚Üí ÁøªËΩâÁÇ∫ [${row},${col}]`);
            } else {
                console.log(`ÈªûÊìäÊ£ãÁõ§Ê†ºÂ≠ê: [${row},${col}]`);
            }

            const piece = gameState.board[row][col];
            if (piece) {
                console.log(`Ë©≤Ê†ºÂ≠êÊúâ ${piece.team}ÊñπÊ£ãÂ≠ê: ${piece.id} (${piece.type})`);
            } else {
                console.log(`Ë©≤Ê†ºÂ≠êÊ≤íÊúâÊ£ãÂ≠ê`);
            }

            // If a piece is already selected
            if (gameState.selectedPiece) {
                console.log(`Â∑≤ÈÅ∏ÊìáÊ£ãÂ≠êÁöÑÂ∫ßÊ®ô: [${gameState.selectedPiece.row},${gameState.selectedPiece.col}]`);
                const selectedPiece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                if (selectedPiece) {
                    console.log(`Â∑≤ÈÅ∏ÊìáÁöÑÊ£ãÂ≠ê: ${selectedPiece.id}, È°ûÂûã: ${selectedPiece.type}`);
                } else {
                    console.log('Ë≠¶Âëä: Â∑≤ÈÅ∏ÊìáÂ∫ßÊ®ôÁÑ°Ê£ãÂ≠ê!');
                }

                // Check if clicked on same piece (deselect)
                if (row === gameState.selectedPiece.row && col === gameState.selectedPiece.col) {
                    console.log(`ÂèñÊ∂àÈÅ∏ÊìáÊ£ãÂ≠ê: [${row},${col}]`);
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                    return;
                }

                // Check if clicked on another piece of same team (change selection)
                if (piece && piece.team === selectedPiece.team) {
                    if (piece.team === gameState.currentTurn) {
                        gameState.selectedPiece = { row, col };
                        gameState.validMoves = calculateValidMoves(row, col);
                        updateBoardDisplay();
                    }
                    return;
                }

                // Check if the move is valid
                const validMove = gameState.validMoves.find(move => move.row === row && move.col === col);
                if (validMove) {
                    // Check if this is a capture move (there's an opponent's piece)
                    if (piece && piece.team !== selectedPiece.team) {
                        // Start the combat minigame
                        startCombat(selectedPiece, piece,
                                    { row: gameState.selectedPiece.row, col: gameState.selectedPiece.col },
                                    { row, col });
                    } else {
                        // Regular move
                        movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                    }
                }
            }
            // No piece selected yet, select a piece if it belongs to current player
            else if (piece && piece.team === gameState.currentTurn) {
                gameState.selectedPiece = { row, col };
                gameState.validMoves = calculateValidMoves(row, col);
                updateBoardDisplay();
            }

            // Âú®ÁßªÂä®ÂÆåÊàêÂêéÔºåÂ¶ÇÊûúÊ∏∏ÊàèÊ≤°ÊúâÁªìÊùüÔºåÊ£ÄÊü•Â∞ÜÂÜõÁä∂ÊÄÅ
            if (!gameState.gameOver && gameState.currentTurn === BLUE) {
                checkPlayerKingInCheck();
            }
            
        }

        // Calculate valid moves for a piece
        function calculateValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];

            let moves = [];

            switch (piece.moveType) {
                case PAWN:
                    moves = calculatePawnMoves(row, col, piece);
                    break;
                case ROOK:
                    moves = calculateRookMoves(row, col, piece);
                    break;
                case KNIGHT:
                    moves = calculateKnightMoves(row, col, piece);
                    break;
                case BISHOP:
                    moves = calculateBishopMoves(row, col, piece);
                    break;
                case QUEEN:
                    moves = calculateQueenMoves(row, col, piece);
                    break;
                case KING:
                    moves = calculateKingMoves(row, col, piece);
                    break;
            }

            // Filter out moves that would put the king in check
            return moves.filter(move => {
                // Create a deep copy of the board for simulation
                const tempBoard = JSON.parse(JSON.stringify(gameState.board));

                // Simulate the move
                tempBoard[move.row][move.col] = tempBoard[row][col];
                tempBoard[row][col] = null;

                // Find the king
                let kingPos = null;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const p = tempBoard[r][c];
                        if (p && p.team === piece.team && p.moveType === KING) {
                            kingPos = { row: r, col: c };
                            break;
                        }
                    }
                    if (kingPos) break;
                }

                // If king not found (unlikely), allow the move
                if (!kingPos) return true;

                // Check if the king would be in check after the move
                return !isInCheck(tempBoard, kingPos.row, kingPos.col, piece.team);
            });
        }

        // Check if a position is under attack
        function isInCheck(board, kingRow, kingCol, team) {
            const enemyTeam = team === BLUE ? RED : BLUE;

            // Check all opponent pieces to see if any can attack the king
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = board[row][col];
                    if (!piece || piece.team !== enemyTeam) continue;

                    // Get potential attack moves for this piece
                    let attackMoves;
                    switch (piece.moveType) {
                        case PAWN:
                            attackMoves = calculatePawnAttacks(row, col, piece);
                            break;
                        case ROOK:
                            attackMoves = calculateRookMoves(row, col, piece);
                            break;
                        case KNIGHT:
                            attackMoves = calculateKnightMoves(row, col, piece);
                            break;
                        case BISHOP:
                            attackMoves = calculateBishopMoves(row, col, piece);
                            break;
                        case QUEEN:
                            attackMoves = calculateQueenMoves(row, col, piece);
                            break;
                        case KING:
                            attackMoves = calculateKingMoves(row, col, piece, true);
                            break;
                    }

                    // If any move can reach the king's position, the king is in check
                    if (attackMoves.some(move => move.row === kingRow && move.col === kingCol)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // ÊòæÁ§∫Â∞ÜÂÜõË≠¶Âëä
        function showCheckWarning(isShown) {
          const warningElement = document.getElementById('check-warning');
          if (!warningElement) return;
  
          if (isShown) {
            warningElement.classList.add('show');
    
            if ('vibrate' in navigator) {
              navigator.vibrate([200, 100, 200]);
            }
            // Ê∑ªÂä†1ÁßíÂêéËá™Âä®ÈöêËóè
            setTimeout(() => {
              warningElement.classList.remove('show');
            }, 1000); // 1Áßí = 1000ÊØ´Áßí  
          } else {
            warningElement.classList.remove('show');
          }
        }

        // Ê£ÄÊü•Áé©ÂÆ∂ÂõΩÁéãÊòØÂê¶Ë¢´Â∞ÜÂÜõ
        function checkPlayerKingInCheck() {
          // ÊâæÂà∞Áé©ÂÆ∂ÂõΩÁéã‰ΩçÁΩÆ
          let kingPos = null;
          for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              const piece = gameState.board[r][c];
              if (piece && piece.team === BLUE && piece.moveType === KING) {
                kingPos = { row: r, col: c };
                break;
              }
            }
            if (kingPos) break;
          }
  
          // Â¶ÇÊûúÊâæ‰∏çÂà∞ÂõΩÁéãÔºåËøîÂõûfalse
          if (!kingPos) return false;
  
          // Ê£ÄÊü•ÂõΩÁéãÊòØÂê¶Ë¢´Â∞ÜÂÜõ
          const inCheck = isInCheck(gameState.board, kingPos.row, kingPos.col, BLUE);
  
          // ÊòæÁ§∫ÊàñÈöêËóèË≠¶Âëä
          showCheckWarning(inCheck);
  
          return inCheck;
        }
        
        // Calculate pawn moves
        function calculatePawnMoves(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1; // Blue moves up, Red moves down

            // Forward move
            if (isValidPosition(row + direction, col) && !gameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });

                // Double move from starting position
                const startRow = piece.team === BLUE ? 6 : 1;
                if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }

            // Capture moves (diagonally)
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    const targetPiece = gameState.board[row + direction][captureCol];
                    if (targetPiece && targetPiece.team !== piece.team) {
                        moves.push({ row: row + direction, col: captureCol });
                    }
                }
            });

            return moves;
        }

        // Calculate pawn attack pattern (for check detection)
        function calculatePawnAttacks(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1;

            // Pawns attack diagonally
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    moves.push({ row: row + direction, col: captureCol });
                }
            });

            return moves;
        }

        // Calculate rook moves
        function calculateRookMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: 0 }, // up
                { rowDelta: 1, colDelta: 0 },  // down
                { rowDelta: 0, colDelta: -1 }, // left
                { rowDelta: 0, colDelta: 1 }   // right
            ];

            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;

                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];

                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }

                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });

            return moves;
        }

        // Calculate knight moves
        function calculateKnightMoves(row, col, piece) {
            const moves = [];
            const knightMoves = [
                { rowDelta: -2, colDelta: -1 },
                { rowDelta: -2, colDelta: 1 },
                { rowDelta: -1, colDelta: -2 },
                { rowDelta: -1, colDelta: 2 },
                { rowDelta: 1, colDelta: -2 },
                { rowDelta: 1, colDelta: 2 },
                { rowDelta: 2, colDelta: -1 },
                { rowDelta: 2, colDelta: 1 }
            ];

            knightMoves.forEach(move => {
                const newRow = row + move.rowDelta;
                const newCol = col + move.colDelta;

                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];

                    if (!targetPiece || targetPiece.team !== piece.team) {
                        // Empty square or enemy piece
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });

            return moves;
        }

        // Calculate bishop moves
        function calculateBishopMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: -1 }, // up-left
                { rowDelta: -1, colDelta: 1 },  // up-right
                { rowDelta: 1, colDelta: -1 },  // down-left
                { rowDelta: 1, colDelta: 1 }    // down-right
            ];

            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;

                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];

                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }

                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });

            return moves;
        }

        // Calculate queen moves (combination of rook and bishop)
        function calculateQueenMoves(row, col, piece) {
            return [
                ...calculateRookMoves(row, col, piece),
                ...calculateBishopMoves(row, col, piece)
            ];
        }

        // Calculate king moves
        function calculateKingMoves(row, col, piece, forCheckDetection = false) {
            const moves = [];

            // King moves one square in any direction
            for (let rowDelta = -1; rowDelta <= 1; rowDelta++) {
                for (let colDelta = -1; colDelta <= 1; colDelta++) {
                    // Skip the current position
                    if (rowDelta === 0 && colDelta === 0) continue;

                    const newRow = row + rowDelta;
                    const newCol = col + colDelta;

                    if (isValidPosition(newRow, newCol)) {
                        const targetPiece = gameState.board[newRow][newCol];

                        if (!targetPiece || targetPiece.team !== piece.team) {
                            // For regular move calculation, ensure the king doesn't move into check
                            if (forCheckDetection) {
                                moves.push({ row: newRow, col: newCol });
                            } else {
                                // Check if the new position would be in check
                                const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                tempBoard[newRow][newCol] = tempBoard[row][col];
                                tempBoard[row][col] = null;

                                if (!isInCheck(tempBoard, newRow, newCol, piece.team)) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                            }
                        }
                    }
                }
            }

            // Ê™¢Êü•ËªäÁéãÊòì‰ΩçÊ¢ù‰ª∂ÔºàÂÉÖÂú®ÈùûÊ™¢Ê∏¨Ê®°Âºè‰∏ãË®àÁÆóÔºâ
            if (!forCheckDetection && !piece.hasMoved) {
                // Ê™¢Êü•ÂúãÁéãÊòØÂê¶ËôïÊñºË¢´Â∞áËªçÁãÄÊÖã
                const kingInCheck = isInCheck(gameState.board, row, col, piece.team);
                if (!kingInCheck) {
                    // Áç≤ÂèñÊ≠£Á¢∫ÁöÑÂúãÁéãÂàùÂßãÂàóÔºàÊ†πÊìöÊ£ãÂ≠êÈöä‰ºçÔºâ
                    const kingRow = piece.team === BLUE ? 7 : 0;

                    // Âè™ÊúâÁï∂ÂúãÁéãÂú®ÂàùÂßã‰ΩçÁΩÆÊôÇÊâçËÄÉÊÖÆËªäÁéãÊòì‰Ωç
                    if (row === kingRow && col === 4) {

                        // Ê™¢Êü•Áü≠Êòì‰ΩçÊ¢ù‰ª∂ÔºàÂêëÂè≥ÂÅ¥ËªäÂ≠êÊñπÂêëÊòì‰ΩçÔºâ
                        checkCastling(moves, row, col, piece, 7, 1, kingRow);

                        // Ê™¢Êü•Èï∑Êòì‰ΩçÊ¢ù‰ª∂ÔºàÂêëÂ∑¶ÂÅ¥ËªäÂ≠êÊñπÂêëÊòì‰ΩçÔºâ
                        checkCastling(moves, row, col, piece, 0, -1, kingRow);
                    }
                }
            }

            return moves;
        }

        // ËºîÂä©ÂáΩÊï∏ÔºöÊ™¢Êü•ÊåáÂÆöÊñπÂêëÁöÑËªäÁéãÊòì‰ΩçÊ¢ù‰ª∂
        function checkCastling(moves, kingRow, kingCol, king, rookCol, direction, initialRow) {
            // Á¢∫Ë™çËªäÂú®Ê≠£Á¢∫‰ΩçÁΩÆ‰∏îÊú™ÁßªÂãïÈÅé
            const rookPiece = gameState.board[initialRow][rookCol];
            if (!rookPiece || rookPiece.team !== king.team ||
                rookPiece.moveType !== ROOK || rookPiece.hasMoved) {
                return;
            }

            // Ê™¢Êü•ÂúãÁéãÂíåËªä‰πãÈñìÊòØÂê¶ÊúâÊ£ãÂ≠ê
            const startCol = direction > 0 ? kingCol + 1 : rookCol + 1;
            const endCol = direction > 0 ? rookCol : kingCol;
            for (let col = startCol; col < endCol; col++) {
                if (gameState.board[kingRow][col] !== null) {
                    return; // ‰∏≠ÈñìÊúâÊ£ãÂ≠êÔºå‰∏çËÉΩÊòì‰Ωç
                }
            }

            // Ê™¢Êü•ÂúãÁéãÁßªÂãïË∑ØÂæë‰∏äÁöÑÊ†ºÂ≠êÊòØÂê¶ÂèóÂà∞ÊîªÊìä
            const step1 = kingCol + direction;
            const step2 = kingCol + 2 * direction;

            // ÂâµÂª∫Ëá®ÊôÇÊ£ãÁõ§Ê™¢Êü•ÂúãÁéãÁßªÂãïË∑ØÂæëÊòØÂê¶ÂÆâÂÖ®
            const tempBoard1 = JSON.parse(JSON.stringify(gameState.board));
            tempBoard1[kingRow][kingCol] = null;
            tempBoard1[kingRow][step1] = king;

            const tempBoard2 = JSON.parse(JSON.stringify(gameState.board));
            tempBoard2[kingRow][kingCol] = null;
            tempBoard2[kingRow][step2] = king;

            // Â¶ÇÊûúÂúãÁéãÁßªÂãïË∑ØÂæë‰∏äÁöÑÊ†ºÂ≠êÊ≤íÊúâÂèóÂà∞ÊîªÊìäÔºåÂâáÂÖÅË®±ËªäÁéãÊòì‰Ωç
            if (!isInCheck(tempBoard1, kingRow, step1, king.team) &&
                !isInCheck(tempBoard2, kingRow, step2, king.team)) {

                // Ê∑ªÂä†Êòì‰ΩçÁõÆÊ®ô‰ΩçÁΩÆÔºå‰∏¶Ë®≠ÁΩÆÁâπÊÆäÊ®ôË®ò
                moves.push({
                    row: kingRow,
                    col: step2,
                    castling: true,
                    rookCol: rookCol,
                    rookNewCol: direction > 0 ? step1 : step1  // ËªäÁöÑÊñ∞‰ΩçÁΩÆ
                });
            }
        }

        // Helper to check if a position is valid (on the board)
        function isValidPosition(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
        }

        // Move a piece without afterimage effect
        function movePiece(fromRow, fromCol, toRow, toCol) {
            console.log(`ÁßªÂãïÊ£ãÂ≠ê: Âæû[${fromRow},${fromCol}]Âà∞[${toRow},${toCol}]`);
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];

            if (piece) {
                console.log(`ÁßªÂãïÁöÑÊ£ãÂ≠ê: ${piece.id}, È°ûÂûã: ${piece.type}`);
            }

            if (capturedPiece) {
                console.log(`ÊçïÁç≤ÁöÑÊ£ãÂ≠ê: ${capturedPiece.id}, È°ûÂûã: ${capturedPiece.type}`);
            }

            // Ê™¢Êü•Ê≠§ÁßªÂãïÊòØÂê¶ÊòØËªäÁéãÊòì‰Ωç
            let isCastling = false;
            let castlingRookCol = null;
            let castlingRookNewCol = null;

            if (piece && piece.moveType === KING) {
                // Ê™¢Êü•Ê≠§ÁßªÂãïÊòØÂê¶ÁÇ∫ÊúâÊïàÁöÑËªäÁéãÊòì‰Ωç
                const validMove = gameState.validMoves.find(move =>
                    move.row === toRow && move.col === toCol && move.castling === true
                );

                if (validMove) {
                    isCastling = true;
                    castlingRookCol = validMove.rookCol;
                    castlingRookNewCol = validMove.rookNewCol;
                }
            }

            // If capturing a piece, add to captured list
            if (capturedPiece) {
                if (capturedPiece.team === BLUE) {
                    gameState.blueCaptured.push(capturedPiece);
                } else {
                    gameState.redCaptured.push(capturedPiece);
                }

                // Check if captured piece is a king (game over)
                if (capturedPiece.moveType === KING) {
                    // Âè™ÊúâÂú®Ê≤°ÊúâËá™ÂÆö‰πâËÉúÂà©Êù°‰ª∂ÊàñËÉúÂà©Êù°‰ª∂ÊòØ'captureKing'Êó∂ÊâçÁ´ãÂç≥ÁªìÊùüÊ∏∏Êàè
                    if (!gameState.victoryCondition || gameState.victoryCondition.type === 'captureKing') {
                        gameState.gameOver = true;
                        gameState.winner = piece.team;
                    }
                }

                // Âú®ËøôÈáåËß¶Âèë pieceCaptured ‰∫ã‰ª∂
                if (typeof eventSystem !== 'undefined') {
                    console.log(`Ëß¶ÂèëpieceCaptured‰∫ã‰ª∂ÔºåÊçïËé∑ËÄÖ: ${piece.id}ÔºåË¢´ÊçïËé∑: ${capturedPiece.id}`);
                    eventSystem.triggerEvent('pieceCaptured', {
                        capturedPiece: capturedPiece,
                        capturingPiece: piece
                    });
                }
            }

            // Move the piece in the game state
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // Â¶ÇÊûúÊòØËªäÁéãÊòì‰ΩçÔºåÈÇÑÈúÄË¶ÅÁßªÂãïËªäÂ≠ê
            if (isCastling && castlingRookCol !== null && castlingRookNewCol !== null) {
                // Áç≤ÂèñËªäÂ≠ê
                const rook = gameState.board[toRow][castlingRookCol];
                if (rook) {
                    // ÁßªÂãïËªäÂ≠êÂà∞Êñ∞‰ΩçÁΩÆ
                    gameState.board[toRow][castlingRookNewCol] = rook;
                    gameState.board[toRow][castlingRookCol] = null;

                    // Ê®ôË®òËªäÂ≠êÂ∑≤Á∂ìÁßªÂãï
                    rook.hasMoved = true;

                    console.log(`Âü∑Ë°åËªäÁéãÊòì‰ΩçÔºöÂúãÁéãÂæû(${fromRow},${fromCol})Âà∞(${toRow},${toCol})ÔºåËªäÂ≠êÂæû(${toRow},${castlingRookCol})Âà∞(${toRow},${castlingRookNewCol})`);
                }
            }

            // Mark the piece as moved (important for pawns)
            piece.hasMoved = true;

            // Clear selection and valid moves
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            // Switch turns
            gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;

            // Áï∂Ëº™Âà∞ËóçÊñπÂõûÂêàÊôÇÂ¢ûÂä†ÂõûÂêàÊï∏Ë®àÊï∏ÔºàÊØèÂÆåÊàê‰∏ÄÂÄãÂÆåÊï¥ÂõûÂêàÂ¢ûÂä†‰∏ÄÔºâ
            if (gameState.currentTurn === BLUE) {
                gameState.turnCount++;
                console.log(`ÂõûÂêàÊï∏Â¢ûÂä†Âà∞: ${gameState.turnCount}`);

                // Ê∑ªÂä†Ê≠§Ë°åÊòæÁ§∫ÂõûÂêàËøáÊ∏°
                showTurnTransition(BLUE, gameState.turnCount);

                // Ê£ÄÊü•ÊòØÂê¶Ê≠£Âú®Êí≠ÊîæÊàòÊñóBGM
                const wasBattleBgmPlaying = battleBgmPlayer !== null;
                stopBattleBGM();

                // Âè™ÊúâÂú®‰πãÂâçÊ≠£Âú®Êí≠ÊîæÊàòÊñóBGMÊó∂Êâç‰ªéÂ§¥Êí≠Êîæboardbgm
                if (wasBattleBgmPlaying && levelManager && levelManager.currentLevel) {
                    // ‰ªéÂ§¥Êí≠ÊîæÂÖ≥Âç°BGM
                    const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                    if (currentLevelData && currentLevelData.boardbgm) {
                        playBoardBGM(currentLevelData.boardbgm);
                    }
                }

                // Ëß∏ÁôºÂõûÂêàÈñãÂßã‰∫ã‰ª∂
                if (typeof eventSystem !== 'undefined') {
                    console.log(`Ëß∏ÁôºËóçÊñπÂõûÂêàÈñãÂßã‰∫ã‰ª∂ÔºåÂõûÂêàÊï∏: ${gameState.turnCount}`);
                    eventSystem.triggerEvent('turnStart', {
                        team: BLUE,
                        turn: gameState.turnCount
                    });
                }
            } else {
                // Ëß∏ÁôºÂõûÂêàÈñãÂßã‰∫ã‰ª∂(Á¥ÖÊñπ)
                if (typeof eventSystem !== 'undefined') {
                    console.log(`Ëß∏ÁôºÁ¥ÖÊñπÂõûÂêàÈñãÂßã‰∫ã‰ª∂ÔºåÂõûÂêàÊï∏: ${gameState.turnCount}`);
                    eventSystem.triggerEvent('turnStart', {
                        team: RED,
                        turn: gameState.turnCount
                    });
                }

             if (typeof eventSystem !== 'undefined') {
                    console.log(`Ëß¶ÂèëpieceMove‰∫ã‰ª∂Ôºå‰ªé[${fromRow},${fromCol}]Âà∞[${toRow},${toCol}]`);
                    eventSystem.triggerEvent('pieceMove', {
                        piece: piece,
                        fromRow: fromRow,
                        fromCol: fromCol,
                        row: toRow,  // Ê≥®ÊÑèËøôÈáå‰ΩøÁî®toRow‰Ωú‰∏∫row
                        col: toCol   // Ê≥®ÊÑèËøôÈáå‰ΩøÁî®toCol‰Ωú‰∏∫col
                    });
                }

            }

            // Update UI
            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();
            updateTurnCountDisplay();

            // Update status message and show victory overlay if game is over
            if (gameState.gameOver) {
                const winnerTeam = gameState.winner === BLUE ? 'ËóçÊñπ' : 'Á¥ÖÊñπ';
                statusMessage.textContent = `ÈÅäÊà≤ÁµêÊùüÔºÅ${winnerTeam}ÂãùÂà©ÔºÅ`;

                // Show victory overlay with animation
                showVictoryScreen(gameState.winner);

                // ËôïÁêÜÈóúÂç°ÂÆåÊàêÊàñÂ§±Êïó
                if (levelManager && levelManager.isLevelActive) {
                    if (gameState.winner === BLUE) {
                        levelManager.levelComplete();
                    } else {
                        levelManager.levelFailed();
                    }
                }
            } else {
                statusMessage.textContent = `${gameState.currentTurn === BLUE ? 'ËóçÊñπ' : 'Á¥ÖÊñπ'}ÂõûÂêà„ÄÇ`;

                // Ê™¢Êü•ÈóúÂç°Á≥ªÁµ±ÁöÑÈ°çÂ§ñÂãùÂà©/Êà∞ÊïóÊ¢ù‰ª∂
                if (levelManager && levelManager.isLevelActive) {
                    // Ê™¢Êü•È°çÂ§ñÁöÑÂãùÂà©Ê¢ù‰ª∂
                    if (levelManager.checkVictoryCondition()) {
                        gameState.gameOver = true;
                        gameState.winner = BLUE;
                        statusMessage.textContent = `ÈÅäÊà≤ÁµêÊùüÔºÅËóçÊñπÂãùÂà©ÔºÅ`;
                        showVictoryScreen(BLUE);
                        levelManager.levelComplete();
                        return;
                    }

                    // Ê™¢Êü•È°çÂ§ñÁöÑÊà∞ÊïóÊ¢ù‰ª∂
                    if (levelManager.checkDefeatCondition()) {
                        gameState.gameOver = true;
                        gameState.winner = RED;
                        statusMessage.textContent = `ÈÅäÊà≤ÁµêÊùüÔºÅÁ¥ÖÊñπÂãùÂà©ÔºÅ`;
                        showVictoryScreen(RED);
                        levelManager.levelFailed();
                        return;
                    }
                }
            }

            // If single player mode and it's AI's turn
            if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                console.log(`Ê∫ñÂÇôÂÆâÊéíAIÁßªÂãïÔºåÁï∂ÂâçÂõûÂêà: ${gameState.currentTurn}`);
                // Ê∏ÖÈô§‰ªª‰ΩïÂèØËÉΩÂ≠òÂú®ÁöÑ‰πãÂâçÁöÑË®àÊôÇÂô®
                if (aiMoveTimer) {
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }

                const aiDelay = 2000;
                aiMoveTimer = setTimeout(makeAIMove, aiDelay);
            }
            
            // Âú®‰∫§Êç¢ÂõûÂêàÂêéÔºåÂ¶ÇÊûúÁé∞Âú®ÊòØÁé©ÂÆ∂ÂõûÂêàÔºåÊ£ÄÊü•Áé©ÂÆ∂ÂõΩÁéãÊòØÂê¶Ë¢´Â∞ÜÂÜõ
            if (gameState.currentTurn === BLUE && !gameState.gameOver) {
                // AIÂàöÂàöÁßªÂä®ÂÆåÔºåÁé∞Âú®ÊòØÁé©ÂÆ∂ÂõûÂêàÔºåÊ£ÄÊü•Â∞ÜÂÜõÁä∂ÊÄÅ
                setTimeout(checkPlayerKingInCheck, 300); // Áü≠ÊöÇÂª∂ËøüÁ°Æ‰øùUIÂ∑≤Êõ¥Êñ∞
            }
            
        }

        // Êõ¥Êñ∞ÂõûÂêàÊï∏È°ØÁ§∫
        function updateTurnCountDisplay() {
            const turnCountElement = document.getElementById('turn-count');
            if (turnCountElement) {
                turnCountElement.textContent = gameState.turnCount;
            }
        }

        // Initialize the combat shooting minigame - clean version with no visual elements
        function initSpaceBackground() {
            // Ê∏ÖÁ©∫ËÉåÊôØÂçÄÂüüÔºåÁ¢∫‰øùÊ≤íÊúâ‰ªª‰ΩïË¶ñË¶∫ÂÖÉÁ¥†
            spaceBackground.innerHTML = '';
            // ‰∏çÊ∑ªÂä†‰ªª‰ΩïÊòüÊòü„ÄÅÊòüÈõ≤ÊàñÂÖ∂‰ªñË¶ñË¶∫ÂÖÉÁ¥†Ôºå‰øùÊåÅÁ¥îÁÅ∞Ëâ≤ËÉåÊôØ
        }

        // Ë®≠ÁΩÆÊà∞È¨•Ê®°ÂºèÁãÄÊÖãËøΩËπ§
        let tutorialBattleState = {
            stage: 0, // 0: ÂàùÂßã, 1: Á§∫ÁØÑÊà∞È¨•ÂÆåÊàê, 2: Áé©ÂÆ∂Èò≤ÂÆàÊà∞È¨•ÂÆåÊàê
            inProgress: false
        };

        // È´îÈ©óÊà∞È¨•ÊåâÈàï
        document.getElementById('tutorial-cover-btn').onclick = function() {
            // ÈáçÁΩÆÊà∞È¨•ÁãÄÊÖã
            tutorialBattleState = {
                stage: 0,
                inProgress: false
            };

            // Èö±ËóèÂ∞ÅÈù¢
            coverPage.classList.add('hide');

            // ÂïüÂãïÁ¨¨‰∏ÄÈöéÊÆµÔºöÂ±ïÁ§∫Êà∞È¨•
            startTutorialBattle();
        };

        // ÂïüÂãïÊïôÂ≠∏Êà∞È¨•Â∫èÂàó
        function startTutorialBattle() {
            if (tutorialBattleState.inProgress) return;
            tutorialBattleState.inProgress = true;

            // Âª∂ÈÅ≤‰∏ÄÁßíÂæåÈñãÂßãÁõ∏ÊáâÈöéÊÆµÁöÑÊà∞È¨•
            setTimeout(() => {
                if (tutorialBattleState.stage === 0) {
                    // Á¨¨‰∏ÄÈöéÊÆµÔºöÂ±ïÁ§∫Êà∞È¨• - ÈõªËÖ¶Ëá™ÂãïÂ∞çÊà∞ÊºîÁ§∫
                    console.log("ÈñãÂßãÁ¨¨‰∏ÄÈöéÊÆµÔºöÊà∞È¨•Á§∫ÁØÑ (NuÈ´òÈÅî vs Ê≤ôËñ©ÊØî)");

                    // Âª∫Á´ãÊîªÊìäËÄÖ (NuÈ´òÈÅî, ËóçÊñπ) ÂíåÈò≤ÂÆàËÄÖ (Ê≤ôËñ©ÊØî, Á¥ÖÊñπ)
                    const attackerPiece = {
                        id: 'nu_gundam',
                        team: BLUE,
                        type: 'NuÈ´òÈÅî',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/uUhvX3b.png',
                        hit: 4,
                        dodge: 4
                    };

                    const defenderPiece = {
                        id: 'sazabi',
                        team: RED,
                        type: 'Ê≤ôËñ©ÊØî',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/90O9E1o.png',
                        hit: 4,
                        dodge: 4
                    };

                    // ÊõøÊèõÁµêÊùüÊà∞È¨•ÁöÑÂáΩÊï∏Ôºå‰ª•‰æøÊà∞È¨•ÁµêÊùüÂæåÈÄ≤ÂÖ•‰∏ã‰∏ÄÈöéÊÆµ
                    const originalEndCombat = endCombat;
                    endCombat = function(winner) {
                        originalEndCombat(winner);

                        // Á≠âÂæÖÊà∞È¨•ÁµêÊûúÈ°ØÁ§∫ÂæåÈÄ≤ÂÖ•‰∏ã‰∏ÄÈöéÊÆµ
                        setTimeout(() => {
                            tutorialBattleState.stage = 1;
                            tutorialBattleState.inProgress = false;
                            startTutorialBattle(); // ÂïüÂãïÁ¨¨‰∫åÈöéÊÆµ
                        }, 2000);
                    };

                    // ÂïüÂãïÂ±ïÁ§∫Êà∞È¨•
                    startCombat(attackerPiece, defenderPiece, {row: 7, col: 3}, {row: 0, col: 3});

                } else if (tutorialBattleState.stage === 1) {
                    // Á¨¨‰∫åÈöéÊÆµÔºöÁé©ÂÆ∂Èò≤ÂÆà - Áî±Áé©ÂÆ∂ÊâÆÊºîÈò≤ÂÆàËÄÖ
                    console.log("ÈñãÂßãÁ¨¨‰∫åÈöéÊÆµÔºöÁé©ÂÆ∂Èò≤ÂÆà (Áé©ÂÆ∂NuÈ´òÈÅîÈò≤ÂÆà vs ÈõªËÖ¶Ê≤ôËñ©ÊØîÊîªÊìä)");

                    // Âª∫Á´ãÊîªÊìäËÄÖ (Ê≤ôËñ©ÊØî, ÁèæÂú®ÁÇ∫Á¥ÖÊñπ) ÂíåÈò≤ÂÆàËÄÖ (NuÈ´òÈÅî, ÁèæÂú®ÁÇ∫ËóçÊñπ)
                    // Ê≥®ÊÑèÔºöÊàëÂÄë‰∫§Êèõ‰∫ÜËßíËâ≤Ôºå‰ΩÜ‰øùÊåÅÈô£ÁáüÈ°èËâ≤‰ª•Á¢∫‰øùÁé©ÂÆ∂ÊéßÂà∂ËóçÊñπ
                    const attackerPiece = {
                        id: 'sazabi',
                        team: RED,
                        type: 'Ê≤ôËñ©ÊØî',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/90O9E1o.png',
                        hit: 4,
                        dodge: 4
                    };

                    const defenderPiece = {
                        id: 'nu_gundam',
                        team: BLUE,
                        type: 'NuÈ´òÈÅî',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/uUhvX3b.png',
                        hit: 4,
                        dodge: 4
                    };

                    // ÊõøÊèõÁµêÊùüÊà∞È¨•ÁöÑÂáΩÊï∏Ôºå‰ª•‰æøÊà∞È¨•ÁµêÊùüÂæåËøîÂõûÂ∞ÅÈù¢È†ÅÈù¢
                    const originalEndCombat = endCombat;
                    endCombat = function(winner) {
                        originalEndCombat(winner);

                        // Á≠âÂæÖÊà∞È¨•ÁµêÊûúÈ°ØÁ§∫ÂæåËøîÂõûÂ∞ÅÈù¢È†ÅÈù¢
                        setTimeout(() => {
                            tutorialBattleState.stage = 2;
                            tutorialBattleState.inProgress = false;

                            // ËøîÂõûÂ∞ÅÈù¢È†ÅÈù¢
                            combatOverlay.classList.add('hidden');
                            showCoverPage();

                            // ÊÅ¢Âæ©ÂéüÂßãÁöÑendCombatÂáΩÊï∏
                            endCombat = originalEndCombat;
                        }, 2000);
                    };

                    // ÂïüÂãïÁé©ÂÆ∂Èò≤ÂÆàÊà∞È¨•
                    startCombat(attackerPiece, defenderPiece, {row: 0, col: 3}, {row: 7, col: 3});
                }
            }, 1000);
        }

        // ‰øÆÊîπcombatIntroHTMLÂèòÈáè‰∏≠ÁöÑHTMLÊ®°ÊùøÔºåÂú®ÁßªÂä®Á±ªÂûã‰∏ãÊñπÊ∑ªÂä†Ê≠¶Âô®Á±ªÂûãÊòæÁ§∫
        const combatIntroHTML = `
            <div id="combat-intro-overlay" class="fixed inset-0 bg-black bg-opacity-75 z-[150] flex items-start justify-center transition-opacity duration-500 opacity-0">
                <div class="relative w-full bg-gradient-to-b from-gray-900 to-gray-800 rounded-lg p-2 text-white overflow-hidden shadow-2xl mt-10" style="max-width: 430px;">
                    <div class="absolute inset-0 overflow-hidden">
                        <div class="stars-bg absolute inset-0"></div>
                    </div>
                    <div class="relative z-10">
                        <h2 class="text-center text-lg font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-blue-500">Êà∞È¨•Âç≥Â∞áÈñãÂßã!</h2>

                        <div class="flex flex-col md:flex-row justify-between items-center space-y-3 md:space-y-0 md:space-x-2">
                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-red-500 to-pink-600 text-white py-1 px-2 rounded-t-lg font-bold text-xs">
                                    ÊîªÊìäÊñπ
                                </div>
                                <div class="bg-gray-900 p-2 rounded-b-lg border-2 border-t-0 border-pink-500">
                                    <img id="intro-attacker-img" src="" alt="ÊîªÊìäÊ©üÈ´î" class="w-20 h-20 object-contain mx-auto mb-1">
                                    <h3 id="intro-attacker-name" class="text-sm font-bold mb-0.5 text-pink-300">ÊîªÊìäÊ©üÈ´îÂêçÁ®±</h3>
                                    <p id="intro-attacker-type" class="text-xs mb-1 text-gray-300">ÁßªÂãïÈ°ûÂûã</p>
                                    <p id="intro-attacker-weapon" class="text-xs mb-1 text-yellow-300">Ê≠¶Âô®È°ûÂûã</p>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-pink-400 font-bold text-xs">ÂëΩ‰∏≠:</span>
                                        <span id="intro-attacker-hit" class="font-mono font-bold text-pink-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 mb-1 rounded-full overflow-hidden">
                                        <div id="intro-attacker-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-cyan-400 font-bold text-xs">Ëø¥ÈÅø:</span>
                                        <span id="intro-attacker-dodge" class="font-mono font-bold text-cyan-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 rounded-full overflow-hidden">
                                        <div id="intro-attacker-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="relative">
                                <div class="w-8 h-8 bg-gradient-to-r from-pink-500 to-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                                    VS
                                </div>
                                <div class="absolute -top-1 -left-1 w-2 h-2 bg-yellow-400 rounded-full animate-ping opacity-70"></div>
                                <div class="absolute -bottom-1 -right-1 w-2 h-2 bg-blue-400 rounded-full animate-ping opacity-70 animation-delay-500"></div>
                            </div>

                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-cyan-500 to-blue-600 text-white py-1 px-2 rounded-t-lg font-bold text-xs">
                                    Èò≤ÂÆàÊñπ
                                </div>
                                <div class="bg-gray-900 p-2 rounded-b-lg border-2 border-t-0 border-cyan-500">
                                    <img id="intro-defender-img" src="" alt="Èò≤ÂÆàÊ©üÈ´î" class="w-20 h-20 object-contain mx-auto mb-1">
                                    <h3 id="intro-defender-name" class="text-sm font-bold mb-0.5 text-cyan-300">Èò≤ÂÆàÊ©üÈ´îÂêçÁ®±</h3>
                                    <p id="intro-defender-type" class="text-xs mb-1 text-gray-300">ÁßªÂãïÈ°ûÂûã</p>
                                    <p id="intro-defender-weapon" class="text-xs mb-1 text-yellow-300">Ê≠¶Âô®È°ûÂûã</p>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-pink-400 font-bold text-xs">ÂëΩ‰∏≠:</span>
                                        <span id="intro-defender-hit" class="font-mono font-bold text-pink-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 mb-1 rounded-full overflow-hidden">
                                        <div id="intro-defender-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-cyan-400 font-bold text-xs">Ëø¥ÈÅø:</span>
                                        <span id="intro-defender-dodge" class="font-mono font-bold text-cyan-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 rounded-full overflow-hidden">
                                        <div id="intro-defender-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="text-center mt-2">
                            <div id="intro-countdown" class="hidden">3</div>
                            <p class="text-gray-300 text-xs font-bold animate-pulse">Ê∫ñÂÇôÈÄ≤ÂÖ•Êà∞È¨•!</p>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Start combat mode with introduction window
        function startCombat(attackerPiece, defenderPiece, attackerPos, defenderPos) {
            // Store combat information
            preloadCombatSounds();
            combatMode.active = true;
            combatMode.attacker = attackerPiece;
            combatMode.defender = defenderPiece;
            combatMode.attackerPos = attackerPos;
            combatMode.defenderPos = defenderPos;

            // Determine if player is attacker or defender
            if (gameState.gameMode === 'single-player') {
                combatMode.isPlayerAttacker = attackerPiece.team === BLUE;
                combatMode.isPlayerDefender = defenderPiece.team === BLUE;
            }

            // Âú®Êà∞È¨•ÂâçÊö´ÂÅúÈóúÂç°ËÉåÊôØÈü≥Ê®ÇÔºå‰ΩÜ‰∏çÊ∏ÖÈô§ÂÆÉÔºå‰ª•‰æøÊà∞È¨•ÁµêÊùüÂæåÂèØ‰ª•ÁπºÁ∫åÊí≠Êîæ
            if (boardBgmPlayer) {
                boardBgmPlayer.pause();
            }

            // Âú®Êà∞È¨•Ë≥áË®äÈ†ÅÂ∞±ÈñãÂßãÊí≠ÊîæBGM
            // Âè™ÁÇ∫Áé©ÂÆ∂Ê£ãÂ≠êÊí≠ÊîæBGM
            if (combatMode.attacker.team === BLUE && combatMode.attacker.bgmtype) {
                // ÊîªÊìäËÄÖÊòØÁé©ÂÆ∂‰∏îÊúâbgmtype
                playBattleBGM(combatMode.attacker.bgmtype);
            } else if (combatMode.defender.team === BLUE && combatMode.defender.bgmtype) {
                // Èò≤ÂÆàËÄÖÊòØÁé©ÂÆ∂‰∏îÊúâbgmtype
                playBattleBGM(combatMode.defender.bgmtype);
            }

            // ÂâµÂª∫‰∏¶È°ØÁ§∫‰ªãÁ¥πÂΩàÁ™ó
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = combatIntroHTML;
            const introOverlay = tempDiv.firstElementChild;
            document.body.appendChild(introOverlay);

            // ÊöóÂåñÊ£ãÁõ§ÂÖÉÁ¥†
            const boardDim = document.createElement('div');
            boardDim.id = 'board-dim';
            boardDim.className = 'fixed inset-0 bg-black bg-opacity-60 z-[140] transition-opacity duration-500 opacity-0';
            document.body.appendChild(boardDim);

            // ÂèñÂæóÁßªÂãïÈ°ûÂûãÁöÑ‰∏≠ÊñáÂêçÁ®±
            function getMoveTypeText(moveType) {
                switch(moveType) {
                    case PAWN: return "Ê≠•ÂÖµ";
                    case ROOK: return "ÂüéÂ†°";
                    case KNIGHT: return "È®éÂ£´";
                    case BISHOP: return "‰∏ªÊïô";
                    case QUEEN: return "ÁöáÂêé";
                    case KING: return "ÂúãÁéã";
                    default: return "";
                }
            }

            function getWeaponTypeText(crosshairType) {
                switch(crosshairType) {
                    case "Beam_Rifie": return "ÂÖâÊùüÊ≠•Êßç";
                    case "Beam_Saber": return "ÂÖâÊùüÂäç";
                    case "Cosmo_Nova": return "ÂÆáÂÆôÊñ∞Êòü";
                    case "Destructive_Thunder": return "Á†¥Â£ûÈõ∑Èõª";
                    case "Getter_Beam": return "‰∏â‰∏ÄÊ≠ªÂÖâ"; 
                    case "diamond": return "ÈëΩÁü≥ÂÖâÊùü";
                    case "triangle": return "‰∏âËßíÂÖâÊùü";
                    case "custom": return "Ëá™ÂÆöÁæ©Ê≠¶Âô®";
                    default: return crosshairType || "Êú™Áü•Ê≠¶Âô®";
                }
            }

            // Â°´ÂÖÖ‰ªãÁ¥πË¶ñÁ™óÊï∏Êìö
            const maxValue = 5; // ÂÅáË®≠ÊúÄÂ§ßÂÄºÊòØ5

            // ÊîªÊìäÊñπÊï∏Êìö
            document.getElementById('intro-attacker-img').src = attackerPiece.imgUrl;
            document.getElementById('intro-attacker-name').textContent = attackerPiece.type;
            document.getElementById('intro-attacker-type').textContent = `ÁßªÂãïÈ°ûÂûã: ${getMoveTypeText(attackerPiece.moveType)}`;
            document.getElementById('intro-attacker-weapon').textContent = `Ê≠¶Âô®È°ûÂûã: ${getWeaponTypeText(attackerPiece.crosshairType)}`;
            document.getElementById('intro-attacker-hit').textContent = attackerPiece.hit;
            document.getElementById('intro-attacker-dodge').textContent = attackerPiece.dodge;
            document.getElementById('intro-attacker-hit-bar').style.width = `${(attackerPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-attacker-dodge-bar').style.width = `${(attackerPiece.dodge / maxValue) * 100}%`;

            // Èò≤ÂÆàÊñπÊï∏Êìö
            document.getElementById('intro-defender-img').src = defenderPiece.imgUrl;
            document.getElementById('intro-defender-name').textContent = defenderPiece.type;
            document.getElementById('intro-defender-type').textContent = `ÁßªÂãïÈ°ûÂûã: ${getMoveTypeText(defenderPiece.moveType)}`;
            document.getElementById('intro-defender-weapon').textContent = `Ê≠¶Âô®È°ûÂûã: ${getWeaponTypeText(defenderPiece.crosshairType)}`;
            document.getElementById('intro-defender-hit').textContent = defenderPiece.hit;
            document.getElementById('intro-defender-dodge').textContent = defenderPiece.dodge;
            document.getElementById('intro-defender-hit-bar').style.width = `${(defenderPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-defender-dodge-bar').style.width = `${(defenderPiece.dodge / maxValue) * 100}%`;

            // Âª∂ÈÅ≤È°ØÁ§∫ÂÖÉÁ¥†ÔºåÂâµÈÄ†Ê∑°ÂÖ•ÊïàÊûú
            setTimeout(() => {
                introOverlay.style.opacity = '1';
                boardDim.style.opacity = '1';
            }, 50);

            // ÂÄíÊï∏Ë®àÊôÇ
            let countdown = 3;
            const countdownEl = document.getElementById('intro-countdown');

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);

                    // Ê∑°Âá∫‰ªãÁ¥πË¶ñÁ™óÂíåÊöóÂåñÂ±§
                    introOverlay.style.opacity = '0';
                    boardDim.style.opacity = '0';

                    // ÁßªÈô§ÂÖÉÁ¥†‰∏¶ÈñãÂßãÊà∞È¨•
                    setTimeout(() => {
                        if (introOverlay.parentNode) introOverlay.parentNode.removeChild(introOverlay);
                        if (boardDim.parentNode) boardDim.parentNode.removeChild(boardDim);

                        // ÂàùÂßãÂåñÊà∞È¨•Ê®°Âºè
                        initCombat();
                    }, 500); // Á≠âÂæÖÊ∑°Âá∫ÂãïÁï´ÂÆåÊàê
                } else {
                    countdownEl.textContent = countdown;
                }
            }, 1000);

            // ÂØ¶ÈöõÂàùÂßãÂåñÊà∞È¨•
            function initCombat() {
                // Reset combat state
                combatMode.timer = 3;
                combatMode.timeRemaining = 3000;
                combatMode.lastFrameTime = 0;
                combatMode.bulletFired = false;
                combatMode.defenderMoving = false;
                combatMode.result = null;

                // ÂÖàÈö±ËóèÁµêÊûúÊñáÂ≠ó
                combatResult.classList.remove('show');

                // ÂàùÂßãÂåñÂ§™Á©∫ËÉåÊôØ
                initSpaceBackground();

                // ÂÖàÈ°ØÁ§∫Êà∞È¨•ÂÆπÂô®
                combatOverlay.classList.remove('hidden');

                // ‰ΩøÁî®requestAnimationFrameÁ≠âÂæÖ‰∏ã‰∏ÄÁπ™Ë£ΩÂπÄ
                requestAnimationFrame(() => {
                    // ÂÜçÁî®setTimeoutÁµ¶DOM‰∏ÄÈªûÊôÇÈñìÂÆåÊàêÂØ¶ÈöõÊ∏≤Êüì
                    setTimeout(() => {
                        // Áç≤ÂèñÂÆπÂô®Áü©ÂΩ¢Â∞∫ÂØ∏ÔºàÂú®ÂÆπÂô®ÂÆåÂÖ®Ê∏≤ÊüìÂæåÔºâ
                        const containerRect = combatContainer.getBoundingClientRect();

                        // ÂÆπÂô®Â∞∫ÂØ∏Ê∏¨ÈáèÂÆåÊàê

                        // Ë®≠ÁΩÆËßíËâ≤‰ø°ÊÅØÈ°ØÁ§∫
                        attackerRole.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                        defenderRole.style.display = combatMode.isPlayerDefender ? 'block' : 'none';
                        attackerInstruction.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                        defenderInstruction.style.display = combatMode.isPlayerDefender ? 'block' : 'none';

                        // Ë®≠ÁΩÆÂü∫ÊñºÊîªÊìäËÄÖÂëΩ‰∏≠ÂÄºÁöÑÂçÅÂ≠óÊ∫ñÊòüÂ§ßÂ∞èÔºàÁôæÂàÜÊØîÊñπÂºèÔºâ
                        // Ë®àÁÆóÁôæÂàÜÊØîÂ∞∫ÂØ∏Ôºö(100% + (ÂëΩ‰∏≠ÂÄº-2)*35%) * (20% ÁöÑÂÆπÂô®ÂØ¨Â∫¶)
                        const containerWidth = containerRect.width;
                        const baseSizePercent = 20; // Âü∫Á§éÂ§ßÂ∞èÁÇ∫ÂÆπÂô®ÁöÑ20%
                        const hitMultiplier = 1 + (attackerPiece.hit - 2) * 0.35; // ÂëΩ‰∏≠ÂÄº‰øÆÊ≠£Âõ†Â≠ê
                        const crosshairSizePercent = hitMultiplier * baseSizePercent;
                        combatMode.crosshairSize = containerWidth * (crosshairSizePercent / 100);
                        crosshair.style.width = `${crosshairSizePercent}%`;
                        crosshair.style.height = `${crosshairSizePercent}%`;

                        // Ëé∑ÂèñÊ≠¶Âô®È¢úËâ≤ÂíåÂáÜÊòüÁ±ªÂûã
                        const weaponColor = attackerPiece.weapon_colour || '#FF1493'; // ÈªòËÆ§Ê∑±Á≤âÁ∫¢Ëâ≤
                        const crosshairType = attackerPiece.crosshairType || 'Beam_Rifie'; // ÈªòËÆ§ÂúÜÂΩ¢

                        // Âà†Èô§ÊóßÁöÑÂáÜÊòüÂÜÖÂÆπ
                        while (crosshair.firstChild) {
                            crosshair.removeChild(crosshair.firstChild);
                        }

                        // ÂàõÂª∫Êñ∞ÁöÑÂáÜÊòüÂÖÉÁ¥†
                        const newCrosshair = createCrosshair(crosshairType, weaponColor, combatMode.crosshairSize);

                        // Â∞ÜÊñ∞ÂáÜÊòüÁöÑÂÜÖÂÆπÊ∑ªÂä†Âà∞Áé∞ÊúâÂáÜÊòüÂÆπÂô®
                        crosshair.innerHTML = newCrosshair.innerHTML;

                        // Ë®≠ÁΩÆÈò≤ÂÆàËÄÖÂ∞∫ÂØ∏ÁÇ∫ÂÆπÂô®ÂØ¨Â∫¶ÁöÑÁôæÂàÜÊØî
                        defender.style.width = `${combatMode.defenderSizePercent}%`;
                        defender.style.height = `${combatMode.defenderSizePercent}%`;

                        // Ë®àÁÆóÂØ¶ÈöõÁöÑÈò≤ÂÆàËÄÖÂ∞∫ÂØ∏ÔºàÂü∫ÊñºÂÆπÂô®ÂØ¨Â∫¶ÁöÑÁôæÂàÜÊØîÔºâ
                        const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);

                        // Èò≤ÂÆàËÄÖÈÄüÂ∫¶Âü∫ÊñºÂÆπÂô®ÂØ¨Â∫¶ÁöÑÁôæÂàÜÊØî
                        // Ë®àÁÆóÈÄüÂ∫¶ÁôæÂàÜÊØîÔºö(ÂõûÈÅøÂÄº - 2)*‰πòÊï∏ + Âü∫ÂÄº ÁöÑÂÆπÂô®ÂØ¨Â∫¶/ÂπÄ
                        // Ëã•Áé©ÂÆ∂ÊòØÈò≤ÂÆàËÄÖÔºå‰ΩøÁî®ËºÉ‰ΩéÁöÑÈÄüÂ∫¶
                        let speedMultiplier = 1.5; // ÈªòË™ç‰πòÊï∏
                        let speedBase = 3; // ÈªòË™çÂü∫ÂÄº

                        if (combatMode.isPlayerDefender) {
                            // Áé©ÂÆ∂‰ΩúÁÇ∫Èò≤ÂÆàËÄÖÊôÇÔºåÈôç‰ΩéÁßªÂãïÈÄüÂ∫¶
                            speedMultiplier = 0.8; // Èôç‰Ωé‰πòÊï∏
                            speedBase = 1.5; // Èôç‰ΩéÂü∫ÂÄº
                        }

                        // Áé∞Âú®defenderSpeedPercent‰ª£Ë°®ÊØèÁßíÁßªÂä®Â§öÂ∞ëÁôæÂàÜÊØîÁöÑÂÆπÂô®ÂÆΩÂ∫¶
                        const defenderSpeedPercent = (defenderPiece.dodge - 2) * speedMultiplier + speedBase;
                        // ËΩ¨Êç¢‰∏∫ÊØèÁßíÂ§öÂ∞ëÂÉèÁ¥†
                        combatMode.defenderSpeed = containerRect.width * (defenderSpeedPercent / 100);

                        // Update combat info panel
                        attackerName.textContent = attackerPiece.type;
                        defenderName.textContent = defenderPiece.type;
                        attackerImage.src = attackerPiece.imgUrl;
                        defenderImage.src = defenderPiece.imgUrl;

                        // Apply responsive sizing to combat elements based on container width
                        const infoContainer = document.querySelector('.combat-info-panel');
                        if (infoContainer) {
                            const attackerInfo = document.querySelector('.attacker-info');
                            const defenderInfo = document.querySelector('.defender-info');
                            if (attackerInfo && defenderInfo) {
                                attackerInfo.style.height = '24%';
                                defenderInfo.style.height = '24%';
                            }
                        }

                        // Set stat bars
                        const maxHit = 5; // Assume 5 is max hit value
                        const maxDodge = 5; // Assume 5 is max dodge value

                        const hitPercentage = (attackerPiece.hit / maxHit) * 100;
                        const dodgePercentage = (defenderPiece.dodge / maxDodge) * 100;

                        attackerHitBar.style.width = `${hitPercentage}%`;
                        defenderDodgeBar.style.width = `${dodgePercentage}%`;

                        // Set combat info text
                        combatInfo.textContent = `${attackerPiece.type} vs ${defenderPiece.type}`;

                        // Set defender image
                        defender.innerHTML = `<img src="${defenderPiece.imgUrl}" alt="${defenderPiece.type}">`;

                        // Â∞áÈò≤ÂÆàËÄÖÈö®Ê©üÊîæÁΩÆÂú®ÂõõÂÄãÈ†êË®≠‰ΩçÁΩÆ‰πã‰∏Ä
                        // Èö®Ê©üÈÅ∏Êìá‰∏ÄÂÄã‰ΩçÁΩÆ (0-3)
                        const positionIndex = Math.floor(Math.random() * 4);
                        let xPercent, yPercent;

                        // Ê†πÊìöÈö®Ê©üÊï∏ÈÅ∏Êìá‰ΩçÁΩÆ
                        switch(positionIndex) {
                            case 0: // Âè≥‰∏ãËßí
                                xPercent = 0.8;
                                yPercent = 0.8;
                                break;
                            case 1: // Âè≥‰∏äËßí
                                xPercent = 0.8;
                                yPercent = 0.2;
                                break;
                            case 2: // Â∑¶‰∏ãËßí
                                xPercent = 0.2;
                                yPercent = 0.8;
                                break;
                            case 3: // Â∑¶‰∏äËßí
                                xPercent = 0.2;
                                yPercent = 0.2;
                                break;
                        }

                        // Ë®≠ÁΩÆÈò≤ÂÆàËÄÖ‰ΩçÁΩÆÁÇ∫Ë®àÁÆóÂá∫ÁöÑÂùêÊ®ô
                        combatMode.defenderX = containerRect.width * xPercent;
                        combatMode.defenderY = containerRect.height * yPercent;

                        // Êõ¥Êñ∞Ë¶ñË¶∫‰ΩçÁΩÆ
                        defender.style.left = `${combatMode.defenderX}px`;
                        defender.style.top = `${combatMode.defenderY}px`;

                        // ÂàùÂßãÂåñÈò≤ÂÆàËÄÖÂùêÊ®ôÂÆåÊàê
                        stopBoardBGM();

                        // Start crosshair near the defender but not directly on it
                        if (combatMode.isPlayerAttacker) {
                            combatMode.mouseX = containerRect.width / 2 + 50;
                            combatMode.mouseY = containerRect.height / 2 + 50;
                        } else {
                            // For AI, initialize offscreen until game starts
                            combatMode.mouseX = -100;
                            combatMode.mouseY = -100;
                        }

                        // ÂàùÂßãÂåñÊªëÈº†ÂèäÊ∫ñÊòü‰ΩçÁΩÆÂÆåÊàê

                        crosshair.style.left = `${combatMode.mouseX}px`;
                        crosshair.style.top = `${combatMode.mouseY}px`;

                        // Add event listeners for combat
                        if (combatMode.isPlayerAttacker) {
                            combatContainer.addEventListener('mousemove', handleAttackerMouseMove);
                            combatContainer.addEventListener('click', handleAttackerClick);
                            combatContainer.addEventListener('touchmove', handleAttackerTouchMove);
                            combatContainer.addEventListener('touchstart', handleAttackerTouch);
                        }

                        if (combatMode.isPlayerDefender) {
                            combatContainer.addEventListener('mousemove', handleDefenderMouseMove);
                            combatContainer.addEventListener('click', handleDefenderClick);
                            combatContainer.addEventListener('touchmove', handleDefenderTouchMove);
                            combatContainer.addEventListener('touchstart', handleDefenderTouch);

                            // Show the defender target indicator
                            defenderTarget.style.display = 'block';
                        }

                        // Start AI if needed
                        if (!combatMode.isPlayerAttacker) {
                            setTimeout(startAIAttacker, 1000); // Slight delay before AI attacks
                        }

                        if (!combatMode.isPlayerDefender) {
                            startAIDefender();
                        }

                        // Start combat animation frame loop
                        requestAnimationFrame(updateCombat);
                    }, 50); // Áµ¶DOM 50msÁöÑÊôÇÈñìÂÆåÊàêÊ∏≤Êüì
                });
            }
        }

        // Handle attacker mouse movement
        function handleAttackerMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;

            const rect = combatContainer.getBoundingClientRect();

            // Get mouse position relative to container
            combatMode.mouseX = e.clientX - rect.left;
            combatMode.mouseY = e.clientY - rect.top;

            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
        }

        // Handle attacker touch movement
        function handleAttackerTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // Get touch position relative to container
            combatMode.mouseX = touch.clientX - rect.left;
            combatMode.mouseY = touch.clientY - rect.top;

            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
        }

        // Handle attacker click (shooting)
        function handleAttackerClick(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            shootLaser();
        }

        // Handle attacker touch (shooting)
        function handleAttackerTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            e.preventDefault();

            // Ëé∑ÂèñËß¶Êë∏ÁÇπÂùêÊ†á
            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // Êõ¥Êñ∞ÂáÜÊòü‰ΩçÁΩÆ
            combatMode.mouseX = touch.clientX - rect.left;
            combatMode.mouseY = touch.clientY - rect.top;
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;

            // ÂáÜÊòü‰ΩçÁΩÆÊõ¥Êñ∞ÂêéÔºåÂª∂Ëøü300ÊØ´ÁßíÂÜçÂ∞ÑÂáª
            // ËøôÁªôÁî®Êà∑Êèê‰æõ‰∫ÜÁûÑÂáÜÁöÑÊó∂Èó¥
            setTimeout(function() {
                if (combatMode.active && !combatMode.bulletFired) {
                    // ÊòæÁ§∫ËßÜËßâÂèçÈ¶à
                    crosshair.classList.add('firing');
                    // Â∞ÑÂáª
                    shootLaser();
                }
            }, 10);
        }

        // Handle defender mouse movement
        function handleDefenderMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;

            const rect = combatContainer.getBoundingClientRect();

            // Record target position for click to move
            combatMode.defenderTargetX = e.clientX - rect.left;
            combatMode.defenderTargetY = e.clientY - rect.top;

            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }

        // Handle defender touch movement
        function handleDefenderTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // Record target position for touch to move
            combatMode.defenderTargetX = touch.clientX - rect.left;
            combatMode.defenderTargetY = touch.clientY - rect.top;

            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }

        // Handle defender click (evasive move)
        function handleDefenderClick(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            startDefenderMovement();
        }

        // Handle defender touch (evasive move)
        function handleDefenderTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            e.preventDefault();
            startDefenderMovement();
        }

        // Start the defender movement to target
        function startDefenderMovement() {
            // ËÆ∞ÂΩïÂºÄÂßãÁßªÂä®ÁöÑÊó∂Èó¥
            combatMode.moveStartTime = Date.now();
            // ËÆ∞ÂΩïÂºÄÂßã‰ΩçÁΩÆ
            combatMode.moveStartX = combatMode.defenderX;
            combatMode.moveStartY = combatMode.defenderY;

            // ËÆæÁΩÆÁßªÂä®Áä∂ÊÄÅ
            combatMode.defenderMoving = true;

            // ‰ªçÁÑ∂‰øùÁïôÊó∂Èó¥ÈôêÂà∂Á°Æ‰øùÁßªÂä®‰∏ç‰ºöÊó†ÈôêÊåÅÁª≠
            setTimeout(() => {
                combatMode.defenderMoving = false;
            }, 200);
        }

        function shootLaser() {
            if (combatMode.bulletFired) return;

            combatMode.bulletFired = true;

            // Ëé∑ÂèñÂΩìÂâçÊîªÂáªËÄÖÁöÑÊ≠¶Âô®È¢úËâ≤
            const weaponColor = combatMode.attacker.weapon_colour || '#FF1493'; // ÈªòËÆ§Ê∑±Á≤âÁ∫¢Ëâ≤

            // Ëé∑ÂèñÂáÜÊòüÁ±ªÂûã
            const crosshairType = combatMode.attacker.crosshairType || 'Beam_Rifie';

            // Ê†πÊçÆÂáÜÊòüÁ±ªÂûãÊí≠Êîæ‰∏çÂêåÁöÑÈü≥Êïà
            if (crosshairType === 'Beam_Saber') {
                // Êí≠ÊîæÂÖâÊùüÂâëÈü≥Êïà
                playCombatSound(beamSaberSound);
            } else if (crosshairType === 'Cosmo_Nova') {
                // Êí≠ÊîæÂÆáÂÆôÊñ∞ÊòüÈü≥Êïà
                playCombatSound(cosmoNovaSound);
            } else if (crosshairType === 'Destructive_Thunder') {
                // Êí≠ÊîæÈõ∑ÁîµÈü≥Êïà
                playCombatSound(thunderSound);
            } else {
                // Êí≠ÊîæÊøÄÂÖâÊû™Èü≥Êïà
                playCombatSound(beamGunSound);
            }   

            // Ê†πÊçÆÂáÜÊòüÁ±ªÂûã‰ΩøÁî®‰∏çÂêåÁöÑÊîªÂáªÊïàÊûú
            switch(crosshairType) {
                case 'Beam_Rifie':
                    createLaserBeamEffect(weaponColor);
                    break;
                case 'Beam_Saber':
                    createEnergyPulseEffect(weaponColor);
                    break;
                case 'Cosmo_Nova':
                    createConvergeShotEffect(weaponColor);
                    break;
                case 'Destructive_Thunder':
                    createThunderConvergenceEffect(weaponColor);
                    break;
                case 'Getter_Beam':
                    createGetterBeamEffect(weaponColor);
                    break;
                case 'diamond':
                    createScatterShotEffect(weaponColor);
                    break;
                case 'triangle':
                    createPowerBeamEffect(weaponColor);
                    break;
                case 'custom':
                    createSpiralBeamEffect(weaponColor);
                    break;
                default:
                    createLaserBeamEffect(weaponColor); // ÈªòËÆ§‰ΩøÁî®ÊøÄÂÖâÊïàÊûú
            }

            // Delayed hit detection - 150ms delay
            setTimeout(() => {
                // Check hit detection after delay
                checkHit();

                // If missed, end combat after a short delay
                if (!combatMode.result) {
                    setTimeout(() => {
                        endCombat('defender');
                    }, 500);
                }
            }, 150); // Âª∂ÈÅ≤150ÊØ´ÁßíÈÄ≤Ë°åÂëΩ‰∏≠Âà§ÂÆö
        }

        function createLaserBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Create multiple laser beams for a more spectacular effect
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    // Main laser beam
                    const laser = document.createElement('div');
                    laser.className = 'laser';

                    // Position laser at crosshair
                    laser.style.left = `${combatMode.mouseX}px`;
                    laser.style.top = `${combatMode.mouseY}px`;

                    // Random angle for visual variety
                    const baseAngle = i * 60; // Spread evenly around 360 degrees
                    const angle = baseAngle + (Math.random() * 20 - 10); // Small random variation
                    const length = containerRect.width * 1.5; // Longer laser

                    laser.style.width = `${length}px`;
                    laser.style.height = `${Math.random() * 3 + 5}px`; // Thicker lasers (5-8px)
                    laser.style.transform = `rotate(${angle}deg)`;

                    // ‰ΩøÁî®Ê£ãÂ≠êÁöÑÊ≠¶Âô®È¢úËâ≤ËÆæÁΩÆÊøÄÂÖâÊ†∑Âºè
                    laser.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 0.5)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.5)} 100%)`;
                    laser.style.boxShadow = `0 0 10px ${weaponColor}, 0 0 20px ${weaponColor}`;

                    combatContainer.appendChild(laser);

                    // Add a glow effect behind the laser
                    const glow = document.createElement('div');
                    glow.className = 'laser-glow';
                    glow.style.left = `${combatMode.mouseX}px`;
                    glow.style.top = `${combatMode.mouseY}px`;
                    glow.style.width = `${length}px`;
                    glow.style.height = `${Math.random() * 10 + 20}px`; // Thicker glow
                    glow.style.transform = `rotate(${angle}deg)`;

                    // ËÆæÁΩÆÂÖâÊôïÈ¢úËâ≤
                    glow.style.background = hexToRgba(weaponColor, 0.1);

                    combatContainer.appendChild(glow);

                    // Remove after animation
                    setTimeout(() => {
                        if (laser.parentNode) laser.parentNode.removeChild(laser);
                        if (glow.parentNode) glow.parentNode.removeChild(glow);
                    }, 300);
                }, i * 40); // Stagger the laser beams
            }
        }

        function createEnergyPulseEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // ËÆ°ÁÆóÈïøÊñπÂΩ¢ÂáÜÊòüÁöÑÂ∞∫ÂØ∏ÂíåÈ°∂ÈÉ®‰ΩçÁΩÆ
            // ÂÅáËÆæÂáÜÊòüÁöÑÈ´òÂ∫¶ÊòØÂÆΩÂ∫¶ÁöÑ6ÂÄçÔºå‰∏∫ÂÆπÂô®ÁöÑouterSize*0.4*6
            const outerSize = combatMode.crosshairSize * 0.8; // Â§ñÊ°ÜÂ§ßÂ∞è‰∏∫ÂÆπÂô®Â§ßÂ∞èÁöÑ80%
            const frameWidth = Math.round(outerSize * 0.4);
            const frameHeight = frameWidth * 6; // È´òÂ∫¶ÊòØÂÆΩÂ∫¶ÁöÑ6ÂÄç

            // ËÆ°ÁÆóÂáÜÊòüÈ°∂ÈÉ®‰ΩçÁΩÆÔºà‰ªéÈº†Ê†á‰ΩçÁΩÆ‰∏äÁßªframeHeight/2Ôºâ
            const saberTopY = combatMode.mouseY - frameHeight / 2;

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSSÔºåË∞ÉÊï¥ËÉΩÈáèÊü±Âä®ÁîªÂè™Âà∞ÂÆπÂô®È´òÂ∫¶
            addCSSIfNeeded(`
                @keyframes energyPulse {
                    0% { height: 0; opacity: 0.8; }
                    30% { opacity: 1; }
                    90% { height: ${containerRect.height - saberTopY}px; }
                    100% { height: ${containerRect.height - saberTopY}px; opacity: 0; }
                }

                @keyframes pulseGlow {
                    0% { opacity: 0.3; transform: scale(1); }
                    50% { opacity: 0.6; transform: scale(1.2); }
                    100% { opacity: 0; transform: scale(1.5); }
                }

                @keyframes shockwaveRing {
                    0% { width: 0; height: 0; opacity: 0.7; }
                    100% { width: ${containerRect.width * 0.7}px; height: ${containerRect.width * 0.7}px; opacity: 0; }
                }
            `);

            // ‰∏ªËÉΩÈáèÊü±ÊïàÊûú - ‰ªéÂáÜÊòüÈ°∂ÈÉ®ÂºÄÂßã
            const pulse = document.createElement('div');
            pulse.style.position = 'absolute';
            pulse.style.left = `${combatMode.mouseX}px`;
            pulse.style.top = `${saberTopY}px`; // ËÆæÁΩÆ‰∏∫ÂáÜÊòüÈ°∂ÈÉ®‰ΩçÁΩÆ
            pulse.style.width = `${Math.max(30, containerRect.width * 0.05)}px`; // ÂÆΩÂ∫¶‰∏∫ÂÆπÂô®ÂÆΩÂ∫¶ÁöÑ5%ÔºåÊúÄÂ∞è30px
            pulse.style.transformOrigin = 'center top';
            pulse.style.background = `linear-gradient(0deg, ${hexToRgba(weaponColor, 0.3)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.3)} 100%)`;
            pulse.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
            pulse.style.zIndex = '15';
            pulse.style.animation = 'energyPulse 0.45s forwards'; // Áï•ÂæÆÁº©Áü≠Âä®ÁîªÊó∂Èó¥
            pulse.style.transform = 'translateX(-50%)';
            combatContainer.appendChild(pulse);

            // Ê∑ªÂä†ËÉΩÈáèÊü±È°∂ÈÉ®Ëµ∑ÂßãÁâπÊïà
            const pulseStart = document.createElement('div');
            pulseStart.style.position = 'absolute';
            pulseStart.style.left = `${combatMode.mouseX}px`;
            pulseStart.style.top = `${saberTopY}px`;
            pulseStart.style.width = `${Math.max(40, containerRect.width * 0.07)}px`; // Áï•ÂÆΩ‰∫éËÉΩÈáèÊü±
            pulseStart.style.height = `${Math.max(40, containerRect.width * 0.07)}px`;
            pulseStart.style.borderRadius = '50%';
            pulseStart.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, transparent 70%)`;
            pulseStart.style.boxShadow = `0 0 15px ${weaponColor}`;
            pulseStart.style.transform = 'translate(-50%, -50%)';
            pulseStart.style.zIndex = '16';
            pulseStart.style.opacity = '1';
            pulseStart.style.animation = 'pulseGlow 0.4s forwards';
            combatContainer.appendChild(pulseStart);

            // Ê∑ªÂä†ËÑâÂÜ≤ÂúÜÁéØÊïàÊûú - Âú®ÂáÜÊòüÈ°∂ÈÉ®‰ΩçÁΩÆ
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.left = `${combatMode.mouseX}px`;
                    ring.style.top = `${saberTopY}px`; // ËÆæÁΩÆ‰∏∫ÂáÜÊòüÈ°∂ÈÉ®‰ΩçÁΩÆ
                    ring.style.borderRadius = '50%';
                    ring.style.border = `3px solid ${hexToRgba(weaponColor, 0.7)}`;
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.zIndex = '14';
                    ring.style.animation = 'shockwaveRing 0.7s forwards ease-out';
                    combatContainer.appendChild(ring);

                    setTimeout(() => {
                        if (ring.parentNode) ring.parentNode.removeChild(ring);
                    }, 700);
                }, i * 150); // Âä†Âø´ÂúÜÁéØÂá∫Áé∞È¢ëÁéá
            }

            // Ê∑ªÂä†Âú∞Èù¢ÂÖâÊôïÊïàÊûú - ÂáÜÊòü‰∏éÂú∞Èù¢Áõ∏‰∫§‰ΩçÁΩÆ
            setTimeout(() => {
                const glow = document.createElement('div');
                glow.style.position = 'absolute';
                glow.style.left = `${combatMode.mouseX}px`;
                glow.style.top = `${containerRect.height}px`; // Â∫ïÈÉ®
                glow.style.width = `${Math.max(70, containerRect.width * 0.12)}px`; // Á®çÂæÆÂ¢ûÂä†ÂÆΩÂ∫¶
                glow.style.height = `${Math.max(35, containerRect.height * 0.06)}px`; // Á®çÂæÆÂ¢ûÂä†È´òÂ∫¶
                glow.style.background = `radial-gradient(ellipse at center, ${hexToRgba(weaponColor, 0.9)} 0%, ${hexToRgba(weaponColor, 0.2)} 60%, transparent 100%)`;
                glow.style.borderRadius = '50%';
                glow.style.filter = 'blur(6px)'; // Â¢ûÂº∫Ê®°Á≥äÊïàÊûú
                glow.style.transform = 'translateX(-50%)';
                glow.style.zIndex = '13';
                glow.style.animation = 'pulseGlow 0.8s forwards';
                combatContainer.appendChild(glow);

                // Ê∑ªÂä†Âú∞Èù¢ÂÜ≤ÂáªÊ≥¢
                const groundRing = document.createElement('div');
                groundRing.style.position = 'absolute';
                groundRing.style.left = `${combatMode.mouseX}px`;
                groundRing.style.top = `${containerRect.height}px`; // Â∫ïÈÉ®
                groundRing.style.transform = 'translate(-50%, 0)';
                groundRing.style.borderRadius = '50% 50% 0 0'; // Âè™Êúâ‰∏äÂçäÂúÜ
                groundRing.style.height = `${containerRect.height * 0.05}px`;
                groundRing.style.border = `2px solid ${hexToRgba(weaponColor, 0.6)}`;
                groundRing.style.borderBottom = 'none';
                groundRing.style.zIndex = '12';
                groundRing.style.opacity = '0.7';
                groundRing.style.animation = 'shockwaveRing 0.6s forwards ease-out';
                groundRing.style.width = '0';
                combatContainer.appendChild(groundRing);

                setTimeout(() => {
                    if (groundRing.parentNode) groundRing.parentNode.removeChild(groundRing);
                    if (glow.parentNode) glow.parentNode.removeChild(glow);
                }, 800);
            }, 150); // ËÉΩÈáèÊü±Âà∞ËææÂú∞Èù¢ÁöÑÊó∂Èó¥

            // Ê∏ÖÁêÜÂÖÉÁ¥†
            setTimeout(() => {
                if (pulse.parentNode) pulse.parentNode.removeChild(pulse);
                if (pulseStart.parentNode) pulseStart.parentNode.removeChild(pulseStart);
            }, 800);
        }

        function createConvergeShotEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS
            addCSSIfNeeded(`
                @keyframes convergeShot {
                    0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.3; }
                    90% { transform: translate(-50%, -50%) scale(0.4); opacity: 0.8; }
                    100% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; }
                }
        
                @keyframes centralExplosion {
                    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; }
                    50% { opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
                }

                @keyframes convergeParticle {
                    0% { transform: translate(var(--tx), var(--ty)) scale(1); opacity: 1; }
                    90% { transform: translate(0, 0) scale(0.6); opacity: 0.8; }
                    100% { transform: translate(0, 0) scale(0.2); opacity: 0; }
                }
            `);

            // ÂàõÂª∫‰∏≠ÂøÉÊ±áËÅöÂå∫Âüü
            const convergeZone = document.createElement('div');
            convergeZone.style.position = 'absolute';
            convergeZone.style.left = `${combatMode.mouseX}px`;
            convergeZone.style.top = `${combatMode.mouseY}px`;
            convergeZone.style.width = `${containerRect.width * 0.05}px`; // ÂàùÂßãËæÉÂ∞è
            convergeZone.style.height = `${containerRect.width * 0.05}px`;
            convergeZone.style.borderRadius = '50%';
            convergeZone.style.background = `radial-gradient(circle, ${hexToRgba(weaponColor, 0.7)} 0%, ${hexToRgba(weaponColor, 0.3)} 70%, transparent 100%)`;
            convergeZone.style.boxShadow = `0 0 10px ${weaponColor}`;
            convergeZone.style.zIndex = '16';
            convergeZone.style.animation = 'convergeShot 0.7s forwards';
            convergeZone.style.transform = 'translate(-50%, -50%) scale(1.5)';
            combatContainer.appendChild(convergeZone);

            // ÂàõÂª∫Ê±áËÅöÁ≤íÂ≠ê
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) + (Math.random() * 20 - 10); // Â∞Ü360Â∫¶ÂàÜÊàê12‰ªΩ
                const radian = (angle * Math.PI) / 180;
                const distance = containerRect.width * (0.2 + Math.random() * 0.3); // 20%-50%ÁöÑÂÆπÂô®ÂÆΩÂ∫¶

                const tx = Math.cos(radian) * distance;
                const ty = Math.sin(radian) * distance;

                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.left = `${combatMode.mouseX}px`;
                particle.style.top = `${combatMode.mouseY}px`;
                particle.style.width = `${8 + Math.random() * 7}px`; // 8-15px
                particle.style.height = `${8 + Math.random() * 7}px`;
                particle.style.borderRadius = '50%';
                particle.style.background = `${hexToRgba(weaponColor, 0.9)}`;
                particle.style.boxShadow = `0 0 10px ${weaponColor}`;
                particle.style.zIndex = '17';

                // ‰ΩøÁî®CSSÂèòÈáè‰º†ÈÄí‰∏çÂêåÁöÑËµ∑Âßã‰ΩçÁΩÆÔºà‰∏éÊï£Â∞ÑÁõ∏ÂèçÔºâ
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                // ÂàùÂßã‰ΩçÁΩÆËÆæÁΩÆÂú®Â§ñÂõ¥
                particle.style.transform = `translate(${tx}px, ${ty}px)`;
                particle.style.animation = 'convergeParticle 0.7s forwards';

                combatContainer.appendChild(particle);

                // Ê∏ÖÁêÜÁ≤íÂ≠ê
                setTimeout(() => {
                    if (particle.parentNode) particle.parentNode.removeChild(particle);
                }, 700);
            }

            // Á≤íÂ≠êÊ±áËÅöÂêéÔºåÂàõÂª∫‰∏≠ÂøÉÁàÜÁÇ∏ÊïàÊûú
            setTimeout(() => {
                const centerExplosion = document.createElement('div');
                centerExplosion.style.position = 'absolute';
                centerExplosion.style.left = `${combatMode.mouseX}px`;
                centerExplosion.style.top = `${combatMode.mouseY}px`;
                centerExplosion.style.width = `${containerRect.width * 0.15}px`; // ÊØîÂàùÂßãÂå∫ÂüüÂ§ß
                centerExplosion.style.height = `${containerRect.width * 0.15}px`;
                centerExplosion.style.borderRadius = '50%';
                centerExplosion.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, ${hexToRgba(weaponColor, 0.2)} 70%, transparent 100%)`;
                centerExplosion.style.boxShadow = `0 0 30px ${weaponColor}, 0 0 50px ${weaponColor}`;
                centerExplosion.style.zIndex = '18';
                centerExplosion.style.animation = 'centralExplosion 0.5s forwards';
                centerExplosion.style.transform = 'translate(-50%, -50%) scale(0.2)';
                combatContainer.appendChild(centerExplosion);

                // Ê∑ªÂä†ÂÖâÊôïÊ≥¢Á∫π
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const ripple = document.createElement('div');
                        ripple.style.position = 'absolute';
                        ripple.style.left = `${combatMode.mouseX}px`;
                        ripple.style.top = `${combatMode.mouseY}px`;
                        ripple.style.width = `${containerRect.width * 0.1 * (i+1)}px`;
                        ripple.style.height = `${containerRect.width * 0.1 * (i+1)}px`;
                        ripple.style.borderRadius = '50%';
                        ripple.style.border = `2px solid ${hexToRgba(weaponColor, 0.8 - i*0.2)}`;
                        ripple.style.boxShadow = `0 0 15px ${weaponColor}`;
                        ripple.style.zIndex = '17';
                        ripple.style.transform = 'translate(-50%, -50%) scale(0)';
                        ripple.style.animation = 'centralExplosion 0.4s forwards';
                        combatContainer.appendChild(ripple);

                        // Ê∏ÖÁêÜÊ≥¢Á∫π
                        setTimeout(() => {
                            if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
                        }, 400);
                    }, i * 100); // ‰æùÊ¨°‰∫ßÁîüÊ≥¢Á∫π
                }

                // Ê∏ÖÁêÜ‰∏≠ÂøÉÁàÜÁÇ∏
                setTimeout(() => {
                    if (centerExplosion.parentNode) centerExplosion.parentNode.removeChild(centerExplosion);
                }, 500);
            }, 650); // Âú®Á≤íÂ≠êÂø´Ë¶ÅÊ±áËÅöÂÆåÊàêÊó∂Ëß¶ÂèëÁàÜÁÇ∏

            // Ê∏ÖÁêÜÊ±áËÅöÂå∫Âüü
            setTimeout(() => {
                if (convergeZone.parentNode) convergeZone.parentNode.removeChild(convergeZone);
            }, 700);
        }

        function createThunderConvergenceEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();
            const centerX = combatMode.mouseX;
            const centerY = combatMode.mouseY;
    
            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS - ÁÆÄÂåñÂä®ÁîªÂÆö‰πâ
            addCSSIfNeeded(`
                @keyframes thunderBolt {
                    0% { stroke-dashoffset: 2000; opacity: 0; }
                    15% { opacity: 1; }
                    40% { stroke-dashoffset: 0; opacity: 1; }
                    100% { opacity: 0; }
                }

                @keyframes thunderPulse {
                    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
                    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }

                @keyframes thunderRipple {
                    0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; stroke-width: 8px; }
                    100% { transform: translate(-50%, -50%) scale(3); opacity: 0; stroke-width: 1px; }
                }
            `);

            // Èó™ÁîµÈ¢úËâ≤Ôºö‰∏ªËâ≤ÂíåÈ´ò‰∫ÆËâ≤
            const baseColor = weaponColor;
            const highlightColor = '#FFFFFF'; // ÁôΩËâ≤È´ò‰∫ÆÈÉ®ÂàÜ

            // ‰∏≠ÂøÉÁàÜÂèëÊïàÊûú
            const centerEffect = document.createElement('div');
            centerEffect.style.position = 'absolute';
            centerEffect.style.left = `${centerX}px`;
            centerEffect.style.top = `${centerY}px`;
            centerEffect.style.width = `${containerRect.width * 0.15}px`;
            centerEffect.style.height = `${containerRect.width * 0.15}px`;
            centerEffect.style.borderRadius = '50%';
            centerEffect.style.background = `radial-gradient(circle, ${highlightColor} 0%, ${hexToRgba(baseColor, 0.9)} 30%, ${hexToRgba(baseColor, 0.2)} 70%, transparent 100%)`;
            centerEffect.style.boxShadow = `0 0 30px ${baseColor}, 0 0 50px ${baseColor}`;
            centerEffect.style.zIndex = '19';
            centerEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
            centerEffect.style.animation = 'thunderPulse 0.8s forwards';
            combatContainer.appendChild(centerEffect);
    
            // ‰ºòÂåñÁÇπ1: ‰ªéÂõõ‰∏™ÊñπÂêëÂàõÂª∫Ê±áËÅöÁöÑÈó™ÁîµÔºå‰ΩÜÂáèÂ∞ëÊØè‰∏™ÊñπÂêëÁöÑÈó™ÁîµÊï∞Èáè
            const directions = [
                { angle: 45, label: 'rightDown'}, // Âè≥‰∏ã
                { angle: 135, label: 'leftDown'}, // Â∑¶‰∏ã
                { angle: 225, label: 'leftUp'},   // Â∑¶‰∏ä
                { angle: 315, label: 'rightUp'}   // Âè≥‰∏ä
            ];

            // ‰ºòÂåñÁÇπ1: ÂáèÂ∞ëÈó™ÁîµÊï∞Èáè - ‰ªé2-4Êù°ÂáèÂ∞ëÂà∞1-2Êù°
            directions.forEach((dir, i) => {
                // ÂáèÂ∞ëÈó™ÁîµÊï∞Èáè
                const boltCount = 1 + Math.floor(Math.random() * 2);
        
                for (let j = 0; j < boltCount; j++) {
                    setTimeout(() => {
                        createLightningBolt(dir.angle, i * 80 + j * 60, j);
                }, i * 80 + j * 60);
                }
            });

            // ‰ºòÂåñÁÇπ4: ÂáèÂ∞ëÊº£Êº™ÊïàÊûú - Âè™‰øùÁïô1‰∏™Ê∂üÊº™
            setTimeout(() => {
                const ripple = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                ripple.style.position = 'absolute';
                ripple.style.left = '0';
                ripple.style.top = '0';
                ripple.style.width = '100%';
                ripple.style.height = '100%';
                ripple.style.zIndex = '17';
                ripple.setAttribute('viewBox', `0 0 ${containerRect.width} ${containerRect.height}`);
        
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', containerRect.width * 0.1);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', baseColor);
                circle.setAttribute('stroke-width', '3');
                circle.style.animation = 'thunderRipple 0.8s forwards';
                circle.style.transformOrigin = `${centerX}px ${centerY}px`;
                circle.style.filter = `drop-shadow(0 0 5px ${baseColor})`;
        
                ripple.appendChild(circle);
                combatContainer.appendChild(ripple);
        
                setTimeout(() => {
                    if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
                }, 1000);
            }, 800);

            // ÂàõÂª∫‰∏≠ÂøÉÁàÜÂèëÂÖâÂúàÊïàÊûú
            setTimeout(() => {
                // ‰∏≠ÂøÉÁàÜÂèëÂÖâÂúà
                const burstEffect = document.createElement('div');
                burstEffect.style.position = 'absolute';
                burstEffect.style.left = `${centerX}px`;
                burstEffect.style.top = `${centerY}px`;
                burstEffect.style.width = `${containerRect.width * 0.35}px`; // Á®çÂæÆÂáèÂ∞èÁàÜÂèëËåÉÂõ¥
                burstEffect.style.height = `${containerRect.width * 0.35}px`;
                burstEffect.style.borderRadius = '50%';
                burstEffect.style.background = `radial-gradient(circle, ${highlightColor} 0%, ${hexToRgba(baseColor, 0.5)} 40%, transparent 70%)`;
                burstEffect.style.boxShadow = `0 0 60px ${baseColor}`; // ÂáèÂ∞ëÈò¥ÂΩ±Â±ÇÁ∫ß
                burstEffect.style.zIndex = '20';
                burstEffect.style.transform = 'translate(-50%, -50%) scale(0.1)';
                burstEffect.style.animation = 'thunderPulse 0.8s forwards';
                burstEffect.style.opacity = '0.9';
                combatContainer.appendChild(burstEffect);

                setTimeout(() => {
                    if (burstEffect.parentNode) burstEffect.parentNode.removeChild(burstEffect);
                }, 800);
        
                // ‰ºòÂåñÁÇπ4: ÂáèÂ∞ëÊï£Â∞ÑÊïàÊûú - ‰ªé12Êù°ÂáèÂ∞ëÂà∞6Êù°
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60); // Êîπ‰∏∫ÊØè60Â∫¶‰∏ÄÊù°
                    setTimeout(() => {
                        const scatter = document.createElement('div');
                        scatter.style.position = 'absolute';
                        scatter.style.left = `${centerX}px`;
                        scatter.style.top = `${centerY}px`;
                        scatter.style.width = '4px';
                        scatter.style.height = `${30 + Math.random() * 20}px`;
                        scatter.style.background = baseColor;
                        scatter.style.boxShadow = `0 0 8px ${baseColor}`; // ÂáèÂ∞ëÈò¥ÂΩ±Âº∫Â∫¶
                        scatter.style.zIndex = '16';
                        scatter.style.transformOrigin = 'center bottom';
                        scatter.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                
                        // ÂàõÂª∫Âä®Áîª
                        const keyframes = `
                            @keyframes scatterAnim${i} {
                                0% { transform: translate(-50%, -100%) rotate(${angle}deg) scaleY(0.1); opacity: 1; }
                                100% { transform: translate(-50%, -100%) rotate(${angle}deg) scaleY(${3 + Math.random() * 2}); opacity: 0; }
                            }
                        `;
                        addCSSIfNeeded(keyframes);
                        scatter.style.animation = `scatterAnim${i} 0.5s forwards`;
                    
                        combatContainer.appendChild(scatter);
                        setTimeout(() => {
                            if (scatter.parentNode) scatter.parentNode.removeChild(scatter);
                        }, 500);
                    }, Math.random() * 150);
                }
            }, 850); // ÂΩìÊâÄÊúâÈó™ÁîµÊ±áËÅöÂà∞‰∏≠ÂøÉÂêé

            // Ê∏ÖÁêÜ‰∏≠ÂøÉÊïàÊûú
            setTimeout(() => {
                if (centerEffect.parentNode) centerEffect.parentNode.removeChild(centerEffect);
            }, 1000);
    
            // ÂàõÂª∫Èó™ÁîµÊïàÊûúÂáΩÊï∞
            function createLightningBolt(angle, delay, index) {
                // ‰ΩøÁî® SVG ÂàõÂª∫Èó™ÁîµË∑ØÂæÑ
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.style.position = 'absolute';
                svg.style.left = '0';
                svg.style.top = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '18';
                svg.setAttribute('viewBox', `0 0 ${containerRect.width} ${containerRect.height}`);

                // ËÆ°ÁÆóËµ∑ÁÇπÂíåÁªàÁÇπ
                const distance = Math.max(containerRect.width, containerRect.height) * 0.8;

                // Ê†πÊçÆËßíÂ∫¶ËÆ°ÁÆóËµ∑ÁÇπÔºà‰ªéËæπÁºòÂºÄÂßãÔºâ
                const startX = centerX + Math.cos(angle * Math.PI / 180) * distance;
                const startY = centerY + Math.sin(angle * Math.PI / 180) * distance;

                // ËÆæÂÆö‰∏ªÈó™ÁîµÁöÑÂÆΩÂ∫¶ - ‰øùÊåÅÈó™ÁîµÁ≤óÁªÜ‰ΩÜÊõ¥È´òÊïà
                const mainWidth = 5 + Math.floor(Math.random() * 3); // 5-7px
        
                // ÁîüÊàêÈó™ÁîµÁöÑË∑ØÂæÑ
                const paths = [];
        
                // ‰∏ªÈó™ÁîµË∑ØÂæÑ
                const mainPath = generateLightningPath(startX, startY, centerX, centerY, 0.3, 5, index);
                const mainLightning = createLightningPathElement(mainPath, baseColor, mainWidth, 0.9, delay);
                paths.push(mainLightning);
        
                // Èó™ÁîµÂÜÖÂèëÂÖâÊïàÊûú
                const innerGlow = createLightningPathElement(mainPath, highlightColor, mainWidth * 0.6, 0.7, delay);
                paths.push(innerGlow);
        
                // ‰ºòÂåñÁÇπ3: ÂáèÂ∞ëÊ®°Á≥äÊïàÊûú - Âè™‰øùÁïô‰∏ÄÂ±ÇÂ§ñÂèëÂÖâÔºåÂáèÂ∞ëÊ®°Á≥äÂçäÂæÑ
                const outerGlow = createLightningPathElement(mainPath, baseColor, mainWidth * 2, 0.3, delay);
                outerGlow.setAttribute('filter', `blur(3px)`); // ÂáèÂ∞ëÊ®°Á≥äÂçäÂæÑ
                paths.push(outerGlow);
        
                // ‰ºòÂåñÁÇπ2: ÂáèÂ∞ëÂàÜÊîØÈó™Áîµ - ÊéßÂà∂Âú®0-1‰∏™ÂàÜÊîØ
                const branchCount = Math.floor(Math.random() * 2); // 0Êàñ1‰∏™ÂàÜÊîØ
            
                for (let i = 0; i < branchCount; i++) {
                    const segmentIndex = Math.floor(Math.random() * 3) + 1;
                    const segmentRatio = (segmentIndex / 5) + Math.random() * 0.15;
            
                    const branchStartX = startX * (1 - segmentRatio) + centerX * segmentRatio;
                    const branchStartY = startY * (1 - segmentRatio) + centerY * segmentRatio;
            
                    // ÈöèÊú∫ÂàÜÊîØËßíÂ∫¶ÂÅèÁßª
                    const branchAngleOffset = (Math.random() * 60 - 30);
                    const branchAngle = angle + branchAngleOffset;
            
                    // ËÆ°ÁÆóÂàÜÊîØÁªàÁÇπ - Áº©Áü≠ÂàÜÊîØÈïøÂ∫¶
                    const branchLength = distance * (1 - segmentRatio) * (0.3 + Math.random() * 0.2);
                    const branchEndX = branchStartX - Math.cos(branchAngle * Math.PI / 180) * branchLength;
                    const branchEndY = branchStartY - Math.sin(branchAngle * Math.PI / 180) * branchLength;
            
                    // ÁîüÊàêÂàÜÊîØË∑ØÂæÑ
                    const branchPath = generateLightningPath(
                        branchStartX, branchStartY, branchEndX, branchEndY, 
                        0.4, 2, index + i + 10 // ÂáèÂ∞ëÂàÜÊîØÊÆµÊï∞
                    );
            
                    // ÂàÜÊîØÂÆΩÂ∫¶ËæÉ‰∏ªÈó™ÁîµÁªÜ
                    const branchWidth = mainWidth * 0.5;
            
                    // ÂàõÂª∫ÂàÜÊîØÂèäÂÖ∂ÂèëÂÖâÊïàÊûú
                    const branch = createLightningPathElement(branchPath, baseColor, branchWidth, 0.8, delay + 100);
                    paths.push(branch);
            
                    // ‰ºòÂåñÁÇπ3: ÂàÜÊîØ‰∏çÂä†Ê®°Á≥äÊïàÊûú
                }
        
                // Â∞ÜÊâÄÊúâË∑ØÂæÑÊ∑ªÂä†Âà∞SVG
                paths.forEach(path => svg.appendChild(path));

                // Ê∑ªÂä†Âà∞ÂÆπÂô®
                combatContainer.appendChild(svg);

                // ÂÆöÊó∂Ê∏ÖÁêÜ
                setTimeout(() => {
                    if (svg.parentNode) svg.parentNode.removeChild(svg);
                }, delay + 1000); // Áº©Áü≠Ê∏ÖÁêÜÊó∂Èó¥
            }
    
            // ÂàõÂª∫Èó™ÁîµË∑ØÂæÑÂÖÉÁ¥†
            function createLightningPathElement(pathData, color, width, opacity, delay) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', width);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', opacity);
        
                // ÁÆÄÂåñÂèëÂÖâÊïàÊûú
                path.setAttribute('filter', `drop-shadow(0 0 2px ${color})`);
        
                // Ê∑ªÂä†Èó™ÁîµÂä®Áîª
                path.style.strokeDasharray = 2000;
                path.style.strokeDashoffset = 2000;
                path.style.animation = `thunderBolt 0.8s ${delay}ms forwards`; // Áº©Áü≠Âä®ÁîªÊó∂Èó¥
        
                return path;
            }
    
            // ÁîüÊàêÈó™ÁîµË∑ØÂæÑÊï∞ÊçÆ - ‰ΩøÁî®Êõ¥ÁÆÄÂçïÁöÑÁÆóÊ≥ï
            function generateLightningPath(startX, startY, endX, endY, displacementFactor, segments, seed) {
                let pathData = `M${startX},${startY} `;
        
                // ÁÆÄÂåñËÆ°ÁÆó
                const dx = (endX - startX) / segments;
                const dy = (endY - startY) / segments;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
        
                // ‰ΩøÁî®ÁÆÄÂåñÁöÑ‰º™ÈöèÊú∫ÂáΩÊï∞
                const seededRandom = function(min, max) {
                 const x = Math.sin(seed * 9999 + arguments.callee.count++) * 10000;
                    return (x - Math.floor(x)) * (max - min) + min;
                };
        seededRandom.count = 0;
        
        let currentX = startX;
        let currentY = startY;

        for (let i = 1; i <= segments; i++) {
            // ÂêëÁªàÁÇπÁßªÂä®‰∏ÄÊÆµ
            const ratio = i / segments;
            const targetX = startX + dx * i;
            const targetY = startY + dy * i;
    
            // Ê∑ªÂä†ÈöèÊú∫ÂÅèÁßªÔºàÈô§‰∫ÜÊúÄÂêé‰∏ÄÊÆµÁõ¥Êé•ËøûÂà∞‰∏≠ÂøÉÔºâ
            if (i < segments) {
                // ÈöèÁùÄÊé•ËøëÁªàÁÇπÂáèÂ∞èÂÅèÁßª
                const maxDeviation = segmentLength * displacementFactor * (1 - ratio * 0.5);
                
                // Ê∑ªÂä†ÈöèÊú∫ÂÅèÁßª
                const perpAngle = Math.atan2(endY - startY, endX - startX) + Math.PI / 2;
                const randomDeviation = seededRandom(-1, 1) * maxDeviation;
                const deviationX = Math.cos(perpAngle) * randomDeviation;
                const deviationY = Math.sin(perpAngle) * randomDeviation;
        
                currentX = targetX + deviationX;
                currentY = targetY + deviationY;
            } else {
                // ÊúÄÂêé‰∏ÄÊÆµÁõ¥Êé•ËøûÂà∞‰∏≠ÂøÉ
                currentX = endX;
                currentY = endY;
            }
            
            pathData += `L${currentX},${currentY} `;
        }
        
        return pathData;
    }
}
        
        function createScatterShotEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS
            addCSSIfNeeded(`
                @keyframes scatterShot {
                    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0.8; }
                    50% { opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }

                @keyframes scatterParticle {
                    0% { transform: translate(0, 0) scale(1); opacity: 1; }
                    100% { transform: translate(var(--tx), var(--ty)) scale(0.3); opacity: 0; }
                }
            `);

            // ÂàõÂª∫‰∏≠ÂøÉÁàÜÁ†¥ÊïàÊûú
            const centerBlast = document.createElement('div');
            centerBlast.style.position = 'absolute';
            centerBlast.style.left = `${combatMode.mouseX}px`;
            centerBlast.style.top = `${combatMode.mouseY}px`;
            centerBlast.style.width = `${containerRect.width * 0.1}px`; // ÂÆΩÂ∫¶‰∏∫ÂÆπÂô®ÂÆΩÂ∫¶ÁöÑ10%
            centerBlast.style.height = `${containerRect.width * 0.1}px`;
            centerBlast.style.borderRadius = '50%';
            centerBlast.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, ${hexToRgba(weaponColor, 0.1)} 70%, transparent 100%)`;
            centerBlast.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
            centerBlast.style.zIndex = '18';
            centerBlast.style.animation = 'scatterShot 0.6s forwards';
            centerBlast.style.transform = 'translate(-50%, -50%) scale(0.2)';
            combatContainer.appendChild(centerBlast);

            // ÂàõÂª∫Êï£Â∞ÑÁ≤íÂ≠ê
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) + (Math.random() * 20 - 10); // Â∞Ü360Â∫¶ÂàÜÊàê12‰ªΩ
                const radian = (angle * Math.PI) / 180;
                const distance = containerRect.width * (0.2 + Math.random() * 0.3); // 20%-50%ÁöÑÂÆπÂô®ÂÆΩÂ∫¶

                const tx = Math.cos(radian) * distance;
                const ty = Math.sin(radian) * distance;

                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.left = `${combatMode.mouseX}px`;
                particle.style.top = `${combatMode.mouseY}px`;
                particle.style.width = `${8 + Math.random() * 7}px`; // 8-15px
                particle.style.height = `${8 + Math.random() * 7}px`;
                particle.style.borderRadius = '50%';
                particle.style.background = `${hexToRgba(weaponColor, 0.9)}`;
                particle.style.boxShadow = `0 0 10px ${weaponColor}`;
                particle.style.zIndex = '17';

                // ‰ΩøÁî®CSSÂèòÈáè‰º†ÈÄí‰∏çÂêåÁöÑÁßªÂä®‰ΩçÁΩÆ
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                particle.style.animation = 'scatterParticle 0.7s forwards';

                combatContainer.appendChild(particle);

                // Ê∏ÖÁêÜÁ≤íÂ≠ê
                setTimeout(() => {
                    if (particle.parentNode) particle.parentNode.removeChild(particle);
                }, 700);
            }

            // Ê∏ÖÁêÜ‰∏≠ÂøÉÁàÜÁ†¥
            setTimeout(() => {
                if (centerBlast.parentNode) centerBlast.parentNode.removeChild(centerBlast);
            }, 600);
        }

        function createPowerBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS
            addCSSIfNeeded(`
                @keyframes powerBeam {
                    0% { transform: scaleX(0); opacity: 0.3; }
                    10% { transform: scaleX(0.1); opacity: 1; }
                    20% { transform: scaleX(1); }
                    80% { opacity: 1; width: ${containerRect.width * 1.2}px; }
                    100% { opacity: 0; width: ${containerRect.width * 1.2}px; }
                }

                @keyframes powerBeamCharge {
                    0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0.5; }
                    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
                    90% { transform: translate(-50%, -50%) scale(0.1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                }
            `);

            // È¶ñÂÖàÂàõÂª∫ÂÖÖËÉΩÊïàÊûú
            const chargeEffect = document.createElement('div');
            chargeEffect.style.position = 'absolute';
            chargeEffect.style.left = `${combatMode.mouseX}px`;
            chargeEffect.style.top = `${combatMode.mouseY}px`;
            chargeEffect.style.width = `${containerRect.width * 0.08}px`; // ÂÆΩÂ∫¶‰∏∫ÂÆπÂô®ÂÆΩÂ∫¶ÁöÑ8%
            chargeEffect.style.height = `${containerRect.width * 0.08}px`;
            chargeEffect.style.borderRadius = '50%';
            chargeEffect.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.8)} 30%, transparent 70%)`;
            chargeEffect.style.boxShadow = `0 0 30px ${weaponColor}`;
            chargeEffect.style.zIndex = '16';
            chargeEffect.style.animation = 'powerBeamCharge 0.4s forwards';
            chargeEffect.style.transform = 'translate(-50%, -50%) scale(0.3)';
            combatContainer.appendChild(chargeEffect);

            // ÁÑ∂ÂêéÂú®ÂÖÖËÉΩÊïàÊûúÁªìÊùüÂêéÂàõÂª∫‰∏ªÂ∞ÑÁ∫ø
            setTimeout(() => {
                // ÂàõÂª∫‰∏ªÂ∞ÑÁ∫ø
                const beam = document.createElement('div');
                beam.style.position = 'absolute';
                beam.style.left = `${combatMode.mouseX}px`;
                beam.style.top = `${combatMode.mouseY}px`;
                beam.style.width = '0'; // ÂàùÂßãÂÆΩÂ∫¶‰∏∫0ÔºåÂä®Áîª‰∏≠‰ºöÊâ©Â±ï
                beam.style.height = `${containerRect.width * 0.15}px`; // È´òÂ∫¶‰∏∫ÂÆπÂô®ÂÆΩÂ∫¶ÁöÑ15%
                beam.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 1)}, ${hexToRgba(weaponColor, 0.7)})`;
                beam.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
                beam.style.zIndex = '17';
                beam.style.transformOrigin = 'left center';
                beam.style.animation = 'powerBeam 0.6s forwards';

                combatContainer.appendChild(beam);

                // Ê∑ªÂä†Â∞ÑÁ∫øÂÜÖÈÉ®ÂÖâÊïà
                const beamGlow = document.createElement('div');
                beamGlow.style.position = 'absolute';
                beamGlow.style.left = `${combatMode.mouseX}px`;
                beamGlow.style.top = `${combatMode.mouseY}px`;
                beamGlow.style.width = '0'; // ‰∏é‰∏ªÂ∞ÑÁ∫øÂêåÊ≠•
                beamGlow.style.height = `${containerRect.width * 0.08}px`; // Áï•Á™Ñ‰∫é‰∏ªÂ∞ÑÁ∫ø
                beamGlow.style.background = `linear-gradient(90deg, white, ${hexToRgba(weaponColor, 0.8)} 30%, ${hexToRgba(weaponColor, 0.5)} 70%)`;
                beamGlow.style.filter = 'blur(3px)';
                beamGlow.style.zIndex = '16';
                beamGlow.style.transformOrigin = 'left center';
                beamGlow.style.animation = 'powerBeam 0.6s forwards';

                combatContainer.appendChild(beamGlow);

                // Ê∏ÖÁêÜÂ∞ÑÁ∫ø
                setTimeout(() => {
                    if (beam.parentNode) beam.parentNode.removeChild(beam);
                    if (beamGlow.parentNode) beamGlow.parentNode.removeChild(beamGlow);
                }, 600);
            }, 300); // Âú®ÂÖÖËÉΩÊïàÊûúÂêéÊòæÁ§∫Â∞ÑÁ∫ø

            // Ê∏ÖÁêÜÂÖÖËÉΩÊïàÊûú
            setTimeout(() => {
                if (chargeEffect.parentNode) chargeEffect.parentNode.removeChild(chargeEffect);
            }, 400);
        }

        function createGetterBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();
            const centerX = combatMode.mouseX;
            const centerY = combatMode.mouseY;

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS
            addCSSIfNeeded(`
                @keyframes getterScanLine {
                    0% { opacity: 0.8; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `);

            // Ê∞¥Âπ≥ÈïøÊñπÂΩ¢ÂáÜÊòüÁöÑÂèÇÊï∞ËÆ°ÁÆó
            const outerSize = combatMode.crosshairSize * 0.8; // Â§ñÊ°ÜÂ§ßÂ∞è‰∏∫ÂÆπÂô®Â§ßÂ∞èÁöÑ80%
            const frameHeight = Math.round(outerSize * 0.4); // ËæÉÁü≠ÁöÑÈ´òÂ∫¶
            const frameWidth = frameHeight * 6; // ÂÆΩÂ∫¶ÊòØÈ´òÂ∫¶ÁöÑ6ÂÄç
    
            // È¢ÑÂÖàËÆ°ÁÆóÊâ´ÊèèÁ∫øÊï∞ÈáèÂíåÊó∂Èó¥ÂèÇÊï∞
            const scanCount = 7; // ÂàõÂª∫7Êù°Êâ´ÊèèÁ∫ø
            const scanDuration = 100; // ÊØèÊù°Á∫øÁöÑÊåÅÁª≠Êó∂Èó¥(ÊØ´Áßí)
            const scanDelay = 50; // Á∫ø‰πãÈó¥ÁöÑÂª∂Ëøü(ÊØ´Áßí)
    
            // Êí≠ÊîæÂÖâÊùüÈü≥Êïà
            playCombatSound(beamGunSound);
    
            // ÂàõÂª∫Êâ´ÊèèÁ∫øÂä®Áîª
            for (let i = 0; i < scanCount; i++) {
                setTimeout(() => {
                    // Âú®ÈïøÊñπÂΩ¢ÂÜÖÈöèÊú∫È´òÂ∫¶ÂàõÂª∫Êâ´ÊèèÁ∫ø
                    const randomOffset = (Math.random() - 0.5) * frameHeight;
                    const scanY = centerY + randomOffset;
            
                    // ÂàõÂª∫Êâ´ÊèèÁ∫ø
                    const scanLine = document.createElement('div');
                    scanLine.style.position = 'absolute';
                    scanLine.style.height = '5px'; // Âä†Á≤óÊâ´ÊèèÁ∫ø
                    scanLine.style.width = `${frameWidth}px`;
                    scanLine.style.left = `${centerX - frameWidth/2}px`;
                    scanLine.style.top = `${scanY}px`;
                    scanLine.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 0.3)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.3)} 100%)`;
                    scanLine.style.boxShadow = `0 0 10px ${weaponColor}, 0 0 20px ${weaponColor}`;
                    scanLine.style.zIndex = '9';
                    scanLine.style.animation = 'getterScanLine 0.3s forwards';
            
                    // Ê∑ªÂä†Âà∞ÂÆπÂô®
                    combatContainer.appendChild(scanLine);
            
                    // Ê∏ÖÁêÜÊâ´ÊèèÁ∫ø
                    setTimeout(() => {
                        if (scanLine.parentNode) scanLine.parentNode.removeChild(scanLine);
                    }, 300);
                }, i * scanDelay);
            }
    
            // Âª∂ËøüÊ£ÄÊü•ÂëΩ‰∏≠ - Âú®ÊúÄÂêé‰∏ÄÊù°Êâ´ÊèèÁ∫øÂêé
            setTimeout(() => {
                checkHit();
            }, scanCount * scanDelay + 150);
        }
            
        function createSpiralBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS
            addCSSIfNeeded(`
                @keyframes spiralWave {
                    0% { transform: translate(-50%, -50%) scale(0.3) rotate(0deg); opacity: 0.7; }
                    100% { transform: translate(-50%, -50%) scale(2) rotate(720deg); opacity: 0; }
                }

                @keyframes spiralBeam {
                    0% { transform: rotate(var(--startAngle)) translateX(10px); opacity: 0.2; width: 0; }
                    20% { opacity: 1; }
                    100% { transform: rotate(var(--endAngle)) translateX(var(--distance)); opacity: 0; width: ${containerRect.width * 0.6}px; }
                }
            `);

            // ÂàõÂª∫‰∏≠ÂøÉËû∫ÊóãÊïàÊûú
            const spiral = document.createElement('div');
            spiral.style.position = 'absolute';
            spiral.style.left = `${combatMode.mouseX}px`;
            spiral.style.top = `${combatMode.mouseY}px`;
            spiral.style.width = `${containerRect.width * 0.2}px`; // ÂÆΩÂ∫¶‰∏∫ÂÆπÂô®ÂÆΩÂ∫¶ÁöÑ20%
            spiral.style.height = `${containerRect.width * 0.2}px`;
            spiral.style.background = `conic-gradient(from 0deg,
                                        ${hexToRgba(weaponColor, 0)} 0%,
                                        ${hexToRgba(weaponColor, 0.8)} 25%,
                                        ${hexToRgba(weaponColor, 1)} 50%,
                                        ${hexToRgba(weaponColor, 0.8)} 75%,
                                        ${hexToRgba(weaponColor, 0)} 100%)`;
            spiral.style.borderRadius = '50%';
            spiral.style.zIndex = '16';
            spiral.style.transform = 'translate(-50%, -50%) scale(0.3)';
            spiral.style.animation = 'spiralWave 1s forwards';
            spiral.style.boxShadow = `0 0 30px ${weaponColor}`;
            combatContainer.appendChild(spiral);

            // ÂàõÂª∫ÂèëÊï£ÁöÑËÉΩÈáèÊùü
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const startAngle = i * 60; // Âπ≥ÂùáÂàÜÂ∏ÉÂú®360Â∫¶
                    const endAngle = startAngle + (Math.random() * 120 + 180); // ÊóãËΩ¨180-300Â∫¶
                    const distance = containerRect.width * (0.4 + Math.random() * 0.3); // 40%-70%ÁöÑÂÆπÂô®ÂÆΩÂ∫¶

                    const beam = document.createElement('div');
                    beam.style.position = 'absolute';
                    beam.style.left = `${combatMode.mouseX}px`;
                    beam.style.top = `${combatMode.mouseY}px`;
                    beam.style.height = `${4 + Math.random() * 4}px`; // 4-8pxÈ´ò
                    beam.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 1)}, ${hexToRgba(weaponColor, 0.7)} 70%, transparent)`;
                    beam.style.boxShadow = `0 0 10px ${weaponColor}`;
                    beam.style.transformOrigin = 'left center';
                    beam.style.zIndex = '15';

                    // ‰ΩøÁî®CSSÂèòÈáè‰º†ÈÄí‰∏çÂêåÁöÑËßíÂ∫¶ÂíåË∑ùÁ¶ª
                    beam.style.setProperty('--startAngle', `${startAngle}deg`);
                    beam.style.setProperty('--endAngle', `${endAngle}deg`);
                    beam.style.setProperty('--distance', `${distance}px`);
                    beam.style.animation = 'spiralBeam 0.8s forwards';

                    combatContainer.appendChild(beam);

                    // Ê∏ÖÁêÜËÉΩÈáèÊùü
                    setTimeout(() => {
                        if (beam.parentNode) beam.parentNode.removeChild(beam);
                    }, 800);
                }, i * 100); // ÈîôÂºÄÂèëÂ∞ÑÊó∂Èó¥
            }

            // Ê∏ÖÁêÜËû∫ÊóãÊïàÊûú
            setTimeout(() => {
                if (spiral.parentNode) spiral.parentNode.removeChild(spiral);
            }, 1000);
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÂä®ÊÄÅÊ∑ªÂä†CSS
        function addCSSIfNeeded(cssText) {
            // ‰∏∫ÊØèÊ¨°Ê∑ªÂä†ÁöÑCSSÂàõÂª∫ÂîØ‰∏ÄID
            const cssId = 'custom-effect-css-' + Math.random().toString(36).substr(2, 9);

            // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÁöÑCSS
            if (!document.getElementById(cssId)) {
                const head = document.head || document.getElementsByTagName('head')[0];
                const style = document.createElement('style');
                style.id = cssId;
                style.type = 'text/css';

                if (style.styleSheet) {
                    // IE8 Âèä‰ª•‰∏ã
                    style.styleSheet.cssText = cssText;
                } else {
                    // Áé∞‰ª£ÊµèËßàÂô®
                    style.appendChild(document.createTextNode(cssText));
                }

                head.appendChild(style);
            }
        }

        // Ê£ÄÊü•ÊòØÂê¶ÂëΩ‰∏≠
        function checkHit() {
            const containerRect = combatContainer.getBoundingClientRect();

            // ËÆ°ÁÆóÈò≤ÂÆàËÄÖ‰∏≠ÂøÉ‰ΩçÁΩÆ
            const defenderCenterX = combatMode.defenderX;
            const defenderCenterY = combatMode.defenderY;

            // ËÆ°ÁÆóÂáÜÊòü‰∏≠ÂøÉ‰ΩçÁΩÆ
            const crosshairCenterX = combatMode.mouseX;
            const crosshairCenterY = combatMode.mouseY;

            // ËÆ°ÁÆóÈò≤ÂÆàËÄÖÂ§ßÂ∞èÂíåÂáÜÊòüÂ§ßÂ∞è
            const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);
            const defenderRadius = defenderSize / 2;
            const crosshairRadius = combatMode.crosshairSize / 2;

            // ‰ΩøÁî®ÂΩìÂâçÂáÜÊòüÂΩ¢Áä∂ÔºàÈªòËÆ§ÊòØÂúÜÂΩ¢Ôºâ
            const crosshairType = combatMode.attacker.crosshairType || 'Beam_Rifie';

            // Ê†πÊçÆÂáÜÊòüÁ±ªÂûãÂàõÂª∫‰∏çÂêåÁöÑÁ¢∞ÊíûÂΩ¢Áä∂
            let hitDetected = false;

            if (crosshairType === 'Beam_Rifie' || !crosshairType) {
                // ‰ΩøÁî®ÁÆÄÂçïÁöÑÂúÜÂΩ¢Á¢∞ÊíûÊ£ÄÊµãÔºàÂéüÊúâÁöÑÊñπÊ≥ïÔºâ
                const dx = crosshairCenterX - defenderCenterX;
                const dy = crosshairCenterY - defenderCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                hitDetected = distance < (defenderRadius + crosshairRadius);
            } else {
                // ‰ΩøÁî®Â§öËæπÂΩ¢Á¢∞ÊíûÊ£ÄÊµã
                let crosshairPoints;
                let defenderPoints;

                // ÂàõÂª∫Èò≤ÂÆàËÄÖÁöÑÁ¢∞ÊíûÂΩ¢Áä∂ÔºàÈÄöÂ∏∏ÊòØÂúÜÂΩ¢Ôºâ
                defenderPoints = createRegularPolygon(8, defenderRadius); // Áî®8ËæπÂΩ¢Ëøë‰ººÂúÜÂΩ¢

                // Ê†πÊçÆÂáÜÊòüÁ±ªÂûãÂàõÂª∫‰∏çÂêåÂΩ¢Áä∂
                switch (crosshairType) {
                    case 'Beam_Saber':
                        // ÂàõÂª∫Ê≠£ÊñπÂΩ¢ÂáÜÊòü
                        const halfSize = crosshairRadius * 0.8; // Á®çÂæÆÁº©Â∞è‰ª•ÂåπÈÖçËßÜËßâÂ§ßÂ∞è
                        crosshairPoints = [
                            {x: -halfSize, y: -halfSize},
                            {x: halfSize, y: -halfSize},
                            {x: halfSize, y: halfSize},
                            {x: -halfSize, y: halfSize}
                        ];
                        break;

                    case 'Cosmo_Nova':
                        // ÂàõÂª∫Ëè±ÂΩ¢ÂáÜÊòü
                        const Cosmo_NovaSize = crosshairRadius * 1.2;
                        crosshairPoints = [
                            {x: 0, y: -Cosmo_NovaSize},
                            {x: Cosmo_NovaSize, y: 0},
                            {x: 0, y: Cosmo_NovaSize},
                            {x: -Cosmo_NovaSize, y: 0}
                        ];
                        break;

                    case 'Destructive_Thunder':
                        // ‰ΩøÁî®‰∏é Beam_Saber Áõ∏ÂêåÁöÑÊñπÂΩ¢Á¢∞ÊíûÊ£ÄÊµãÔºå‰ΩÜ‰ΩøÁî®‰∏çÂêåÁöÑÂèòÈáèÂêç
                        const thunderSize = crosshairRadius * 0.8; // Á®çÂæÆÁº©Â∞è‰ª•ÂåπÈÖçËßÜËßâÂ§ßÂ∞è
                        crosshairPoints = [
                            {x: -thunderSize, y: -thunderSize},
                            {x: thunderSize, y: -thunderSize},
                            {x: thunderSize, y: thunderSize},
                            {x: -thunderSize, y: thunderSize}
                        ];
                        break;

                    // Ê∑ªÂä†Getter_BeamÂΩ¢Áä∂
                    case 'Getter_Beam':
                        // Ê∞¥Âπ≥ÈïøÊñπÂΩ¢ÂáÜÊòüÔºåÂÆΩ:È´ò = 6:1
                        const getterBeamHeight = crosshairRadius * 0.4; // È´òÂ∫¶ËæÉÂ∞è
                        const getterBeamWidth = getterBeamHeight * 6; // ÂÆΩÂ∫¶ÊòØÈ´òÂ∫¶ÁöÑ6ÂÄç
                        crosshairPoints = [
                            {x: -getterBeamWidth/2, y: -getterBeamHeight/2},
                            {x: getterBeamWidth/2, y: -getterBeamHeight/2},
                            {x: getterBeamWidth/2, y: getterBeamHeight/2},
                            {x: -getterBeamWidth/2, y: getterBeamHeight/2}
                        ];
                        break;
                        
                    case 'diamond':
                        // ÂàõÂª∫Ëè±ÂΩ¢ÂáÜÊòü
                        const diamondSize = crosshairRadius * 1.2;
                        crosshairPoints = [
                            {x: 0, y: -diamondSize},
                            {x: diamondSize, y: 0},
                            {x: 0, y: diamondSize},
                            {x: -diamondSize, y: 0}
                        ];
                        break;

                    case 'triangle':
                        // ÂàõÂª∫‰∏âËßíÂΩ¢ÂáÜÊòü
                        const triangleSize = crosshairRadius * 1.3;
                        crosshairPoints = [
                            {x: 0, y: -triangleSize},
                            {x: triangleSize * 0.866, y: triangleSize * 0.5}, // cos(30¬∞), sin(30¬∞)
                            {x: -triangleSize * 0.866, y: triangleSize * 0.5}
                        ];
                        break;

                    default:
                        // ÈªòËÆ§‰ΩøÁî®ÂúÜÂΩ¢ÔºàÁî®16ËæπÂΩ¢Ëøë‰ººÔºâ
                        crosshairPoints = createRegularPolygon(16, crosshairRadius);
                }

                // ÂàõÂª∫Â§öËæπÂΩ¢ÂØπË±°
                const crosshairPolygon = createPolygon(crosshairPoints, crosshairCenterX, crosshairCenterY, 0);
                const defenderPolygon = createPolygon(defenderPoints, defenderCenterX, defenderCenterY, 0);

                // Ê£ÄÊµãÁ¢∞Êíû
                hitDetected = polygonsCollide(crosshairPolygon, defenderPolygon);
            }

            // Â¶ÇÊûúÂëΩ‰∏≠ÔºåÂàõÂª∫ÁàÜÁÇ∏ÊïàÊûú
            if (hitDetected) {
                createExplosion(defenderCenterX, defenderCenterY);
                endCombat('attacker');
                return true;
            }

            return false;
        }

        // ÂâµÂª∫ÁàÜÁÇ∏ÊïàÊûú - ÁôæÂàÜÊØîÊñπÂºèÔºÅ
        function createExplosion(x, y) {
            // Êí≠ÊîæÁàÜÁÇ∏Èü≥Êïà
            playCombatSound(explosionSound);

            // ‰∏ªÁàÜÁÇ∏
            const explosion = document.createElement('div');
            explosion.className = 'explosion';

            // ‰ΩøÁî®ÁôæÂàÜÊØîÂÆö‰Ωç
            const containerRect = combatContainer.getBoundingClientRect();
            const xPercent = (x / containerRect.width) * 100;
            const yPercent = (y / containerRect.height) * 100;

            explosion.style.left = `${xPercent}%`;
            explosion.style.top = `${yPercent}%`;
            combatContainer.appendChild(explosion);

            // Create spark particles - MORE AND PRETTIER
            for (let i = 0; i < 40; i++) { // Doubled from 20 to 40 particles
                const spark = document.createElement('div');
                spark.className = 'spark';

                // Random position around explosion center
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 70 + 30; // Increased distance
                const sparkX = x + Math.cos(angle) * distance;
                const sparkY = y + Math.sin(angle) * distance;

                spark.style.left = `${sparkX}px`;
                spark.style.top = `${sparkY}px`;

                // Enhanced color palette
                const colors = [
                    '#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB', '#FFFFFF',
                    '#FF00FF', '#DA70D6', '#EE82EE', '#FF77FF', '#FFD700'
                ];
                const color = colors[Math.floor(Math.random() * colors.length)];
                spark.style.backgroundColor = color;
                spark.style.color = color; // For box-shadow glow

                // Animation
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkSpeed = Math.random() * 150 + 100; // Faster particles
                const sparkDuration = Math.random() * 600 + 600; // Longer duration

                combatContainer.appendChild(spark);

                // Animate the spark
                let startTime = null;
                function animateSpark(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = (timestamp - startTime) / sparkDuration;

                    if (progress < 1) {
                        const moveX = Math.cos(sparkAngle) * sparkSpeed * progress;
                        const moveY = Math.sin(sparkAngle) * sparkSpeed * progress;

                        spark.style.left = `${sparkX + moveX}px`;
                        spark.style.top = `${sparkY + moveY}px`;
                        spark.style.opacity = 1 - progress;

                        requestAnimationFrame(animateSpark);
                    } else {
                        if (spark.parentNode) {
                            spark.parentNode.removeChild(spark);
                        }
                    }
                }

                requestAnimationFrame(animateSpark);
            }

            // Secondary explosions for more spectacular effect
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const secondaryExplosion = document.createElement('div');
                    secondaryExplosion.className = 'explosion';
                    // Position secondary explosions slightly offset from main explosion
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = (Math.random() - 0.5) * 60;
                    secondaryExplosion.style.left = `${x + offsetX}px`;
                    secondaryExplosion.style.top = `${y + offsetY}px`;
                    // Make secondary explosions smaller
                    secondaryExplosion.style.transform = 'translate(-50%, -50%) scale(0.7)';
                    combatContainer.appendChild(secondaryExplosion);

                    // Remove secondary explosion after animation
                    setTimeout(() => {
                        if (secondaryExplosion.parentNode) {
                            secondaryExplosion.parentNode.removeChild(secondaryExplosion);
                        }
                    }, 600);
                }, i * 200); // Stagger the secondary explosions
            }

            // Remove explosion after animation
            setTimeout(() => {
                if (explosion.parentNode) {
                    explosion.parentNode.removeChild(explosion);
                }
            }, 600);
        }

        // Update combat state
        function updateCombat(timestamp) {
            if (!combatMode.active) return;

            // First frame initialization
            if (!combatMode.lastFrameTime) {
                combatMode.lastFrameTime = timestamp;
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
                return;
            }

            const deltaTime = timestamp - combatMode.lastFrameTime;
            combatMode.lastFrameTime = timestamp;

            // Update timer
            if (!combatMode.result && !combatMode.bulletFired) {
                combatMode.timeRemaining -= deltaTime;
                combatMode.timer = Math.max(0, Math.ceil(combatMode.timeRemaining / 1000));
                combatTimer.textContent = combatMode.timer;

                // Check if time's up
                if (combatMode.timeRemaining <= 0) {
                    // Defender wins if time runs out
                    endCombat('defender');
                }
            }

            // Update defender position
            // Êõ¥Êñ∞Èò≤ÂÆàËÄÖ‰ΩçÁΩÆ
            if (combatMode.defenderMoving && !combatMode.result) {
                // ËÆ°ÁÆóÂ∑≤ÁªèËøáÁöÑÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ
                const elapsedTime = Date.now() - combatMode.moveStartTime;

                // ËÆ°ÁÆóÁßªÂä®ÊñπÂêëÂêëÈáè
                const dx = combatMode.defenderTargetX - combatMode.moveStartX;
                const dy = combatMode.defenderTargetY - combatMode.moveStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) { // Â¶ÇÊûúË∑ùÁõÆÊ†áËøòÊúâ‰∏ÄÊÆµË∑ùÁ¶ª
                    // Â∞ÜÈÄüÂ∫¶‰ªéÂÉèÁ¥†/Â∏ßËΩ¨Êç¢‰∏∫ÂÉèÁ¥†/Áßí
                    const speedPerSecond = combatMode.defenderSpeed * 60; // ÂÅáËÆæ60FPS‰Ωú‰∏∫Âü∫ÂáÜ

                    // ËÆ°ÁÆóËøôÊÆµÊó∂Èó¥ÂÜÖÂ∫îËØ•ÁßªÂä®ÁöÑË∑ùÁ¶ªÊØî‰æãÔºà0Âà∞1‰πãÈó¥Ôºâ
                    // 200msÊòØÊúÄÂ§ßÁßªÂä®Êó∂Èó¥Ôºå‰ΩÜÂèØËÉΩÊèêÂâçÂà∞ËææÁõÆÊ†á
                    const moveRatio = Math.min(elapsedTime / 200, 1.0);

                    // ËÆ°ÁÆóÊØî‰æãË∑ùÁ¶ªÁßªÂä®
                    const moveDistance = Math.min(speedPerSecond * (elapsedTime / 1000), distance);
                    const moveRatio2 = moveDistance / distance;

                    // ‰ΩøÁî®Âπ≥ÊªëÁöÑÂü∫‰∫éÊó∂Èó¥ÁöÑÊèíÂÄº
                    combatMode.defenderX = combatMode.moveStartX + dx * moveRatio2;
                    combatMode.defenderY = combatMode.moveStartY + dy * moveRatio2;

                    // Á°Æ‰øùÈò≤ÂÆàËÄÖ‰∏ç‰ºöÁ¶ªÂºÄÂÆπÂô®ËæπÁïå
                    const containerRect = combatContainer.getBoundingClientRect();
                    const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);
                    combatMode.defenderX = Math.max(defenderSize / 2,
                                        Math.min(containerRect.width - defenderSize / 2,
                                               combatMode.defenderX));
                    combatMode.defenderY = Math.max(defenderSize / 2,
                                        Math.min(containerRect.height - defenderSize / 2,
                                               combatMode.defenderY));

                    // Êõ¥Êñ∞ËßÜËßâ‰ΩçÁΩÆ
                    defender.style.left = `${combatMode.defenderX}px`;
                    defender.style.top = `${combatMode.defenderY}px`;
                } else {
                    // Âà∞ËææÁõÆÊ†á‰ΩçÁΩÆÔºåÂÅúÊ≠¢ÁßªÂä®
                    combatMode.defenderMoving = false;
                }
            }

            // Continue animation
            if (combatMode.active) {
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
            }
        }

        // AI for defender movement
        function startAIDefender() {
            if (!combatMode.active) return;

            const containerRect = combatContainer.getBoundingClientRect();
            const isTouch = isTouchDevice();

            // Set initial target for AI defender
            combatMode.defenderTargetX = combatMode.defenderX;
            combatMode.defenderTargetY = combatMode.defenderY;

            const chooseEvasiveDirection = () => {
                if (!combatMode.active || combatMode.result || combatMode.defenderMoving) return;

                // Calculate random movement distance based on dodge value
                // Formula: (dodgeÂÄº-2)*5% + 10% ÁöÑÂÆπÂô®ÂØ¨Â∫¶
                // Ëß∏ÊéßË£ùÁΩÆ‰∏äÊ∏õÂ∞ëÁßªÂãïË∑ùÈõ¢Ôºå‰ΩøAIÊõ¥ÂÆπÊòìË¢´ÂëΩ‰∏≠
                const moveDistanceMultiplier = 1.0;
                const moveDistancePercent = ((combatMode.defender.dodge - 2) * 5 + 10) * moveDistanceMultiplier;
                const moveDistance = containerRect.width * (moveDistancePercent / 100);

                // Choose a random direction to move
                const angle = Math.random() * Math.PI * 2;

                // Use the new moveDistance formula instead of random distance
                combatMode.defenderTargetX = containerRect.width / 2 + Math.cos(angle) * moveDistance;
                combatMode.defenderTargetY = containerRect.height / 2 + Math.sin(angle) * moveDistance;

                // Ë®àÁÆóÂØ¶ÈöõÁöÑÈò≤ÂÆàËÄÖÂ∞∫ÂØ∏ (‰ΩøÁî®defenderSizePercentÂØ¶ÊôÇË®àÁÆó)
                const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);

                // Keep within bounds
                combatMode.defenderTargetX = Math.max(defenderSize / 2,
                                                    Math.min(containerRect.width - defenderSize / 2,
                                                            combatMode.defenderTargetX));
                combatMode.defenderTargetY = Math.max(defenderSize / 2,
                                                    Math.min(containerRect.height - defenderSize / 2,
                                                            combatMode.defenderTargetY));

                // Start movement
                startDefenderMovement();
            };

            // Perform evasive movement occasionally
            // Ëß∏ÊéßË£ùÁΩÆ‰∏äÊõ¥ÊÖ¢ÁöÑÈñÉÈÅøÈ†ªÁéá
            const evasionInterval = 800;

            const aiInterval = setInterval(() => {
                if (!combatMode.active) {
                    clearInterval(aiInterval);
                    return;
                }

                chooseEvasiveDirection();
            }, evasionInterval);

            // Initial evasion with longer delay on touch devices
            const initialDelay = 500;
            setTimeout(chooseEvasiveDirection, initialDelay);
        }

        // Ê™¢Ê∏¨ÊòØÂê¶ÁÇ∫Ëß∏ÊéßË£ùÁΩÆ
        function isTouchDevice() {
            return ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0);
        }

        // AI for attacker (aiming and shooting)
        function startAIAttacker() {
            if (!combatMode.active || combatMode.bulletFired) return;

            const containerRect = combatContainer.getBoundingClientRect();
            const isTouch = isTouchDevice();

            // Set initial crosshair position
            combatMode.mouseX = containerRect.width / 2;
            combatMode.mouseY = containerRect.height / 2;
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;

            // Ëß∏ÊéßË£ùÁΩÆ‰∏äÊõ¥ÊÖ¢ÁöÑËøΩËπ§ÈñìÈöî
            const trackingInterval = 300;

            // Start tracking defender - Âú®Ëß∏ÊéßË£ùÁΩÆ‰∏äÊõ¥ÊÖ¢
            const trackInterval = setInterval(() => {
                if (!combatMode.active || combatMode.bulletFired) {
                    clearInterval(trackInterval);
                    return;
                }

                // Move crosshair toward defender with some error margin
                const difficultyFactor = 1 - (combatMode.attacker.hit * 0.1);

                // Ëß∏ÊéßË£ùÁΩÆ‰∏ä‰ΩøÁî®Êõ¥Â§ßÁöÑË™§Â∑ÆÁØÑÂúç
                const errorMultiplier = 200;
                const errorX = (Math.random() - 0.5) * errorMultiplier * difficultyFactor;
                const errorY = (Math.random() - 0.5) * errorMultiplier * difficultyFactor;

                combatMode.mouseX = combatMode.defenderX + errorX;
                combatMode.mouseY = combatMode.defenderY + errorY;

                crosshair.style.left = `${combatMode.mouseX}px`;
                crosshair.style.top = `${combatMode.mouseY}px`;
            }, trackingInterval);

            // Ëß∏ÊéßË£ùÁΩÆ‰∏äÊõ¥Èï∑ÁöÑÂ∞ÑÊìäÂª∂ÈÅ≤
            const minDelay = 500;
            const maxRandomDelay = 2000;
            const shootDelay = minDelay + Math.random() * maxRandomDelay;

            setTimeout(() => {
                if (combatMode.active && !combatMode.bulletFired) {
                    shootLaser();
                }
                clearInterval(trackInterval);
            }, shootDelay);
        }

        // ‰øÆÊîπendCombatÂáΩÊï∏Ôºå‰øÆÂæ©Èò≤ÂÆàËÄÖÂãùÂà©ÊôÇÂõûÂêàË®àÊï∏ÂïèÈ°å
        function endCombat(winner) {
            if (combatMode.result) return; // Already ended

            combatMode.result = winner;
            console.log(`Êà∞È¨•ÁµêÊùü: ${winner === 'attacker' ? 'ÊîªÊìäËÄÖ' : 'Èò≤ÂÆàËÄÖ'}ÂãùÂà©`);
            console.log(`ÊîªÊìäËÄÖ‰ΩçÁΩÆ: [${combatMode.attackerPos.row},${combatMode.attackerPos.col}], Èò≤ÂÆàËÄÖ‰ΩçÁΩÆ: [${combatMode.defenderPos.row},${combatMode.defenderPos.col}]`);

            // Show result
            combatResult.textContent = winner === 'attacker'
                ? `${combatMode.attacker.type} ÂãùÂà©ÔºÅ`
                : `${combatMode.defender.type} ÊàêÂäüÈñÉÈÅøÔºÅ`;

            combatResult.classList.add('show');

            // Remove event listeners
            combatContainer.removeEventListener('mousemove', handleAttackerMouseMove);
            combatContainer.removeEventListener('click', handleAttackerClick);
            combatContainer.removeEventListener('touchmove', handleAttackerTouchMove);
            combatContainer.removeEventListener('touchstart', handleAttackerTouch);

            combatContainer.removeEventListener('mousemove', handleDefenderMouseMove);
            combatContainer.removeEventListener('click', handleDefenderClick);
            combatContainer.removeEventListener('touchmove', handleDefenderTouchMove);
            combatContainer.removeEventListener('touchstart', handleDefenderTouch);

            // End combat and update game state after a delay
            setTimeout(() => {
                combatOverlay.classList.add('hidden');
                combatMode.active = false;

                if (combatMode.frameRequest) {
                    cancelAnimationFrame(combatMode.frameRequest);
                    combatMode.frameRequest = null;
                }

                // Âú®Êõ¥ÊîπÈÅäÊà≤ÁãÄÊÖãÂâçÔºåÁ¢∫‰øùÊ∏ÖÈô§‰ªª‰ΩïÂèØËÉΩÊéíÈöäÁöÑAIÁßªÂãïË®àÊôÇÂô®
                if (aiMoveTimer) {
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }

                // Update game state based on combat result
                if (winner === 'attacker') {
                    // Attacker wins - complete the capture
                    const { attackerPos, defenderPos } = combatMode;
                    movePiece(attackerPos.row, attackerPos.col, defenderPos.row, defenderPos.col);
                } else {
                    // Defender wins - pieces stay where they are, but turn changes
                    // ‰øùÂ≠òÁï∂ÂâçÂõûÂêà‰ª•Ê™¢Êü•ÊòØÂê¶ÁôºÁîüÂõûÂêàËΩâÊèõ
                    const previousTurn = gameState.currentTurn;

                    // ÂàáÊèõÂõûÂêà
                    gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;

                    // Áï∂Á¥ÖÊñπ(AI)ÊîªÊìäÂ§±ÊïóÔºåÂõûÂêàËΩâÂõûËóçÊñπÊôÇÔºåÂõûÂêàÊï∏ÊáâË©≤Â¢ûÂä†
                    if (previousTurn === RED && gameState.currentTurn === BLUE) {
                        gameState.turnCount++;
                        console.log(`Èò≤ÂÆàÊàêÂäüÂæåÂõûÂêàÊï∏Â¢ûÂä†Âà∞: ${gameState.turnCount}`);

                        // Ê∑ªÂä†Ê≠§Ë°åÊòæÁ§∫ÂõûÂêàËøáÊ∏°
                        showTurnTransition(BLUE, gameState.turnCount);

                        // Ê£ÄÊü•ÊòØÂê¶Ê≠£Âú®Êí≠ÊîæÊàòÊñóBGM
                        const wasBattleBgmPlaying = battleBgmPlayer !== null;
                        stopBattleBGM();

                        // Âè™ÊúâÂú®‰πãÂâçÊ≠£Âú®Êí≠ÊîæÊàòÊñóBGMÊó∂Êâç‰ªéÂ§¥Êí≠Êîæboardbgm
                        if (wasBattleBgmPlaying && levelManager && levelManager.currentLevel) {
                            // ‰ªéÂ§¥Êí≠ÊîæÂÖ≥Âç°BGM
                            const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                            if (currentLevelData && currentLevelData.boardbgm) {
                                playBoardBGM(currentLevelData.boardbgm);
                            }
                        }

                        // Ëß∏ÁôºÂõûÂêàÈñãÂßã‰∫ã‰ª∂
                        if (typeof eventSystem !== 'undefined') {
                            console.log(`Èò≤ÂÆàÊàêÂäüÂæåËß∏ÁôºËóçÊñπÂõûÂêàÈñãÂßã‰∫ã‰ª∂ÔºåÂõûÂêàÊï∏: ${gameState.turnCount}`);
                            eventSystem.triggerEvent('turnStart', {
                                team: BLUE,
                                turn: gameState.turnCount
                            });
                        }
                    }

                    // Êõ¥Êñ∞‰ªãÈù¢
                    updateTurnIndicator();
                    updateTurnCountDisplay(); // Â¢ûÂä†ÈÄô‰∏ÄË°åÔºåÁ¢∫‰øùÈ°ØÁ§∫Ê≠£Á¢∫ÁöÑÂõûÂêàÊï∏
                    statusMessage.textContent = `${gameState.currentTurn === BLUE ? 'ËóçÊñπ' : 'Á¥ÖÊñπ'}ÂõûÂêà„ÄÇ`;

                    // Clear selection
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                }

                // If AI's turn after combat, schedule its move
                if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                    aiMoveTimer = setTimeout(makeAIMove, 500);
                }
            }, 1500);
        }

        // AI Move Logic
        function makeAIMove() {
            // Á¢∫‰øùÊòØAIÁöÑÂõûÂêàÂÜçÂü∑Ë°åÁßªÂãï - Êñ∞Â¢ûÊ™¢Êü•‰ª•Èò≤Ê≠¢ÈåØË™§ÂõûÂêàÁßªÂãï
            if (gameState.gameOver || combatMode.active || gameState.currentTurn !== RED) {
                return;
            }

            const now = Date.now();
            aiMoveCount++;

            // Ë®òÈåÑÁßªÂãïÊôÇÈñì
            lastAIMoveTime = now;

            // Find all pieces of current team (RED for AI)
            const aiTeam = RED;
            let allPossibleMoves = [];

            // Collect all possible moves
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.team === aiTeam) {
                        const validMoves = calculateValidMoves(row, col);
                        validMoves.forEach(move => {
                            allPossibleMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                piece: piece,
                                targetPiece: gameState.board[move.row][move.col]
                            });
                        });
                    }
                }
            }

            // If no moves, game over - but we don't show victory screen for this case
            if (allPossibleMoves.length === 0) {
                gameState.gameOver = true;
                gameState.winner = BLUE;
                statusMessage.textContent = `ÈÅäÊà≤ÁµêÊùüÔºÅËóçÊñπÈÄöÈÅéÂ∞áËªçÁç≤ÂãùÔºÅ`;
                // ÁßªÈô§ÂãùÂà©Áï´Èù¢ÁöÑÈ°ØÁ§∫ÔºåÂè™ÊîπËÆäÈÅäÊà≤ÁãÄÊÖãÂíåË®äÊÅØ
                return;
            }

            // Prioritize moves
            allPossibleMoves.sort((a, b) => {
                // Prioritize captures over non-captures
                if (a.targetPiece && !b.targetPiece) return -1;
                if (!a.targetPiece && b.targetPiece) return 1;

                // For captures, prioritize higher value pieces
                if (a.targetPiece && b.targetPiece) {
                    const aValue = getPieceValue(a.targetPiece.moveType);
                    const bValue = getPieceValue(b.targetPiece.moveType);
                    if (aValue !== bValue) return bValue - aValue;
                }

                // Add some randomness
                return Math.random() - 0.5;
            });

            // Choose the best move
            const chosenMove = allPossibleMoves[0];

            // AIÈÅ∏ÊìáÁßªÂãïÂÆåÊàê

            // If move is a capture, initiate combat
            if (chosenMove.targetPiece) {
                gameState.selectedPiece = { row: chosenMove.fromRow, col: chosenMove.fromCol };
                startCombat(chosenMove.piece, chosenMove.targetPiece,
                            { row: chosenMove.fromRow, col: chosenMove.fromCol },
                            { row: chosenMove.toRow, col: chosenMove.toCol });
            } else {
                // Regular move
                movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
            }
        }

        // Helper to get piece values for AI decision making
        function getPieceValue(moveType) {
            switch(moveType) {
                case PAWN: return 1;
                case KNIGHT: return 3;
                case BISHOP: return 3;
                case ROOK: return 5;
                case QUEEN: return 9;
                case KING: return 100;
                default: return 0;
            }
        }

        // Show toast notification
        function showToast(message, duration = 2000) {
            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        function sendGameState() {
            if (connection && connection.open) {
                connection.send({
                    type: 'gameState',
                    state: gameState
                });
            }
        }

        // Initialize the cover page space background
        setupSpaceBackground(document.getElementById('cover-space-bg'));

        // Êñ∞Â¢ûÂ∫èÁ´†È†ÅÈù¢ÁöÑHTML
        const prologueHTML = `
        <div id="prologue-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[400] flex items-start justify-center opacity-0 transition-opacity duration-500">
            <div class="relative max-w-3xl w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform transition-transform duration-500 scale-95" style="margin-top: 5vh;">
                <div class="absolute inset-0 overflow-hidden opacity-20">
                    <div class="stars-bg absolute inset-0"></div>
                </div>

                <div class="relative p-6 md:p-8">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl md:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">Â∫è</h2>
                    </div>

                    <div class="space-y-4 text-gray-300 leading-relaxed mb-8 md:text-lg">
                        <p>Âü∫ÁàæÂü∫ÁàæÈãºËàáÈóòÁ•û¬∑Ë´æ‰∫û‰∫ã‰ª∂ÂæåÁöÑÂíåÂπ≥ÊôÇ‰ª£ÔºåÂéüÊòüÁêÉ‰∏äÁöÑË∂ÖÁ¥öÊ©üÊ¢∞‰∫∫ÂÄëÈÄêÊº∏ÈáçÂª∫ÂÆ∂ÂúíÔºåÈÉ®ÂàÜÊ©üÊ¢∞‰∫∫ÈÅ∏ÊìáÈõ¢ÈñãÊòüÁêÉÔºåÂâçÂæÄÂÆáÂÆôÂª∫Á´ãÊñ∞ÁöÑÁîüÊ¥ªÁ©∫Èñì„ÄÇÁÑ∂ËÄåÔºåÂÆáÂÆô‰∏≠Ë≥áÊ∫êÁöÑÊúâÈôêÊÄßËàáÂ∞çÂéüÊòüÁêÉË≥áÊ∫êÁöÑ‰æùË≥¥Ôºå‰ΩøÂæóÂ±ÖÊñºÂÆáÂÆôÁöÑÊ©üÊ¢∞‰∫∫ÈÄêÊº∏ËàáÂú∞ÁêÉÁî¢ÁîüÁüõÁõæ„ÄÇÂÆáÂÆôËÅØÂêàËªçÂÆ£Â∏ÉÁç®Á´ãÔºå‰∏¶ÂêëÂú∞ÁêÉÁôºÂãï‰æµÁï•Êà∞Áà≠„ÄÇ</p>
                        <p>Èù¢Â∞çÂêåËÉûÈñìÁöÑËá™Áõ∏ÊÆòÊÆ∫ÔºåËã±ÈõÑÂÄëÂÜçÊ¨°ÈõÜÁµêÔºåË™ìË¶ÅÈòªÊ≠¢ÈÄôÂ†¥Êà∞Áà≠„ÄÇÁÑ∂ËÄåÔºåÂú®ÈÄôÂ†¥Ë°ùÁ™ÅËÉåÂæåÔºå‰ºº‰πéÈö±ËóèËëóÊõ¥Â§ßÁöÑÈô∞Ë¨Ä‚Ä¶‚Ä¶</p>
                    </div>

                    <div class="flex justify-center">
                        <button id="prologue-continue-btn" class="px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                            ÁπºÁ∫å
                        </button>
                    </div>
                </div>
            </div>
        </div>
        `;

        // ÈóúÂç°Á≥ªÁµ±‰ª£Á¢º ------------------------------
        // ÈóúÂç°ÁÆ°ÁêÜÁ≥ªÁµ±
        const levelManager = {
            currentLevel: 0,
            isLevelActive: false,

            // Âä†ËºâÊåáÂÆöÈóúÂç°
            loadLevel: function(levelId) {
                console.log("Âä†ËºâÈóúÂç°:", levelId);
                const levelInfo = window.levelData.find(level => level.id === levelId);
                if (!levelInfo) {
                    console.error(`ÈóúÂç° ${levelId} ‰∏çÂ≠òÂú®`);
                    return false;
                }

                this.currentLevel = levelId;
                this.isLevelActive = true;

                // È°ØÁ§∫ÈóúÂç°Ë≥áË®äÈ†Å
                this.showLevelInfo(levelInfo);

                return true;
            },

            // È°ØÁ§∫ÈóúÂç°Ë≥áË®äÈ†Å - Ê∑ªÂä†ÂÆâÂÖ®Ê™¢Êü•
            showLevelInfo: function(levelInfo) {
                console.log("È°ØÁ§∫ÈóúÂç°‰ø°ÊÅØ:", levelInfo.title);

                try {
                    // Ë®≠ÁΩÆÈóúÂç°Ê®ôÈ°åÂíåÂâØÊ®ôÈ°åÔºàÊ∑ªÂä†ÂÆâÂÖ®Ê™¢Êü•Ôºâ
                    const levelTitleEl = document.getElementById('level-title');
                    const levelSubtitleEl = document.getElementById('level-subtitle');
                    const levelStoryContentEl = document.getElementById('level-story-content');
                    const victoryTextEl = document.getElementById('victory-text');
                    const defeatTextEl = document.getElementById('defeat-text');
                    const startLevelBtnEl = document.getElementById('start-level-btn');
                    const levelInfoOverlay = document.getElementById('level-info-overlay');

                    if (levelTitleEl) {
                        levelTitleEl.textContent = levelInfo.title;
                    } else {
                        console.error(`ÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - level-title ÂÖÉÁ¥†‰∏çÂ≠òÂú®`);
                    }

                    if (levelSubtitleEl) {
                        levelSubtitleEl.textContent = levelInfo.subtitle || '';
                    }

                    // Ë®≠ÁΩÆÈóúÂç°ÂúñÁâá
                    const levelImage = document.getElementById('level-image');
                    if (levelImage) {
                        if (levelInfo.storyImage) {
                            levelImage.src = levelInfo.storyImage;
                            levelImage.style.display = 'block';
                        } else {
                            levelImage.style.display = 'none';
                        }
                    }

                    // Ë®≠ÁΩÆÊïÖ‰∫ãÁ∞°‰ªã
                    if (levelStoryContentEl) {
                        levelStoryContentEl.textContent = levelInfo.storyDesc || 'ÁÑ°ÊïÖ‰∫ãÁ∞°‰ªã';
                    }

                    // Ë®≠ÁΩÆÂãùÂà©Ê¢ù‰ª∂ÂíåÊà∞ÊïóÊ¢ù‰ª∂
                    if (victoryTextEl) {
                        victoryTextEl.textContent = 'ÂãùÂà©Ê¢ù‰ª∂Ôºö' + (levelInfo.victoryCondition.description || 'ÂêÉÊéâÂ∞çÊñπÁöÑÂúãÁéãÊ£ã');
                    }

                    if (defeatTextEl) {
                        defeatTextEl.textContent = 'Êà∞ÊïóÊ¢ù‰ª∂Ôºö' + (levelInfo.defeatCondition.description || 'ÂúãÁéãÊ£ãË¢´Â∞çÊñπÂêÉÊéâ');
                    }

                    // Ê∑ªÂä†ÈñãÂßãÊåâÈàï‰∫ã‰ª∂
                    if (startLevelBtnEl) {
                        startLevelBtnEl.onclick = () => {
                            this.startLevel(levelInfo);
                        };
                    }

                    // È°ØÁ§∫ÈóúÂç°‰ø°ÊÅØÈ†ÅÈù¢
                    if (levelInfoOverlay) {
                        levelInfoOverlay.classList.add('show');
                    } else {
                        console.error(`ÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - level-info-overlay ÂÖÉÁ¥†‰∏çÂ≠òÂú®`);
                    }
                } catch (error) {
                    console.error(`ÈóúÂç°‰ø°ÊÅØÈ°ØÁ§∫ÈåØË™§ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // ÈñãÂßãÈóúÂç° - Ê∑ªÂä†ÂÆâÂÖ®Ê™¢Êü•ÂíåÈÅ©Áï∂ÁöÑÂª∂ÈÅ≤
            startLevel: function(levelInfo) {
                console.log("ÈñãÂßãÈóúÂç°:", levelInfo.title);
                try {
                    // Èö±ËóèÈóúÂç°‰ø°ÊÅØÈ†ÅÈù¢
                    const levelInfoOverlay = document.getElementById('level-info-overlay');
                    if (levelInfoOverlay) {
                        levelInfoOverlay.classList.remove('show');
                    } else {
                        console.error(`ÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - level-info-overlay ÂÖÉÁ¥†‰∏çÂ≠òÂú®`);
                    }

                    // Êí≠ÊîæÈóúÂç°ËÉåÊôØÈü≥Ê®Ç
                    if (levelInfo.boardbgm) {
                        playBoardBGM(levelInfo.boardbgm);
                    }

                    // Âª∂ÈÅ≤‰∏Ä‰∏ãÁ¢∫‰øùUIÊõ¥Êñ∞ÂÆåÊàê
                    setTimeout(() => {
                        // È°ØÁ§∫ÈÅäÊà≤UI
                        if (gameUI) {
                            gameUI.style.display = 'block';
                        }

                        // ÂàùÂßãÂåñÈóúÂç°
                        this.initializeLevel(levelInfo);

                    }, 100); // Áµ¶DOM 100msÁöÑÊôÇÈñìÂÆåÊàêÊ∏≤Êüì
                } catch (error) {
                    console.error(`ÈóúÂç°ÈñãÂßãÈåØË™§ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // ÂàùÂßãÂåñÈóúÂç° - Ê∑ªÂä†ÈåØË™§ËôïÁêÜÂíåÊó•Ë™å
            initializeLevel: function(levelInfo) {
                console.log("ÂàùÂßãÂåñÈóúÂç°");
                console.log("Â∑≤Âä†ËΩΩÁöÑ‰∫ã‰ª∂:", eventSystem.events);
                try {
                    // Á¢∫Ë™çlevelInfoÂ≠òÂú®
                    if (!levelInfo) {
                        console.error(`ÂàùÂßãÂåñÈóúÂç°ÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - levelInfoÁÇ∫null`);
                        return;
                    }

                    // 1. Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ô
                    this.setBoardImage(levelInfo.boardImage);

                    // 2. Ë®≠ÁΩÆÊ£ãÁõ§ÁãÄÊÖãÔºàÊ£ãÂ≠ê‰ΩçÁΩÆÔºâ
                    this.setInitialBoardState(levelInfo.initialBoardState);

                    // 3. Ë®≠ÁΩÆÂãùÂà©Ê¢ù‰ª∂
                    this.setVictoryCondition(levelInfo.victoryCondition);

                    // 4. Ë®≠ÁΩÆÊà∞ÊïóÊ¢ù‰ª∂
                    this.setDefeatCondition(levelInfo.defeatCondition);

                    // 5. ÂõûÂêàÊï∏Ê≠∏Èõ∂
                    if (gameState) {
                        gameState.turnCount = 0;
                        updateTurnCountDisplay();
                    } else {
                        console.error(`ÂàùÂßãÂåñÈóúÂç°ÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - gameStateÁÇ∫null`);
                    }

                    // 6. ËºâÂÖ•Ë©≤ÈóúÂç°ÁöÑÁâπÂà•‰∫ã‰ª∂
                    if (levelInfo.events) {
                        this.loadLevelEvents(levelInfo.events);
                    }

                    console.log(`ÈóúÂç°ÂàùÂßãÂåñÂÆåÊàêÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`ÈóúÂç°ÂàùÂßãÂåñÈåØË™§ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ô - Ê∑ªÂä†ÂÆâÂÖ®Ê™¢Êü•ÂíåÈåØË™§ËôïÁêÜ
            setBoardImage: function(imagePath) {
                try {
                    if (!imagePath) {
                        console.log(`Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ôÔºöÊú™Êèê‰æõÂúñÁâáË∑ØÂæëÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                        return;
                    }

                    const chessBoardElement = document.querySelector('.chess-board');
                    if (chessBoardElement) {
                        chessBoardElement.style.backgroundImage = `url('${imagePath}')`;
                        console.log(`Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ôÊàêÂäüÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                    } else {
                        console.error(`Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ôÈåØË™§Ôºö.chess-boardÂÖÉÁ¥†‰∏çÂ≠òÂú®ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                    }
                } catch (error) {
                    console.error(`Ë®≠ÁΩÆÊ£ãÁõ§ÂúñÁ¥ôÁôºÁîüÁï∞Â∏∏ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // Ë®≠ÁΩÆÂàùÂßãÊ£ãÁõ§ÁãÄÊÖã - ÂæûÈóúÂç°‰∏≠ËÆÄÂèñÊ©üÈ´îÂÆöÁæ©
            setInitialBoardState: function(initialState) {
                try {
                    if (!gameState || !BOARD_SIZE || typeof initializeGame !== 'function') {
                        console.error(`Ë®≠ÁΩÆÂàùÂßãÊ£ãÁõ§ÁãÄÊÖãÈåØË™§ÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms - gameStateÊàñÂàùÂßãÂåñÂáΩÊï∏‰∏çÂèØÁî®`);
                        return;
                    }

                    // Â¶ÇÊûúÊ≤íÊúâÊèê‰æõÂàùÂßãÁãÄÊÖãÔºåÂâá‰ΩøÁî®ÈªòË™çÂàùÂßãÂåñ
                    if (!initialState) {
                        console.log(`Êú™Êèê‰æõÂàùÂßãÊ£ãÁõ§ÁãÄÊÖãÔºå‰ΩøÁî®ÈªòË™çÂàùÂßãÂåñÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                        initializeGame();
                        return;
                    }

                    // Ê∏ÖÁ©∫Áï∂ÂâçÊ£ãÁõ§
                    gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                    gameState.blueCaptured = [];
                    gameState.redCaptured = [];
                    gameState.currentTurn = BLUE;
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    gameState.gameOver = false;
                    gameState.winner = null;

                    console.log(`ÈñãÂßãË®≠ÁΩÆ ${initialState.length} ÂÄãÊ£ãÂ≠êÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);

                    // Áç≤ÂèñÁï∂ÂâçÈóúÂç°ÁöÑÊ©üÈ´îÂÆöÁæ©
                    const currentLevelData = window.levelData.find(level => level.id === this.currentLevel);
                    if (!currentLevelData || !currentLevelData.pieceDefinitions) {
                        console.error(`ÁÑ°Ê≥ïÊâæÂà∞ÈóúÂç° ${this.currentLevel} ÁöÑÊ©üÈ´îÂÆöÁæ©`);
                        return;
                    }

                    const levelPieceDefinitions = currentLevelData.pieceDefinitions;

                    // Ê†πÊìöÊèê‰æõÁöÑÂàùÂßãÁãÄÊÖãË®≠ÁΩÆÊ£ãÂ≠ê
                    initialState.forEach(piece => {
                    if (!piece || !piece.id || !piece.position || !Array.isArray(piece.position) || piece.position.length !== 2) {
                        console.error(`ÁÑ°ÊïàÁöÑÊ£ãÂ≠êÂÆöÁæ©: ${JSON.stringify(piece)}`);
                        return;
                    }

                    const { id, position } = piece;
                    const [row, col] = position;

                    // Create a variable for the potentially modified ID
                    let actualPieceId = id;
    
                    // Check if we should replace gundam with fa_gundam
                    if (Get_fa_gundam === 1 && id === 'gundam') {
                        actualPieceId = 'fa_gundam';
                        console.log(`Replacing gundam with fa_gundam at position [${row},${col}]`);
                    }

                    if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                        console.error(`Ê£ãÂ≠ê‰ΩçÁΩÆË∂ÖÂá∫ÁØÑÂúç: [${row},${col}]`);
                        return;
                    }

                    // Check if the piece definition exists using actualPieceId
                    if (!levelPieceDefinitions[actualPieceId]) {
                        console.error(`Âú®ÈóúÂç° ${this.currentLevel} ‰∏≠Êú™ÂÆöÁæ©ÁöÑÊ£ãÂ≠êID: ${actualPieceId}`);
                        return;
                    }

                    // Use the potentially modified piece ID for creating the piece
                    const pieceDefinition = levelPieceDefinitions[actualPieceId];
                    gameState.board[row][col] = {
                        id: actualPieceId, // Use the potentially modified ID
                        team: pieceDefinition.team,
                        type: pieceDefinition.type,
                        moveType: pieceDefinition.moveType,
                        imgUrl: pieceDefinition.imgUrl,
                        hit: pieceDefinition.hit,
                        dodge: pieceDefinition.dodge,
                        bgmtype: pieceDefinition.bgmtype || '',
                        weapon_colour: pieceDefinition.weapon_colour || '',
                        crosshairType: pieceDefinition.crosshairType || 'Beam_Rifie',
                        hasMoved: false
                    };
                });
                    console.log(`Ê£ãÁõ§ÂàùÂßãÂåñÂÆåÊàêÔºåÊõ¥Êñ∞UIÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);

                    // ÂÆâÂÖ®Êõ¥Êñ∞UI
                    if (typeof updateBoardDisplay === 'function') updateBoardDisplay();
                    else console.error(`updateBoardDisplay ÂáΩÊï∏‰∏çÂèØÁî®ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);

                    if (typeof updateCapturedPieces === 'function') updateCapturedPieces();
                    else console.error(`updateCapturedPieces ÂáΩÊï∏‰∏çÂèØÁî®ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);

                    if (typeof updateTurnIndicator === 'function') updateTurnIndicator();
                    else console.error(`updateTurnIndicator ÂáΩÊï∏‰∏çÂèØÁî®ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`Ë®≠ÁΩÆÂàùÂßãÊ£ãÁõ§ÁãÄÊÖãÁôºÁîüÁï∞Â∏∏ÔºåÊôÇÈñì: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // Ë®≠ÁΩÆÂãùÂà©Ê¢ù‰ª∂
            setVictoryCondition: function(condition) {
                // ‰øùÂ≠òÂãùÂà©Ê¢ù‰ª∂Âà∞ÈÅäÊà≤ÁãÄÊÖã
                if (gameState) {
                    gameState.victoryCondition = condition;
                }
            },

            // Ë®≠ÁΩÆÊà∞ÊïóÊ¢ù‰ª∂
            setDefeatCondition: function(condition) {
                // ‰øùÂ≠òÊà∞ÊïóÊ¢ù‰ª∂Âà∞ÈÅäÊà≤ÁãÄÊÖã
                if (gameState) {
                    gameState.defeatCondition = condition;
                }
            },

            // Âä†ËºâÈóúÂç°‰∫ã‰ª∂
            loadLevelEvents: function(events) {
                // Ê∏ÖÈô§‰πãÂâçÁöÑÊâÄÊúâ‰∫ã‰ª∂
                eventSystem.clearEvents();

                // Â¶ÇÊûúÊ≤íÊúâ‰∫ã‰ª∂ÔºåÁõ¥Êé•ËøîÂõû
                if (!events || events.length === 0) return;

                // Ë®ªÂÜäÊâÄÊúâÈóúÂç°‰∫ã‰ª∂
                events.forEach(event => {
                    eventSystem.registerEvent(event);
                });
            },

            // Ê™¢Êü•ÂãùÂà©Ê¢ù‰ª∂
            checkVictoryCondition: function() {
                if (!gameState || !gameState.victoryCondition) return false;

                // Ê†πÊìö‰∏çÂêåÁöÑÂãùÂà©Ê¢ù‰ª∂È°ûÂûãÈÄ≤Ë°åÊ™¢Êü•
                switch (gameState.victoryCondition.type) {
                    case 'captureKing':
                        // ÈÄôÂÄãÂú®movePieceÂáΩÊï∏‰∏≠Â∑≤Á∂ìËôïÁêÜ‰∫Ü
                        break;

                    case 'surviveNTurns':
                        // Ê™¢Êü•ÊòØÂê¶Â≠òÊ¥ª‰∫ÜÊåáÂÆöÂõûÂêàÊï∏
                        return gameState.turnCount >= gameState.victoryCondition.turns;

                    case 'reachPosition':
                        // Ê™¢Êü•ÁâπÂÆöÊ£ãÂ≠êÊòØÂê¶Âà∞ÈÅî‰∫ÜÁâπÂÆö‰ΩçÁΩÆ
                        return this.checkPiecePosition(
                            gameState.victoryCondition.pieceId,
                            gameState.victoryCondition.position
                        );

                    case 'captureAllPieces':
                        // Ê™¢Êü•ÊòØÂê¶ÊçïÁç≤‰∫ÜÊâÄÊúâÊïµÊñπÊ£ãÂ≠ê
                        return this.checkAllPiecesCaptured(RED);

                    // ÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öÂãùÂà©Ê¢ù‰ª∂È°ûÂûã
                }

                return false;
            },

            // Ê™¢Êü•Êà∞ÊïóÊ¢ù‰ª∂
            checkDefeatCondition: function() {
                if (!gameState || !gameState.defeatCondition) return false;

                // Ê†πÊìö‰∏çÂêåÁöÑÊà∞ÊïóÊ¢ù‰ª∂È°ûÂûãÈÄ≤Ë°åÊ™¢Êü•
                switch (gameState.defeatCondition.type) {
                    case 'kingCaptured':
                        // ÈÄôÂÄãÂú®movePieceÂáΩÊï∏‰∏≠Â∑≤Á∂ìËôïÁêÜ‰∫Ü
                        break;

                    case 'turnLimit':
                        // Ê™¢Êü•ÊòØÂê¶Ë∂ÖÈÅé‰∫ÜÂõûÂêàÈôêÂà∂
                        return gameState.turnCount > gameState.defeatCondition.turns;

                    case 'pieceDestroyed':
                        // Ê™¢Êü•ÁâπÂÆöÊ£ãÂ≠êÊòØÂê¶Ë¢´Á†¥Â£û
                        return this.checkPieceDestroyed(
                            gameState.defeatCondition.pieceId
                        );

                    // ÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öÊà∞ÊïóÊ¢ù‰ª∂È°ûÂûã
                }

                return false;
            },

            // Ê™¢Êü•ÁâπÂÆöÊ£ãÂ≠êÊòØÂê¶Âú®ÁâπÂÆö‰ΩçÁΩÆ
            checkPiecePosition: function(pieceId, position) {
                if (!gameState || !gameState.board) return false;

                const [targetRow, targetCol] = position;
                if (targetRow < 0 || targetRow >= BOARD_SIZE || targetCol < 0 || targetCol >= BOARD_SIZE) {
                    return false;
                }

                const piece = gameState.board[targetRow][targetCol];
                return piece && piece.id === pieceId;
            },

            // Ê™¢Êü•ÁâπÂÆöÊ£ãÂ≠êÊòØÂê¶Ë¢´Á†¥Â£û
            checkPieceDestroyed: function(pieceId) {
                if (!gameState || !gameState.board) return false;

                // Âú®ÊâÄÊúâÊ£ãÁõ§‰ΩçÁΩÆÂ∞ãÊâæÈÄôÂÄãÊ£ãÂ≠ê
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.id === pieceId) {
                            return false; // Ê£ãÂ≠ê‰ªçÁÑ∂Â≠òÂú®
                        }
                    }
                }

                return true; // Ê£ãÂ≠ê‰∏çÂ≠òÂú®ÔºåÂ∑≤Ë¢´Á†¥Â£û
            },

            // Ê™¢Êü•ÊòØÂê¶ÊâÄÊúâÊïµÊñπÊ£ãÂ≠êË¢´ÊçïÁç≤
            checkAllPiecesCaptured: function(team) {
                if (!gameState || !gameState.board) return false;

                // Âú®Ê£ãÁõ§‰∏äÂ∞ãÊâæÊåáÂÆöÈöä‰ºçÁöÑÊ£ãÂ≠ê
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.team === team) {
                            return false; // ‰ªçÊúâÊïµÊñπÊ£ãÂ≠ê
                        }
                    }
                }

                return true; // ÊâÄÊúâÊïµÊñπÊ£ãÂ≠êÂ∑≤Ë¢´ÊçïÁç≤
            },

            // ÈóúÂç°ÂÆåÊàêËôïÁêÜ
            levelComplete: function() {
                console.log("ÈóúÂç°ÂÆåÊàê");
                // Âú®ÂãùÂà©Áï´Èù¢È°ØÁ§∫ÂæåÔºåÊèê‰æõÈÄ≤ÂÖ•‰∏ã‰∏ÄÈóúÁöÑÈÅ∏È†Ö
                // ‰øÆÊîπÂãùÂà©Áï´Èù¢ÁöÑÊåâÈàïÊñáÊú¨
                const victoryResetBtn = document.getElementById('victory-reset');
                if (victoryResetBtn) {
                    victoryResetBtn.textContent = 'ÈÄ≤ÂÖ•‰∏ã‰∏ÄË©±';

                    // ÂÖãÈöÜÊåâÈàï‰∏¶ÊõøÊèõ‰ª•ÁßªÈô§ÊâÄÊúâ‰∫ã‰ª∂Áõ£ËÅΩÂô®
                    const newBtn = victoryResetBtn.cloneNode(true);
                    if (victoryResetBtn.parentNode) {
                        victoryResetBtn.parentNode.replaceChild(newBtn, victoryResetBtn);
                    }

                    // Ê∑ªÂä†Êñ∞ÁöÑÈªûÊìä‰∫ã‰ª∂
                    newBtn.onclick = () => {
                        if (victoryOverlay) {
                            victoryOverlay.classList.remove('show');
                        }
                        this.nextLevel();
                    };
                }
            },

            // ÈóúÂç°Â§±ÊïóËôïÁêÜ
            levelFailed: function() {
                console.log("ÈóúÂç°Â§±Êïó");
                // ‰øÆÊîπÂãùÂà©Áï´Èù¢ÁöÑÊåâÈàïÊñáÊú¨
                const victoryResetBtn = document.getElementById('victory-reset');
                if (victoryResetBtn) {
                    victoryResetBtn.textContent = 'ÈáçË©¶Êú¨Èóú';

                    // ÂÖãÈöÜÊåâÈàï‰∏¶ÊõøÊèõ‰ª•ÁßªÈô§ÊâÄÊúâ‰∫ã‰ª∂Áõ£ËÅΩÂô®
                    const newBtn = victoryResetBtn.cloneNode(true);
                    if (victoryResetBtn.parentNode) {
                        victoryResetBtn.parentNode.replaceChild(newBtn, victoryResetBtn);
                    }

                    // Ê∑ªÂä†Êñ∞ÁöÑÈªûÊìä‰∫ã‰ª∂
                    newBtn.onclick = () => {
                        if (victoryOverlay) {
                            victoryOverlay.classList.remove('show');
                        }
                        this.retryLevel();
                    };
                }
            },

            // ÈÄ≤ÂÖ•‰∏ã‰∏ÄÈóú
            nextLevel: function() {
                console.log("ÈÄ≤ÂÖ•‰∏ã‰∏ÄÈóú");
    
                // Èö±ËóèÂãùÂà©Áï´Èù¢
                if (victoryOverlay) {
                    victoryOverlay.classList.remove('show');
                }
    
                // È°ØÁ§∫Âä†ËºâÁïåÈù¢
                const loadingOverlay = document.getElementById('csv-loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                    const loadingMessage = document.getElementById('csv-loading-message');
                    if (loadingMessage) {
                        loadingMessage.textContent = "Ê≠£Âú®ËºâÂÖ•Á¨¨‰∫åÈóúÊï∏Êìö...";
                    }
                }
    
                // Ê†πÊìöÁï∂ÂâçÈóúÂç°IDÊ±∫ÂÆöËºâÂÖ•Âì™ÂÄãCSVÊñá‰ª∂
                let nextCsvUrl = "";
                if (this.currentLevel === 1) {
                    // ÂæûÁ¨¨‰∏ÄÈóúÂà∞Á¨¨‰∫åÈóú
                    nextCsvUrl = "./stages/SRWCStage02.csv";
                } else if (this.currentLevel === 2) {
                    // ‰ªéÁ¨¨‰∫åÂÖ≥Âà∞Á¨¨‰∏âÂÖ≥
                    nextCsvUrl = "./stages/SRWCStage03.csv";
                } else if (this.currentLevel === 3) {
                    // ‰ªéÁ¨¨‰∏âÂÖ≥Âà∞Á¨¨ÂõõÂÖ≥
                    nextCsvUrl = "./stages/SRWCStage04.csv";
                } else {
                    // ÂÖ∂‰ªñÊÉÖÊ≥ÅÔºàÊú™‰æÜÂèØËÉΩÁöÑÁ¨¨‰∫îÈóúÁ≠âÔºâ
                    this.showComingSoonMessage();
                    return;
                }
    
                // ËºâÂÖ•‰∏ã‰∏ÄÈóúÁöÑCSV
                loadLevelsFromURL(nextCsvUrl).then(success => {
                    if (success) {
                        // Êõ¥Êñ∞Âä†ËºâÊ∂àÊÅØ
                        const loadingMessage = document.getElementById('csv-loading-message');
                        if (loadingMessage) {
                            loadingMessage.textContent = "Ê≠£Âú®È†êËºâÂúñÁâáË≥áÊ∫ê...";
                        }
            
                        // È†êËºâÂúñÁâá
                        console.log("ÈñãÂßãÈ†êËºâÂúñÁâá...");
                        const imagesToLoad = getAllImageURLsFromLevelData();
                        preloadImages(imagesToLoad).then(() => {
                            // Èö±ËóèÂä†ËºâÁïåÈù¢
                            if (loadingOverlay) {
                                loadingOverlay.style.display = 'none';
                            }
                
                            // Ê∏ÖÁêÜÁï∂ÂâçÈÅäÊà≤ÁãÄÊÖã
                            gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                            gameState.blueCaptured = [];
                            gameState.redCaptured = [];
                            gameState.currentTurn = BLUE;
                            gameState.selectedPiece = null;
                            gameState.validMoves = [];
                            gameState.gameOver = false;
                            gameState.winner = null;
                            gameState.turnCount = 0;
                
                            // Êõ¥Êñ∞UI
                            updateBoardDisplay();
                            updateCapturedPieces();
                            updateTurnIndicator();
                            updateTurnCountDisplay();
                
                            // ËºâÂÖ•Á¨¨‰∫åÈóú
                            const nextLevelId = window.levelData.length > 0 ? window.levelData[0].id : 1;
                            this.loadLevel(nextLevelId);
                        });
                    } else {
                        // ËºâÂÖ•Â§±Êïó
                        console.error("ÁÑ°Ê≥ïËºâÂÖ•‰∏ã‰∏ÄÈóúÊï∏Êìö");
                        this.showComingSoonMessage();
                    }
                }).catch(error => {
                    console.error("ËºâÂÖ•‰∏ã‰∏ÄÈóúÊôÇÂá∫ÈåØ:", error);
                    this.showComingSoonMessage();
                });
            },

            // È°ØÁ§∫"Êï¨Ë´ãÊúüÂæÖ"ÁöÑÊ∂àÊÅØ
            showComingSoonMessage: function() {
                // ÂâµÂª∫‰∏ÄÂÄãÁ¨¶ÂêàÈÅäÊà≤È¢®Ê†ºÁöÑ"Êï¨Ë´ãÊúüÂæÖ"ÂΩàÁ™ó
                const comingSoonHTML = `
                <div id="coming-soon-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[500] flex items-center justify-center opacity-0 transition-opacity duration-500">
                    <div class="relative max-w-md w-full bg-gradient-to-b from-gray-900 to-gray-800 rounded-lg p-6 text-white overflow-hidden shadow-2xl transform transition-all duration-500 scale-95">
                        <div class="absolute inset-0 overflow-hidden opacity-20">
                            <div class="stars-bg absolute inset-0"></div>
                        </div>

                        <div class="relative z-10">
                            <div class="text-center mb-6">
                                <h2 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">Êï¨Ë´ãÊúüÂæÖ</h2>
                            </div>

                            <div class="flex justify-center mb-6">
                                <div class="w-24 h-24 rounded-full bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center animate-pulse">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-14 w-14 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                    </svg>
                                </div>
                            </div>

                            <p class="text-center text-gray-300 mb-6">Á¨¨‰∫åË©±Ê≠£Âú®ÈñãÁôº‰∏≠ÔºåÊï¨Ë´ãÊúüÂæÖÂæåÁ∫åÊõ¥Êñ∞ÔºÅ</p>

                            <div class="flex justify-center">
                                <button id="coming-soon-btn" class="px-6 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none">
                                    ËøîÂõû‰∏ªÁï´Èù¢
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                `;

                // Ê∑ªÂä†ÂΩàÁ™óÂà∞È†ÅÈù¢
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = comingSoonHTML;
                const comingSoonOverlay = tempDiv.firstElementChild;
                document.body.appendChild(comingSoonOverlay);

                // Ë®≠ÁΩÆÊåâÈàï‰∫ã‰ª∂
                const comingSoonBtn = document.getElementById('coming-soon-btn');
                if (comingSoonBtn) {
                    comingSoonBtn.addEventListener('click', () => {
                        // Ê∑°Âá∫ÂΩàÁ™ó
                        comingSoonOverlay.style.opacity = '0';
                        comingSoonOverlay.querySelector('div[class*="scale-95"]').classList.add('scale-90');

                        // Âª∂ÈÅ≤ÂæåÁßªÈô§ÂΩàÁ™ó‰∏¶ËøîÂõû‰∏ªÁï´Èù¢
                        setTimeout(() => {
                            if (comingSoonOverlay.parentNode) {
                                comingSoonOverlay.parentNode.removeChild(comingSoonOverlay);
                            }
                            // ËøîÂõûÊ®ôÈ°åÁï´Èù¢
                            resetGame();
                            showCoverPage();
                        }, 500);
                    });
                }

                // Âª∂ÈÅ≤È°ØÁ§∫ÂΩàÁ™óÔºåÂâµÈÄ†Ê∑°ÂÖ•ÊïàÊûú
                setTimeout(() => {
                    comingSoonOverlay.style.opacity = '1';
                    comingSoonOverlay.querySelector('div[class*="scale-95"]').classList.remove('scale-95');
                }, 50);
            },

            // ÈáçË©¶Áï∂ÂâçÈóúÂç°
            retryLevel: function() {
                console.log("ÈáçË©¶Áï∂ÂâçÈóúÂç°");
                this.loadLevel(this.currentLevel);
            },

            // È°ØÁ§∫ÈÅäÊà≤ÈÄöÈóúÁï´Èù¢
            showGameComplete: function() {
                // ÈÄôË£°ÂèØ‰ª•ÂØ¶ÁèæÈÅäÊà≤ÈÄöÈóúÂæåÁöÑÁï´Èù¢
                alert("ÊÅ≠Âñú‰Ω†! Â∑≤ÂÆåÊàêÊâÄÊúâÈóúÂç°!");

                // ËøîÂõûÊ®ôÈ°åÁï´Èù¢
                resetGame();
                showCoverPage();
            }
        };

        // ‰∫ã‰ª∂Á≥ªÁµ± - ÈáçÊßãÁÇ∫Êõ¥ÈÄöÁî®ÁöÑÊ®°ÁµÑÂåñÁµêÊßã
        const eventSystem = {
            // ‰∫ã‰ª∂Â≠òÂÑ≤ÔºöÊåâÈ°ûÂûãÂàÜÈ°û
            events: {},

            // Âãï‰ΩúËôïÁêÜÂô®Ë®ªÂÜäË°®
            actionHandlers: {},

            // ÂàùÂßãÂåñ‰∫ã‰ª∂Á≥ªÁµ±
            init: function() {
                console.log("ÂàùÂßãÂåñ‰∫ã‰ª∂Á≥ªÁµ±");
                // Ê∏ÖÁ©∫‰∫ã‰ª∂ÂíåËôïÁêÜÂô®
                this.events = {};
                this.actionHandlers = {};

                // Ë®ªÂÜäÊ®ôÊ∫ñ‰∫ã‰ª∂È°ûÂûã
                this.registerEventType("turnStart");
                this.registerEventType("pieceMove");
                this.registerEventType("pieceCaptured");

                // Ë®ªÂÜäÊ®ôÊ∫ñÂãï‰ΩúËôïÁêÜÂô®
                this.registerActionHandler("spawnPiece", this.handleSpawnPieceAction);
                this.registerActionHandler("showMission", this.handleShowMissionAction);
                this.registerActionHandler("replacePiece", this.handleReplacePieceAction);
                // Â∑≤ÁßªÈô§Ë®ªÂÜäspawnAngelGundamËôïÁêÜÂô®

                console.log("‰∫ã‰ª∂Á≥ªÁµ±ÂàùÂßãÂåñÂÆåÊàê");
                return this;
            },

            // Ë®ªÂÜä‰∫ã‰ª∂È°ûÂûã
            registerEventType: function(eventType) {
                if (!this.events[eventType]) {
                    this.events[eventType] = [];
                }
                return this;
            },

            // Ê∏ÖÈô§ÊâÄÊúâ‰∫ã‰ª∂
            clearEvents: function() {
                for (const eventType in this.events) {
                    this.events[eventType] = [];
                }
                return this;
            },

            // ÂæûÈóúÂç°Êï∏ÊìöÂä†Ëºâ‰∫ã‰ª∂
            loadEventsFromLevel: function(levelEvents) {
                console.log("ÂæûÈóúÂç°Âä†Ëºâ‰∫ã‰ª∂");
                this.clearEvents();

                if (!levelEvents || levelEvents.length === 0) {
                    console.log("ÈóúÂç°Ê≤íÊúâÂÆöÁæ©‰∫ã‰ª∂");
                    return this;
                }

                levelEvents.forEach((event, index) => {
                    const success = this.registerEvent(event);
                    console.log(`Ë®ªÂÜä‰∫ã‰ª∂ ${index + 1}/${levelEvents.length}: ${success ? 'ÊàêÂäü' : 'Â§±Êïó'}`);
                });

                return this;
            },

            // Ë®ªÂÜäÂñÆÂÄã‰∫ã‰ª∂
            registerEvent: function(event) {
                if (!event || !event.type) {
                    console.error("ÁÑ°ÊïàÁöÑ‰∫ã‰ª∂ÂÆöÁæ©:", event);
                    return false;
                }

                // Á¢∫‰øù‰∫ã‰ª∂È°ûÂûãÂ∑≤Ë®ªÂÜä
                if (!this.events[event.type]) {
                    this.registerEventType(event.type);
                }

                // Ê™¢Êü•‰∫ã‰ª∂Âãï‰ΩúÊòØÂê¶ÊúâÊïà
                if (!event.action || !event.action.type) {
                    console.error("‰∫ã‰ª∂Áº∫Â∞ëÊúâÊïàÁöÑÂãï‰Ωú:", event);
                    return false;
                }

                // Á¢∫‰øùÂãï‰ΩúÈ°ûÂûãÂ∑≤Ë®ªÂÜäËôïÁêÜÂô®
                if (!this.actionHandlers[event.action.type]) {
                    console.warn(`Êú™Ë®ªÂÜäÁöÑÂãï‰ΩúÈ°ûÂûã '${event.action.type}', ‰ΩÜ‰ªçÊúÉË®ªÂÜä‰∫ã‰ª∂`);
                }

                // Ê∑ªÂä†‰∫ã‰ª∂
                this.events[event.type].push(event);
                return true;
            },

            // Ë®ªÂÜäÂãï‰ΩúËôïÁêÜÂô®
            registerActionHandler: function(actionType, handlerFunction) {
                if (typeof handlerFunction !== 'function') {
                    console.error(`Invalid handler for action type '${actionType}'`);
                    return this;
                }

                this.actionHandlers[actionType] = handlerFunction;
                return this;
            },

            // Ëß∏Áôº‰∫ã‰ª∂
            triggerEvent: function(eventType, context) {
                if (!eventType || !this.events[eventType]) {
                    console.log(`Ê≤°ÊúâÊâæÂà∞${eventType}Á±ªÂûãÁöÑ‰∫ã‰ª∂`);
                    return;
                }

                console.log(`Ëß∏Áôº‰∫ã‰ª∂È°ûÂûã: ${eventType}`, context || {});
                console.log(`ËØ•‰∫ã‰ª∂Á±ªÂûãÂ≠òÂú®${this.events[eventType].length}‰∏™‰∫ã‰ª∂Â§ÑÁêÜÁ®ãÂ∫è`);

                const eventsToRemove = [];

                this.events[eventType].forEach((event, index) => {
                    console.log(`Ê£ÄÊü•‰∫ã‰ª∂${index+1}ÁöÑÊù°‰ª∂:`, event.condition);
                    // Ê™¢Êü•‰∫ã‰ª∂Ê¢ù‰ª∂
                    if (this.checkEventCondition(event, context)) {
                        console.log(`‰∫ã‰ª∂${index+1}Êù°‰ª∂Êª°Ë∂≥, Âü∑Ë°åÂãï‰Ωú: ${event.action.type}`);
                        // Âü∑Ë°å‰∫ã‰ª∂Âãï‰Ωú
                        this.executeAction(event.action, context);

                        // Â¶ÇÊûú‰∫ã‰ª∂Âè™Ëß∏Áôº‰∏ÄÊ¨°ÔºåÊ®ôË®òÁÇ∫ÁßªÈô§
                        if (event.once) {
                            eventsToRemove.push(index);
                        }
                      } else {
                        console.log(`‰∫ã‰ª∂${index+1}Êù°‰ª∂‰∏çÊª°Ë∂≥, ÊúüÊúõteam=${event.condition.team}, pieceId=${event.condition.pieceId}, ‰ΩçÁΩÆ[${event.condition.row},${event.condition.col}]`);

                        let actualTeam = 'Êú™Áü•';
                        let actualPieceId = 'Êú™Áü•';

                        if (context) {
                            if (context.team) actualTeam = context.team;
                            else if (context.piece && context.piece.team) actualTeam = context.piece.team;
                            else if (context.capturedPiece && context.capturedPiece.team) actualTeam = context.capturedPiece.team;
                            else if (context.capturingPiece && context.capturingPiece.team) actualTeam = context.capturingPiece.team;

                            if (context.piece && context.piece.id) actualPieceId = context.piece.id;
                            else if (context.capturedPiece && context.capturedPiece.id) actualPieceId = context.capturedPiece.id;
                            else if (context.capturingPiece && context.capturingPiece.id) actualPieceId = context.capturingPiece.id;
                        }

                        console.log(`ÂÆûÈôÖteam=${actualTeam}, pieceId=${actualPieceId}, ‰ΩçÁΩÆ[${context ? context.row : undefined},${context ? context.col : undefined}]`);
                      }
                });

                // ÂæûÂæåÂêëÂâçÂà™Èô§Ê®ôË®òÁöÑ‰∫ã‰ª∂
                for (let i = eventsToRemove.length - 1; i >= 0; i--) {
                    this.events[eventType].splice(eventsToRemove[i], 1);
                }
            },

            // Ê™¢Êü•‰∫ã‰ª∂Ê¢ù‰ª∂
            checkEventCondition: function(event, context) {
                // Â¶ÇÊûúÊ≤íÊúâÊ¢ù‰ª∂ÔºåÂâáË¶ñÁÇ∫Ê¢ù‰ª∂ÊªøË∂≥
                if (!event.condition) return true;

                const condition = event.condition;

                // Ê¢ù‰ª∂ÊòØ‰∏ÄÂÄãÁâ©‰ª∂ÔºåÂåÖÂê´Â§öÂÄãÂ±¨ÊÄß‰ΩúÁÇ∫Ê¢ù‰ª∂
                if (typeof condition === 'object') {
                    let allConditionsMet = true;

                    // Ê™¢Êü•ÂõûÂêàÊï∏Ê¢ù‰ª∂
                    if ('turn' in condition) {
                        if (!gameState) return false;
                        if (gameState.turnCount !== condition.turn) {
                            allConditionsMet = false;
                        }
                    }

                    // Ê™¢Êü•Èöä‰ºçÊ¢ù‰ª∂
                    if ('team' in condition) {
                        // Ê™¢Êü•ÊâÄÊúâÂèØËÉΩÁöÑÈöä‰ºç‰ΩçÁΩÆ
                        let teamMatched = false;
                        if (context) {
                            if (context.team === condition.team) {
                                teamMatched = true;
                            } else if (context.piece && context.piece.team === condition.team) {
                                teamMatched = true;
                            } else if (context.capturedPiece && context.capturedPiece.team === condition.team) {
                                teamMatched = true;
                            } else if (context.capturingPiece && context.capturingPiece.team === condition.team) {
                                teamMatched = true;
                            }
                        }

                        if (!teamMatched) {
                            allConditionsMet = false;
                        }
                    }

                    // Ê£ÄÊü•Ê£ãÂ≠êIDÊù°‰ª∂
                    if ('pieceId' in condition) {
                        // Ê™¢Êü•ÂêÑÁ®ÆÂèØËÉΩÁöÑÊ£ãÂ≠êID‰ΩçÁΩÆ
                        let pieceIdMatched = false;
                        if (context) {
                           // ÂØπ‰∫é pieceCaptured ‰∫ã‰ª∂ÔºåÂè™Ê£ÄÊü• capturedPiece
                            if (event.type === 'pieceCaptured') {
                                // Âè™Ê£ÄÊü•Ë¢´ÊçïËé∑ÁöÑÊ£ãÂ≠êIDÔºå‰∏çÊ£ÄÊü•ÊîªÂáªÊñπID
                                if (context.capturedPiece && context.capturedPiece.id === condition.pieceId) {
                                    pieceIdMatched = true;
                                }
                            }
                        }

                        if (!pieceIdMatched) {
                            allConditionsMet = false;
                        }
                    }

                    // Ê™¢Êü•‰ΩçÁΩÆÊ¢ù‰ª∂
                    if ('row' in condition && 'col' in condition) {
                        if (!context || context.row !== condition.row || context.col !== condition.col) {
                            allConditionsMet = false;
                        }
                    }

                    // Ëá™Ë®ÇÊ¢ù‰ª∂ËôïÁêÜÂô®ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
                    if ('custom' in condition && typeof condition.custom === 'function') {
                        if (!condition.custom(context, gameState)) {
                            allConditionsMet = false;
                        }
                    }

                    return allConditionsMet;
                }

                // ÂÖ∂‰ªñÊ¢ù‰ª∂È°ûÂûãÁöÑËôïÁêÜÂèØ‰ª•Êì¥Â±ï...

                return true; // ÈªòË™çÊ¢ù‰ª∂ÊªøË∂≥
            },

            // Âü∑Ë°åÂãï‰Ωú
            executeAction: function(action, context) {
                if (!action || !action.type) {
                    console.error("ÁÑ°ÊïàÁöÑÂãï‰Ωú:", action);
                    return;
                }

                const handler = this.actionHandlers[action.type];

                if (!handler) {
                    console.error(`Êú™ÊâæÂà∞Âãï‰ΩúËôïÁêÜÂô®: ${action.type}`);
                    return;
                }

                try {
                    // ‰ΩøÁî®Á∂ÅÂÆöÁöÑthisË™øÁî®ËôïÁêÜÂô®
                    handler.call(this, action, context);
                } catch (error) {
                    console.error(`Âü∑Ë°åÂãï‰Ωú ${action.type} ÊôÇÁôºÁîüÈåØË™§:`, error);
                }
            },

            // ==== Âãï‰ΩúËôïÁêÜÂô® ====

            // ÁîüÊàêÊ£ãÂ≠êÂãï‰Ωú - Â¢ûÂº∑Áâà
            handleSpawnPieceAction: function(action, context) {
                console.log("Âü∑Ë°åÁîüÊàêÊ£ãÂ≠êÂãï‰Ωú:", action);
                const { pieceId, position, special, aimRow, aimCol } = action;

                if (!pieceId) {
                    console.error("ÁîüÊàêÊ£ãÂ≠êÂãï‰ΩúÁº∫Â∞ëÂøÖË¶ÅÂèÉÊï∏ pieceId:", action);
                    return;
                }

                // Â¶ÇÊûúÊèê‰æõ‰∫ÜpositionÔºåÁõ¥Êé•ÁîüÊàêÊ£ãÂ≠ê
                if (position && Array.isArray(position) && position.length === 2) {
                    // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÁâπÊÆäÊïàÊûú
                    if (special) {
                        this.spawnPieceWithSpecialEffect(pieceId, position, action, context);
                    } else {
                        this.spawnPiece(pieceId, position, context);
                    }
                    return;
                }

                // Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõpositionÔºåÂòóË©¶ÊâæÂà∞ÊúÄ‰Ω≥‰ΩçÁΩÆ
                if (typeof aimRow === 'number' && typeof aimCol === 'number') {
                    const targetPosition = [aimRow, aimCol];

                    // Ê£ÄÊü•ÁõÆÊ†á‰ΩçÁΩÆÊòØÂê¶Â∑≤Ë¢´Âç†Áî®
                    if (gameState.board[aimRow][aimCol] !== null) {
                        console.warn('Â∑≤Ë¢´‰ΩîÁî®:', targetPosition);
                        // ÁõÆÊ†á‰ΩçÁΩÆË¢´Âç†Áî®ÔºåÂØªÊâæÊõø‰ª£‰ΩçÁΩÆ
                        if (action.findBestPosition) {
                            const bestPosition = this.findBestPositionForPiece(pieceId, action);
                            if (bestPosition) {
                                console.log(`‰ΩçÁΩÆ [${aimRow},${aimCol}] Â∑≤Ë¢´‰ΩîÁî®ÔºåÊîπÁÇ∫‰ΩøÁî®ÊúÄ‰Ω≥‰ΩçÁΩÆ: [${bestPosition[0]},${bestPosition[1]}]`);
                                if (special) {
                                    this.spawnPieceWithSpecialEffect(pieceId, bestPosition, action, context);
                                } else {
                                    this.spawnPiece(pieceId, bestPosition, context);
                                }
                            } else {
                                console.error(`ÁÑ°Ê≥ïÁÇ∫ ${pieceId} ÊâæÂà∞ÂêàÈÅ©ÁöÑÁîüÊàê‰ΩçÁΩÆ`);
                            }
                        } else {
                            console.error(`ÁõÆÊ®ô‰ΩçÁΩÆ [${aimRow},${aimCol}] Â∑≤Ë¢´‰ΩîÁî®Ôºå‰∏îÊú™ÂïüÁî®Ëá™ÂãïÂ∞ãÊâæ‰ΩçÁΩÆ`);
                        }
                    } else {
                        // ÁõÆÊ†á‰ΩçÁΩÆÊú™Ë¢´Âç†Áî®ÔºåÁõ¥Êé•ÁîüÊàê
                        if (special) {
                            this.spawnPieceWithSpecialEffect(pieceId, targetPosition, action, context);
                        } else {
                            this.spawnPiece(pieceId, targetPosition, context);
                        }
                    }
                      return;
                }


                if (action.findBestPosition) {
                    const bestPosition = this.findBestPositionForPiece(pieceId, action);
                    if (bestPosition) {
                        if (special) {
                            this.spawnPieceWithSpecialEffect(pieceId, bestPosition, action, context);
                        } else {
                            this.spawnPiece(pieceId, bestPosition, context);
                        }
                    } else {
                        console.error(`ÁÑ°Ê≥ïÁÇ∫ ${pieceId} ÊâæÂà∞ÂêàÈÅ©ÁöÑÁîüÊàê‰ΩçÁΩÆ`);
                    }
                    return;
                }

                console.error("ÁîüÊàêÊ£ãÂ≠êÂãï‰ΩúÁº∫Â∞ë‰ΩçÁΩÆÂèÉÊï∏Ôºå‰∏îÊú™ÂïüÁî®Ëá™ÂãïÂ∞ãÊâæ‰ΩçÁΩÆ:", action);
            },

            // È°ØÁ§∫‰ªªÂãôÊèêÁ§∫Âãï‰Ωú
            handleShowMissionAction: function(action, context) {
                console.log("Âü∑Ë°åÈ°ØÁ§∫‰ªªÂãôÊèêÁ§∫Âãï‰Ωú:", action);
                const { text } = action;

                if (!text) {
                    console.error("‰ªªÂãôÊèêÁ§∫Âãï‰ΩúÁº∫Â∞ëÂøÖË¶ÅÂèÉÊï∏:", action);
                    return;
                }

                this.showMissionPopup(text);
            },

            // Ê∑ªÂä†ÊõøÊç¢Ê£ãÂ≠êÂä®‰ΩúÂ§ÑÁêÜÂô®
            handleReplacePieceAction: function(action, context) {
                console.log("ÊâßË°åÊõøÊç¢Ê£ãÂ≠êÂä®‰Ωú:", action);
                const { position, pieceId, row, col, targetPieceId, special } = action;
                
                // Á°ÆÂÆöË¶ÅÊõøÊç¢ÁöÑÊ£ãÂ≠ê‰ΩçÁΩÆ
                let targetRow, targetCol;

                // Â¶ÇÊûúÁõ¥Êé•Êèê‰æõ‰∫Ü‰ΩçÁΩÆ
                if (position && Array.isArray(position) && position.length === 2) {
                    [targetRow, targetCol] = position;
                }
                // Â¶ÇÊûúÊèê‰æõ‰∫ÜË°åÂàó
                else if (typeof row === 'number' && typeof col === 'number') {
                    targetRow = row;
                    targetCol = col;
                }
                // Â¶ÇÊûú‰∏ä‰∏ãÊñáÊèê‰æõ‰∫Ü‰ΩçÁΩÆ
                else if (context && typeof context.row === 'number' && typeof context.col === 'number') {
                    targetRow = context.row;
                    targetCol = context.col;
                }
                // ÊêúÁ¥¢Ê£ãÂ≠êID
                else if (targetPieceId) {
                    const foundPosition = this.findPiecePosition(targetPieceId);
                    if (foundPosition) {
                        [targetRow, targetCol] = foundPosition;
                    } else {
                        console.error(`Êú™ÊâæÂà∞ID‰∏∫ ${targetPieceId} ÁöÑÊ£ãÂ≠êÔºåÊó†Ê≥ïÊâßË°åÊõøÊç¢`);
                        return;
                    }
                } else {
                    console.error("ÊõøÊç¢Ê£ãÂ≠êÂä®‰ΩúÁº∫Â∞ëÊúâÊïà‰ΩçÁΩÆÂèÇÊï∞:", action);
                    return;
                }

                // È™åËØÅ‰ΩçÁΩÆÊúâÊïàÊÄß
                if (targetRow < 0 || targetRow >= BOARD_SIZE || targetCol < 0 || targetCol >= BOARD_SIZE) {
                    console.error(`Êó†ÊïàÁöÑÊõøÊç¢‰ΩçÁΩÆ: [${targetRow},${targetCol}]`);
                    return;
                }

                // ‰øùÂ≠òÂéü‰ΩçÁΩÆÊ£ãÂ≠ê‰ø°ÊÅØÔºåÁî®‰∫éÂêéÁª≠ÊõøÊç¢ÂíåÊïàÊûúÊòæÁ§∫
                const originalPiece = gameState.board[targetRow][targetCol];
                if (!originalPiece) {
                    console.warn(`‰ΩçÁΩÆ [${targetRow},${targetCol}] Ê≤°ÊúâÊ£ãÂ≠êÂèØÊõøÊç¢`);
                    // Â¶ÇÊûúÊ≤°ÊúâÂéüÊ£ãÂ≠êÔºåÂàôÁõ¥Êé•Âú®ËØ•‰ΩçÁΩÆÁîüÊàêÊñ∞Ê£ãÂ≠ê
                    if (special) {
                        this.spawnPieceWithSpecialEffect(pieceId, [targetRow, targetCol], action, context);
                    } else {
                        this.spawnPiece(pieceId, [targetRow, targetCol], context);
                    }
                    return;
                }

                // ‰ªéÊ£ãÁõò‰∏äÁßªÈô§ÂéüÊ£ãÂ≠ê
                gameState.board[targetRow][targetCol] = null;

                // Ëß¶ÂèëÊ£ãÂ≠êÁßªÈô§‰∫ã‰ª∂
                this.triggerEvent('pieceRemoved', {
                    piece: originalPiece,
                    row: targetRow,
                    col: targetCol
                });

                // ÁîüÊàêÊñ∞Ê£ãÂ≠êÂà∞Âêå‰∏Ä‰ΩçÁΩÆ
                if (special) {
                // ‰ΩøÁî®ÁâπÊïàÁîüÊàê
                    const replacementAction = {
                        ...action,
                        originalPiece: originalPiece // ‰º†ÈÄíÂéüÊ£ãÂ≠ê‰ø°ÊÅØ
                    };
                    this.spawnPieceWithSpecialEffect(pieceId, [targetRow, targetCol], replacementAction, context);
                } else {
                    // ÊôÆÈÄöÁîüÊàê
                    this.spawnPiece(pieceId, [targetRow, targetCol], context);
                }

                if (action.pieceId === 'fa_gundam') {
                    console.log("FA Gundam has been unlocked!");
                    Get_fa_gundam = 1;
                }
                
                // Êõ¥Êñ∞Ê£ãÁõòÊòæÁ§∫
                updateBoardDisplay();
            },

            // ËæÖÂä©ÂáΩÊï∞ÔºöÊü•ÊâæÊ£ãÂ≠ê‰ΩçÁΩÆ
            findPiecePosition: function(pieceId) {
                if (!gameState || !gameState.board) return null;

                // Âú®Ê£ãÁõò‰∏äÊü•ÊâæÊåáÂÆöIDÁöÑÊ£ãÂ≠ê
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.id === pieceId) {
                            return [row, col];
                        }
                    }
                }

                return null; // Êú™ÊâæÂà∞Ê£ãÂ≠ê
            },

            // Â∑≤ÁßªÈô§ÁîüÊàêÂ§©‰ΩøÈ´òÈÅîÁâπÊÆäÂãï‰ΩúËôïÁêÜÂô®

            // ==== Âãï‰ΩúÂØ¶ÁèæÂáΩÊï∏ ====

            // ÁîüÊàêÊ£ãÂ≠ê - ÂæûÈóúÂç°ÂÆöÁæ©ËÆÄÂèñÊ£ãÂ≠êÊï∏Êìö
            spawnPiece: function(pieceId, position, context) {
                if (!gameState || !BOARD_SIZE) {
                    console.error('ÈÅäÊà≤ÁãÄÊÖã‰∏çÂèØÁî®');
                    return;
                }

                const [row, col] = position;

                // Ê™¢Êü•‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà
                if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                    console.error('ÁÑ°ÊïàÁöÑÊ£ãÂ≠ê‰ΩçÁΩÆ:', position);
                    return;
                }

                // Ê™¢Êü•Ë©≤‰ΩçÁΩÆÊòØÂê¶ÁÇ∫Á©∫
                if (gameState.board[row][col] !== null) {
                    console.warn('ÁõÆÊ®ô‰ΩçÁΩÆÂ∑≤Ë¢´‰ΩîÁî®:', position);
                    return;
                }

                // ÂæûÁï∂ÂâçÈóúÂç°Áç≤ÂèñÊ£ãÂ≠êÂÆöÁæ©
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions) {
                    console.error(`ÁÑ°Ê≥ïÊâæÂà∞ÈóúÂç° ${levelManager.currentLevel} ÁöÑÊ©üÈ´îÂÆöÁæ©`);
                    return;
                }

                const levelPieceDefinitions = currentLevelData.pieceDefinitions;

                // Ê™¢Êü•Ê£ãÂ≠êÂÆöÁæ©ÊòØÂê¶Â≠òÂú®
                if (!levelPieceDefinitions[pieceId]) {
                    console.error(`Âú®ÈóúÂç° ${levelManager.currentLevel} ‰∏≠Êú™ÂÆöÁæ©ÁöÑÊ£ãÂ≠êID: ${pieceId}`);
                    return;
                }

                const pieceDefinition = levelPieceDefinitions[pieceId];

                // ÂâµÂª∫Ê£ãÂ≠êÂØ¶‰æã
                gameState.board[row][col] = {
                    id: pieceId,
                    team: pieceDefinition.team,
                    type: pieceDefinition.type,
                    moveType: pieceDefinition.moveType,
                    imgUrl: pieceDefinition.imgUrl,
                    hit: pieceDefinition.hit,
                    dodge: pieceDefinition.dodge,
                    bgmtype: pieceDefinition.bgmtype,
                    weapon_colour: pieceDefinition.weapon_colour,
                    crosshairType: pieceDefinition.crosshairType,
                    hasMoved: false
                };

                // Ëß∏ÁôºÊ£ãÂ≠êÁîüÊàê‰∫ã‰ª∂
                this.triggerEvent('pieceSpawned', {
                    piece: gameState.board[row][col],
                    row: row,
                    col: col
                });

                // Êõ¥Êñ∞Ê£ãÁõ§È°ØÁ§∫
                updateBoardDisplay();
            },

            // Âú® spawnPieceWithSpecialEffect ÂáΩÊï∞‰∏≠Ê∑ªÂä†ÈíàÂØπÊõøÊç¢ÁöÑÂ§ÑÁêÜ
            spawnPieceWithSpecialEffect: function(pieceId, position, action, context) {
                console.log("‰ΩøÁî®ÁâπÊÆäÊïàÊûúÁîüÊàêÊ£ãÂ≠ê:", pieceId, "Âú®‰ΩçÁΩÆ", position);

                // Ëé∑ÂèñÂùêÊ†á‰ΩçÁΩÆÁöÑÂ≠óÊØçÊï∞Â≠óË°®Á§∫ÔºàÂ¶ÇA1„ÄÅB2Á≠âÔºâ
                const row = position[0];
                const col = position[1];
                const colLetter = String.fromCharCode(65 + col); // A, B, C...
                const rowNumber = 8 - row; // 1, 2, 3...
                const positionText = `${colLetter}${rowNumber}`;

                // ‰ªéÂΩìÂâçÂÖ≥Âç°Ëé∑ÂèñÊ£ãÂ≠êÂÆö‰πâ
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions || !currentLevelData.pieceDefinitions[pieceId]) {
                    console.error(`Êó†Ê≥ïÊâæÂà∞Ê£ãÂ≠ê ${pieceId} ÁöÑÂÆö‰πâ`);
                    return;
                }

                const pieceDefinition = currentLevelData.pieceDefinitions[pieceId];

                // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊõøÊç¢Êìç‰Ωú
                const isReplacement = action.originalPiece !== undefined;
                let replacementHTML = '';

                if (isReplacement) {
                    // Ê∑ªÂä†ÂéüÊ£ãÂ≠ê‰ø°ÊÅØÁöÑÊòæÁ§∫
                    const originalPiece = action.originalPiece;
                    replacementHTML = `
                    <div class="flex justify-center items-center space-x-4 my-4">
                        <div class="flex flex-col items-center">
                            <img src="${originalPiece.imgUrl}" alt="${originalPiece.type}" class="w-16 h-16 object-contain mb-2">
                            <span class="text-sm text-gray-400">ÂéüÂßãÊ£ãÂ≠ê</span>
                        </div>
                        <div class="flex items-center text-yellow-500">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                            </svg>
                        </div>
                        <div class="flex flex-col items-center">
                            <img src="${pieceDefinition.imgUrl}" alt="${pieceDefinition.type}" class="w-16 h-16 object-contain mb-2">
                            <span class="text-sm text-gray-400">Êñ∞Ê£ãÂ≠ê</span>
                        </div>
                    </div>
                    `;
                }

                // ÂàõÂª∫ÁâπÊÆäÊïàÊûúHTML
                const specialEffectHTML = `
                <div id="special-piece-confirm-overlay" class="angel-confirm-overlay">
                    <div class="angel-confirm-card" style="position: absolute; top: 10%; left: 50%; transform: translateX(-50%);">
                        <div class="angel-header">
                            <img src="${pieceDefinition.imgUrl}" alt="${pieceDefinition.type}" class="angel-image">
                        </div>
                        <h2 class="angel-title">${action.title || pieceDefinition.type + 'Â∑≤Âá∫Áé∞ÔºÅ'}</h2>
                        <p class="angel-desc">${action.description || (isReplacement ? 'Ê£ãÂ≠êÂ∑≤Ë¢´ÊõøÊç¢Ôºå‰ΩçÁΩÆÂú®' : '‰∏ÄÂè∞Êñ∞ÁöÑÊú∫‰ΩìÂá∫Áé∞Âú®ÊàòÂú∫‰∏äÔºå‰ΩçÁΩÆÂú®')}<span style="color:#5D5CDE;font-weight:bold;">${positionText}</span>„ÄÇ</p>

                        ${replacementHTML}

                        <div class="angel-stats">
                            <div class="angel-stat angel-stat-type">
                                <span class="stat-label">Á±ªÂûã</span>
                                <span class="stat-value">${this.getMoveTypeText(pieceDefinition.moveType)}</span>
                            </div>
                            <div class="angel-stat angel-stat-hit">
                                <span class="stat-label">ÂëΩ‰∏≠</span>
                                <span class="stat-value">${pieceDefinition.hit}</span>
                            </div>
                            <div class="angel-stat angel-stat-dodge">
                                <span class="stat-label">ÂõûÈÅø</span>
                                <span class="stat-value">${pieceDefinition.dodge}</span>
                            </div>
                        </div>

                        <button id="special-piece-confirm-btn" class="angel-confirm-btn">${action.buttonText || 'Á°ÆËÆ§'}</button>
                    </div>
                </div>
                `;

                // Ê∑ªÂä†ÁâπÊÆäÊïàÊûúË¶ñÁ™óÂà∞È†ÅÈù¢
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = specialEffectHTML;
                document.body.appendChild(tempDiv.firstElementChild);

                // Áç≤ÂèñÁ¢∫Ë™çË¶ñÁ™óÂÖÉÁ¥†
                const confirmOverlay = document.getElementById('special-piece-confirm-overlay');
                const confirmBtn = document.getElementById('special-piece-confirm-btn');

                // Êö´ÂÅúÈÅäÊà≤Êìç‰Ωú
                const disableGameInteraction = () => {
                    const chessCells = document.querySelectorAll('.chess-cell');
                    chessCells.forEach(cell => {
                        cell.style.pointerEvents = 'none';
                    });
                };

                // ÊÅ¢Âæ©ÈÅäÊà≤Êìç‰Ωú
                const enableGameInteraction = () => {
                    const chessCells = document.querySelectorAll('.chess-cell');
                    chessCells.forEach(cell => {
                        cell.style.pointerEvents = 'auto';
                    });
                };

                // È°ØÁ§∫Á¢∫Ë™çË¶ñÁ™óÂâçÊö´ÂÅúÈÅäÊà≤Êìç‰Ωú
                disableGameInteraction();

                // È°ØÁ§∫Á¢∫Ë™çË¶ñÁ™ó
                confirmOverlay.classList.add('show');
                setTimeout(() => {
                    const card = confirmOverlay.querySelector('.angel-confirm-card');
                    if (card) card.style.opacity = '1';
                }, 50);

                // Ë®≠ÁΩÆÁ¢∫Ë™çÊåâÈàïÈªûÊìä‰∫ã‰ª∂
                const handleConfirmClick = () => {
                    // Èö±ËóèÁ¢∫Ë™çË¶ñÁ™ó
                    confirmOverlay.classList.remove('show');
                    const card = confirmOverlay.querySelector('.angel-confirm-card');
                    if (card) card.style.opacity = '0';

                    // ÊÅ¢Âæ©ÈÅäÊà≤Êìç‰Ωú
                    enableGameInteraction();

                    // ÂØ¶ÈöõÁîüÊàêÊ£ãÂ≠ê
                    this.spawnPiece(pieceId, position, context);

                    // Â¶ÇÊûúË®≠ÁΩÆ‰∫ÜÁ¢∫Ë™çÂæåÁöÑÂãï‰ΩúÔºåÂü∑Ë°åÂÆÉ
                    if (action.onConfirm) {
                        try {
                            action.onConfirm(context);
                        } catch (error) {
                            console.error("Âü∑Ë°åÁ¢∫Ë™çÂæåÂãï‰ΩúÂá∫ÈåØ:", error);
                        }
                    }

                    // ÁßªÈô§‰∫ã‰ª∂Áõ£ËÅΩÂô®ÂíåÂΩàÁ™ó
                    if (confirmBtn) {
                        confirmBtn.removeEventListener('click', handleConfirmClick);
                    }
                    setTimeout(() => {
                        if (confirmOverlay && confirmOverlay.parentNode) {
                            confirmOverlay.parentNode.removeChild(confirmOverlay);
                        }
                    }, 500);
                };

                // Ê∑ªÂä†Á¢∫Ë™çÊåâÈàïÈªûÊìä‰∫ã‰ª∂
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', handleConfirmClick);
                }
            },

            // Áç≤ÂèñÁßªÂãïÈ°ûÂûãÁöÑ‰∏≠ÊñáÂêçÁ®±
            getMoveTypeText: function(moveType) {
                switch(moveType) {
                    case PAWN: return "Ê≠•ÂÖµÂûã";
                    case ROOK: return "ÂüéÂ†°Âûã";
                    case KNIGHT: return "È®éÂ£´Âûã";
                    case BISHOP: return "‰∏ªÊïôÂûã";
                    case QUEEN: return "ÁöáÂêéÂûã";
                    case KING: return "ÂúãÁéãÂûã";
                    default: return "Êú™Áü•È°ûÂûã";
                }
            },

            // Â∞ãÊâæÊúÄ‰Ω≥‰ΩçÁΩÆÁîüÊàêÊ£ãÂ≠ê
            findBestPositionForPiece: function(pieceId, options) {
                console.log("Â∞ãÊâæÊúÄ‰Ω≥‰ΩçÁΩÆÁîüÊàêÊ£ãÂ≠ê:", pieceId);
                if (!gameState || !BOARD_SIZE) {
                    console.error('ÈÅäÊà≤ÁãÄÊÖã‰∏çÂèØÁî®');
                    return null;
                }

                // Áç≤ÂèñÊ£ãÂ≠êÈöä‰ºç‰ª•Á¢∫ÂÆöÊêúÁ¥¢ÊñπÂêë
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions || !currentLevelData.pieceDefinitions[pieceId]) {
                    console.error(`ÁÑ°Ê≥ïÊâæÂà∞Ê£ãÂ≠ê ${pieceId} ÁöÑÂÆöÁæ©`);
                    return null;
                }

                const pieceTeam = currentLevelData.pieceDefinitions[pieceId].team;

                // Ê†πÊìöÈöä‰ºçÂíåÈÅ∏È†ÖÁ¢∫ÂÆöÂÑ™ÂÖàÊêúÁ¥¢ÁöÑË°å
                let preferredRow = options && options.preferredRow !== undefined ? options.preferredRow : null;

                if (preferredRow === null) {
                    // Â¶ÇÊûúÊ≤íÊúâÊåáÂÆöÔºåËóçÈöäÂÑ™ÂÖàÂú®Á¨¨‰∏ÉË°åÔºåÁ¥ÖÈöäÂÑ™ÂÖàÂú®Á¨¨‰∫åË°å
                    preferredRow = pieceTeam === BLUE ? 6 : 1;
                }

                // Âú®ÂÑ™ÂÖàË°åÂ∞ãÊâæÁ©∫‰Ωç
                let availablePositions = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (!gameState.board[preferredRow][col]) {
                        availablePositions.push([preferredRow, col]);
                    }
                }

                // Â¶ÇÊûúÂÑ™ÂÖàË°åÊúâÁ©∫‰ΩçÔºåÈÅ∏ÊìáË∑ùÈõ¢‰∏≠Â§ÆÊúÄËøëÁöÑ
                if (availablePositions.length > 0) {
                    const centerCol = 3.5; // ‰∏≠Èñì‰ΩçÁΩÆÂú®3Âíå4‰πãÈñì
                    let bestPosition = null;
                    let minDistance = Infinity;

                    for (const pos of availablePositions) {
                        const col = pos[1];
                        const distance = Math.abs(col - centerCol);

                        if (distance < minDistance) {
                            minDistance = distance;
                            bestPosition = pos;
                        }
                    }

                    return bestPosition;
                }

                // Â¶ÇÊûúÂÑ™ÂÖàË°åÊ≤íÊúâÁ©∫‰ΩçÔºåÂú®Êï¥ÂÄãÊ£ãÁõ§‰∏äÂ∞ãÊâæÊúÄÈÅ©ÂêàÁöÑ‰ΩçÁΩÆ
                const centerRow = 3.5;
                const centerCol = 3.5;
                let closestPosition = null;
                let minDistance = Infinity;

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (!gameState.board[row][col]) {
                            // Ë®àÁÆóÂà∞‰∏≠ÂøÉÁöÑË∑ùÈõ¢
                            const distance = Math.sqrt(
                                Math.pow(row - centerRow, 2) +
                                Math.pow(col - centerCol, 2)
                            );

                            if (distance < minDistance) {
                                minDistance = distance;
                                closestPosition = [row, col];
                            }
                        }
                    }
                }

                return closestPosition;
            },

            // È°ØÁ§∫‰ªªÂãôÊèêÁ§∫Ê°Ü
            showMissionPopup: function(text) {
                const missionPopup = document.getElementById('mission-popup');
                const missionDesc = document.getElementById('mission-desc');

                if (!missionPopup || !missionDesc) {
                    console.error('‰ªªÂãôÊèêÁ§∫Ê°ÜÂÖÉÁ¥†‰∏çÂ≠òÂú®');
                    return;
                }

                // Ë®≠ÁΩÆÊñáÊú¨‰∏¶È°ØÁ§∫
                missionDesc.textContent = text;
                missionPopup.classList.add('show');

                // ‰∫îÁßíÂæåËá™ÂãïÈö±Ëóè
                setTimeout(() => {
                    missionPopup.classList.remove('show');
                }, 5000);
            }
        };

        // È°ØÁ§∫Â∫èÁ´†È†ÅÈù¢
        function showPrologue() {
            // Ê∑ªÂä†Â∫èÁ´†È†ÅÈù¢Âà∞DOM
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = prologueHTML;
            const prologueOverlay = tempDiv.firstElementChild;
            document.body.appendChild(prologueOverlay);

            // Ë®≠ÁΩÆÁπºÁ∫åÊåâÈàï‰∫ã‰ª∂
            const prologueContinueBtn = document.getElementById('prologue-continue-btn');
            if (prologueContinueBtn) {
                prologueContinueBtn.addEventListener('click', () => {
                    // Ê∑°Âá∫Â∫èÁ´†
                    prologueOverlay.style.opacity = '0';

                    // Âª∂ÈÅ≤ÂæåÁßªÈô§Â∫èÁ´†‰∏¶È°ØÁ§∫Á¨¨‰∏ÄÈóú
                    setTimeout(() => {
                        if (prologueOverlay.parentNode) {
                            prologueOverlay.parentNode.removeChild(prologueOverlay);
                        }

                        // ÂàùÂßãÂåñ‰∏¶È°ØÁ§∫Á¨¨‰∏ÄÈóú
                        if (levelManager) {
                            levelManager.loadLevel(1);
                        } else {
                            console.error('ÈóúÂç°ÁÆ°ÁêÜÂô®Êú™ÂàùÂßãÂåñ');
                            // ÂõûÈÄÄÂà∞ÈªòË™çË°åÁÇ∫
                            gameUI.style.display = 'block';
                            initializeGame();
                        }
                    }, 500);
                });
            }

            // È°ØÁ§∫Â∫èÁ´†ÔºàÊ∑°ÂÖ•ÊïàÊûúÔºâ
            setTimeout(() => {
                prologueOverlay.style.opacity = '1';
                const card = prologueOverlay.querySelector('div[class*="scale-95"]');
                if (card) card.classList.remove('scale-95');
            }, 50);
        }

        // Ë®≠ÁΩÆÈ†ÅÈù¢ÊåâÈàï‰∫ã‰ª∂
        function setupButtonEvents() {
            // Ë®≠ÁΩÆÁïåÈù¢
            document.getElementById('settings-cover-btn').onclick = function() {
                document.getElementById('settings-overlay').style.opacity = '1';
                document.getElementById('settings-overlay').style.pointerEvents = 'auto';
            };

            document.getElementById('settings-close-btn').onclick = function() {
                document.getElementById('settings-overlay').style.opacity = '0';
                document.getElementById('settings-overlay').style.pointerEvents = 'none';
            };
        }

        // Âú®DOMÂä†ËΩΩÂÆåÊàêÂêéÊ∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.addEventListener('DOMContentLoaded', function() {
            // ‰øùÂ≠òËøõÂ∫¶ÊåâÈíÆ
            const saveProgressBtn = document.getElementById('save-progress-btn');
            if (saveProgressBtn) {
                saveProgressBtn.addEventListener('click', saveProgress);
            }
    
            // ËΩΩÂÖ•ËøõÂ∫¶ÊåâÈíÆ
            const loadProgressBtn = document.getElementById('load-progress-btn');
            if (loadProgressBtn) {
                loadProgressBtn.addEventListener('click', loadProgress);
            }
        });

        // ÂæûURLÂä†ËºâÈóúÂç°
        async function loadLevelsFromURL(url) {
            // È°ØÁ§∫Âä†ËºâÁïåÈù¢
            const loadingOverlay = document.getElementById('csv-loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                // Áç≤ÂèñÂíåËß£ÊûêCSVÊï∏Êìö
                const csvText = await fetchCSVFromURL(url);
                const csvEntries = parseCSV(csvText);
                const levels = createLevelsFromCSV(csvEntries);

                // ÊõøÊèõÂÖ®Â±ÄÈóúÂç°Êï∏Êìö
                if (levels.length > 0) {
                    window.levelData = levels;
                    console.log("ÊàêÂäüÂæûURLÂä†ËºâÈóúÂç°Êï∏Êìö");
                    return true;
                } else {
                    throw new Error("Ëß£ÊûêCSVÂæåÊ≤íÊúâÁç≤ÂæóÊúâÊïàÁöÑÈóúÂç°Êï∏Êìö");
                }
            } catch (error) {
                console.error("Âä†ËºâÈóúÂç°Êï∏ÊìöÂ§±Êïó:", error);
                // È°ØÁ§∫ÈåØË™§Ë®äÊÅØ
                document.getElementById('csv-loading-message').textContent = "Âä†ËºâÈóúÂç°Êï∏ÊìöÂ§±Êïó: " + error.message;
                // 5ÁßíÂæåÈö±ËóèÂä†ËºâÁïåÈù¢
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 5000);
                return false;
            } finally {
                // ÂæûÈÄôË£°ÁßªÈô§Âä†ËºâÁïåÈù¢È°ØÁ§∫ÔºåÂú®ÊàêÂäüÊÉÖÊ≥Å‰∏ãË™øÁî®ËÄÖÊúÉËôïÁêÜ
            }
        }

        // Main code
        // Set up cover page
        setupSpaceBackground(document.getElementById('cover-space-bg'));

        // Set up buttons
        setupButtonEvents();

        // Update document title with loading time
        document.title = `Ë∂ÖÁ¥öÊ©üÊ¢∞‰∫∫Â§ßÊà∞Chess - ${Date.now() - window.gameLoadStartTime}ms`;

        // ÂñÆ‰∫∫ÈÅäÊà≤ÊåâÈàï‰∫ã‰ª∂
        singleplayerBtn.onclick = async function(e) {
            // Èò≤Ê≠¢‰∫ã‰ª∂ÂÜíÊ≥°
            e.preventDefault();
            e.stopPropagation();

            // Êí≠Êîæ‰ªãÁ¥πÈü≥Ê®Ç
            playIntroMusic();

            // ÊåáÂÆöCSV URL
            const csvUrl = "./stages/SRWCStage01.csv";

            // Èö±ËóèÂ∞ÅÈù¢È†ÅÈù¢
            coverPage.classList.add('hide');

            // È°ØÁ§∫Âä†ËºâÁïåÈù¢
            document.getElementById('csv-loading-overlay').style.display = 'flex';
            document.getElementById('csv-loading-message').textContent = "Ê≠£Âú®ÂæûÂ§ñÈÉ®Êï∏ÊìöÊ∫êÁç≤ÂèñÈóúÂç°‰ø°ÊÅØ...";

            try {
                // Âä†ËºâÈóúÂç°Êï∏Êìö
                const success = await loadLevelsFromURL(csvUrl);

                if (success) {
                    // Êõ¥Êñ∞Âä†ËºâÊ∂àÊÅØ
                    document.getElementById('csv-loading-message').textContent = "Ê≠£Âú®È†êËºâÂúñÁâáË≥áÊ∫ê...";

                    // È†êËºâÂúñÁâá
                    console.log("ÈñãÂßãÈ†êËºâÂúñÁâá...");
                    const imagesToLoad = getAllImageURLsFromLevelData();
                    await preloadImages(imagesToLoad);

                    // Èö±ËóèÂä†ËºâÁïåÈù¢
                    document.getElementById('csv-loading-overlay').style.display = 'none';

                    // ÂâµÂª∫ÈÅäÊà≤Ê£ãÁõ§
                    createBoard();

                    // ÂàùÂßãÂåñ‰∫ã‰ª∂Á≥ªÁµ±
                    if (typeof eventSystem !== 'undefined' && typeof eventSystem.init === 'function') {
                        eventSystem.init();
                    }

                    // È°ØÁ§∫Â∫èÁ´†
                    showPrologue();
                } else {
                    throw new Error("Âä†ËºâÈóúÂç°Êï∏ÊìöÂ§±Êïó");
                }
            } catch (error) {
                console.error("ËôïÁêÜÂ§±Êïó:", error);

                // È°ØÁ§∫ÈåØË™§Ê∂àÊÅØ
                const loadingMessage = document.getElementById('csv-loading-message');
                if (loadingMessage) loadingMessage.textContent = "ÈåØË™§: " + error.message;

                // Âª∂ÈÅ≤ÂæåËøîÂõû‰∏ªÁï´Èù¢
                setTimeout(() => {
                    document.getElementById('csv-loading-overlay').style.display = 'none';
                    coverPage.classList.remove('hide');
                }, 3000);
            }

            return false;
        };
    </script>
</body>
</html>
