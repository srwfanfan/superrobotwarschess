<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://qph.cf2.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content; report-uri https://www.quora.com/poe_api/csp_report_3RD_PARTY_POST; report-to csp-endpoint;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超級機械人大戰Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // 添加全局計時器，記錄頁面加載開始時間
        window.gameLoadStartTime = Date.now();

        // 全局錯誤處理函數
        window.onerror = function(message, source, lineno, colno, error) {
            // 返回false讓瀏覽器繼續顯示錯誤
            return false;
        };

        // 安全的innerHTML設置函數
        function safeSetInnerHTML(element, html) {
            if (!element) {
                return false;
            }
            element.innerHTML = html;
            return true;
        }

        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'primary': '#5D5CDE',
                        'board-light': '#f0d9b5',
                        'board-dark': '#b58863',
                        'highlight': 'rgba(93, 92, 222, 0.5)',
                        'valid-move': 'rgba(0, 255, 0, 0.3)',
                        'attack-move': 'rgba(255, 0, 0, 0.3)'
                    }
                }
            }
        }
    </script>
    <style>
        /* Cover Page Styles */
        .cover-page {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #000428, #004e92);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 5vh;
            transition: 0.5s ease opacity;
        }

        .cover-page.hide {
            opacity: 0;
            pointer-events: none;
        }

        .cover-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: white;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            to { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(93, 92, 222, 0.6); }
        }

        .cover-buttons {
            display: grid;
            grid-template: auto auto / 1fr 1fr;
            gap: 1rem;
            width: 100%;
            max-width: 500px;
        }

        .cover-button {
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .cover-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Space Background */
        .space-bg {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 1px;
            height: 1px;
            background: white;
            border-radius: 50%;
        }

        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 50%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transform-origin: right center;
            animation: shoot 3s ease-out infinite;
        }

        @keyframes shoot {
            0% {
                opacity: 0;
                transform: translateX(0) rotate(0deg);
            }
            15% {
                opacity: 1;
            }
            30% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateX(-200px) rotate(0deg);
            }
        }

        /* Game Board Styles */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            background-image: url('https://i.imgur.com/po1uZL5.png');
            background-size: cover;
            background-position: center;
        }

        .chess-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }

        .chess-board .light, .chess-board .dark,
        .dark .chess-board .light, .dark .chess-board .dark {
            background-color: transparent;
        }

        .piece-img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            position: relative;
            z-index: 10;
            transition: all 0.2s ease;
        }

        .piece-overlay {
            position: absolute;
            inset: 0;
            z-index: 11;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none;
        }

        .blue-overlay {
            background-color: rgba(0, 0, 255, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
        }

        .red-overlay {
            background-color: rgba(255, 0, 0, 0.15);
            mask-image: url('https://i.imgur.com/po1uZL5.png');
            -webkit-mask-image: url('https://i.imgur.com/po1uZL5.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-position: center;
            -webkit-mask-position: center;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            transform: scaleX(-1);
        }

        .valid-move-indicator {
            position: absolute;
            width: 40%;
            height: 40%;
            border-radius: 50%;
            opacity: 0.7;
            z-index: 5;
        }

        .coordinate {
            position: absolute;
            font-size: 0.7rem;
            opacity: 0;
            z-index: 5;
            display: none;
        }

        .top-left {
            top: 2px;
            left: 2px;
        }

        .selected {
            animation: blink 1s infinite;
            box-shadow: inset 0 0 0 4px rgba(93, 92, 222, 0.7);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Victory Overlay */
        .victory-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10vh;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            visibility: hidden;
        }

        .victory-overlay.show {
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }

        .victory-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            max-width: 90%;
            width: 600px;
            transform: scale(0.8);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .victory-overlay.show .victory-card {
            transform: scale(1);
        }

        .victory-card::before {
            content: '';
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            background: linear-gradient(
                135deg,
                transparent,
                rgba(255, 255, 255, 0.05),
                transparent,
                transparent
            );
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% {
                left: -100%;
                top: -100%;
            }
            50%, 100% {
                left: 100%;
                top: 100%;
            }
        }

        .victory-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px currentColor;
            animation: pulse 2s infinite;
        }

        .blue-victory {
            color: #4169E1;
            background: linear-gradient(135deg, #000428, #004e92);
        }

        .blue-victory .victory-title {
            color: #4169E1;
        }

        .red-victory {
            color: #DC143C;
            background: linear-gradient(135deg, #16222A, #3A1C71);
        }

        .red-victory .victory-title {
            color: #DC143C;
        }

        .victory-message {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: white;
        }

        .victory-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(-20px);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
            50% {
                opacity: 0.8;
                text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
        }

        .victory-reset {
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .victory-reset:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .victory-confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            opacity: 0.7;
            animation: confetti-fall linear forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh)) rotate(90deg);
                opacity: 0;
            }
        }

        /* Combat Mini-Game Styles */
        .combat-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            padding-top: 20px;
        }

        .combat-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 25px rgba(93, 92, 222, 0.8);
            cursor: default;
        }

        .combat-info-panel {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 800px;
            height: auto;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 8px;
            border: 2px solid #5D5CDE;
            box-shadow: 0 0 15px rgba(93, 92, 222, 0.6);
            overflow: hidden;
            margin-bottom: 10px;
        }

        .attacker-info, .defender-info {
            display: flex;
            align-items: center;
            padding: 1.5% 2%;
            position: relative;
            height: 24%;
            box-sizing: border-box;
        }

        .attacker-info {
            background: linear-gradient(to bottom, rgba(255,0,85,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .defender-info {
            background: linear-gradient(to top, rgba(0,255,200,0.3) 0%, rgba(10,10,30,0) 100%);
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .unit-image {
            height: 20%;
            width: 20%;
            object-fit: contain;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.7));
        }

        .unit-stats {
            display: flex;
            flex-direction: column;
            margin: 0 10px;
            color: white;
        }

        .unit-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        .stat-bar {
            width: 150px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            margin: 3px 0;
            overflow: hidden;
            position: relative;
        }

        .hit-stat {
            background: linear-gradient(90deg, #FF1493 0%, #FF69B4 100%);
        }

        .dodge-stat {
            background: linear-gradient(90deg, #00CED1 0%, #40E0D0 100%);
        }

        .attacker-role, .defender-role {
            position: absolute;
            top: -40px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .attacker-role {
            left: 10px;
            background: linear-gradient(90deg, #FF1493 0%, #C71585 100%);
        }

        .defender-role {
            right: 10px;
            background: linear-gradient(90deg, #20B2AA 0%, #5F9EA0 100%);
        }

        .attacker-instruction, .defender-instruction {
            position: absolute;
            bottom: 10px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 10;
            width: 45%;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .attacker-instruction {
            left: 10px;
        }

        .defender-instruction {
            right: 10px;
        }

        .space-background {
            position: absolute;
            inset: 0;
            background: rgba(85, 85, 85, 0.05); /* 純灰色背景，5%透明度 */
            overflow: hidden;
        }

        .combat-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .timer {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            background: linear-gradient(135deg, #ff0099, #493240);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,0,153,0.5);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }

        .crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -50%);
        }

        .crosshair-horizontal, .crosshair-vertical {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0) 100%);
        }

        .crosshair-horizontal {
            top: 50%;
            left: 0;
            height: 4px;
            width: 100%; /* 添加此行，确保水平线占满容器宽度 */
            transform: translateY(-50%);
        }

        .crosshair-vertical {
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            transform: translateX(-50%);
        }

        .crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: rgba(255, 20, 147, 0.5);
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
            animation: pulse 1.5s infinite;
            width: 10px; /* 添加此行，给内圆一个默认宽度 */
            height: 10px; /* 添加此行，给内圆一个默认高度 */
        }

        .defender {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 8;
            transition: top 0.05s linear, left 0.05s linear;
        }

        .defender img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(0,255,200,0.7));
        }

        .defender-target {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px dashed rgba(0, 255, 200, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 7;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 10px rgba(0,255,200,0.5);
            animation: targetPulse 1.5s infinite;
        }

        @keyframes targetPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(0.8); }
        }

        .laser {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,20,147,0.5) 0%, rgba(255,20,147,1) 50%, rgba(255,20,147,0.5) 100%);
            transform-origin: center left;
            z-index: 9;
            opacity: 0;
            animation: laser-pulse 0.3s ease-out;
            box-shadow: 0 0 10px #FF1493, 0 0 20px #FF1493;
            height: 0.625%;
        }

        .laser-glow {
            position: absolute;
            background: rgba(255,20,147,0.1);
            transform-origin: center left;
            z-index: 8;
            opacity: 0;
            animation: laser-glow 0.5s ease-out;
            filter: blur(10px);
            height: 2.5%;
        }

        @keyframes laser-pulse {
            0% { opacity: 0.7; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes laser-glow {
            0% { opacity: 0.3; transform: scale(1, 3); }
            50% { opacity: 0.5; transform: scale(1, 5); }
            100% { opacity: 0; transform: scale(1, 2); }
        }

        .explosion {
            position: absolute;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,105,180,0.8) 30%, rgba(255,20,147,0.6) 70%, rgba(0,0,0,0) 100%);
            z-index: 20;
            transform: translate(-50%, -50%);
            animation: explode 0.6s forwards;
            box-shadow: 0 0 30px #FF1493, 0 0 60px #FF1493;
        }

        @keyframes explode {
            0% { width: 0; height: 0; opacity: 1; }
            70% { opacity: 1; }
            100% { width: 31.25%; height: 31.25%; opacity: 0; }
        }

        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            z-index: 19;
            opacity: 1;
            box-shadow: 0 0 5px currentColor;
        }

        .combat-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 0 30px rgba(255,20,147,0.7);
            text-shadow: 0 0 5px #fff, 0 0 10px #ff0099;
        }

        .combat-result.show {
            opacity: 1;
            animation: resultPulse 2s infinite;
        }

        @keyframes resultPulse {
            0% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
            50% { box-shadow: 0 0 50px rgba(255,20,147,1); }
            100% { box-shadow: 0 0 30px rgba(255,20,147,0.7); }
        }

        /* Level System Styles */
        .level-info-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 400;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            overflow-y: auto;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .level-info-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .level-info-card {
            background: linear-gradient(135deg, #000428, #004e92);
            max-width: 800px;
            width: 90%;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(93, 92, 222, 0.5);
            overflow: hidden;
            transform: translateY(-20px);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white;
            transform: scale(0.7);
            font-size: 70%;
        }

        .level-info-overlay.show .level-info-card {
            transform: translateY(0);
        }

        .level-header {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            position: relative;
        }

        .level-title {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: left;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 10px rgba(93, 92, 222, 0.8);
        }

        .level-subtitle {
            font-size: 1.1rem;
            text-align: left;
            color: #ccc;
        }

        .level-content {
            padding: 20px;
        }

        .level-image-container {
            width: 100%;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .level-image {
            max-width: 80%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .level-story {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .level-story-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .level-story-content {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ddd;
        }

        .level-conditions {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .level-conditions-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .victory-condition {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            color: #4ADE80;
        }

        .defeat-condition {
            display: flex;
            align-items: center;
            color: #F87171;
        }

        .condition-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }

        .level-footer {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        .start-level-btn {
            background: linear-gradient(135deg, #5D5CDE, #4338CA);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 8px 20px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.4);
        }

        .start-level-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(93, 92, 222, 0.6);
        }

        /* Event Dialog */
        .event-dialog {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5D5CDE;
            border-radius: 10px;
            padding: 15px;
            z-index: 350;
            display: none;
            color: white;
            box-shadow: 0 0 20px rgba(93, 92, 222, 0.5);
        }

        .dialog-character {
            font-weight: bold;
            margin-bottom: 8px;
            color: #5D5CDE;
        }

        .dialog-content {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .dialog-next {
            text-align: right;
            font-style: italic;
            color: #ccc;
            font-size: 0.9rem;
        }

        /* Mission Popup */
        .mission-popup {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-left: 4px solid #5D5CDE;
            padding: 10px 15px;
            color: white;
            border-radius: 5px;
            z-index: 300;
            max-width: 80%;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mission-popup.show {
            opacity: 1;
        }

        .mission-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }

        .mission-title i {
            margin-right: 8px;
            color: #5D5CDE;
        }

        .mission-desc {
            font-size: 0.9rem;
            color: #ddd;
        }

        /* Angel Gundam Confirm */
        .angel-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .angel-confirm-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .angel-confirm-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            transition: transform 0.5s ease, opacity 0.5s ease;
            opacity: 0;
            position: relative;
            overflow: hidden;
        }

        .angel-confirm-overlay.show .angel-confirm-card {
            transform: translateY(0);
            opacity: 1;
        }

        .angel-confirm-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0) 70%);
            animation: angel-pulse 3s infinite;
        }

        @keyframes angel-pulse {
            0% { opacity: 0.1; }
            50% { opacity: 0.3; }
            100% { opacity: 0.1; }
        }

        .angel-header {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .angel-image {
            width: 120px;
            height: 120px;
            object-fit: contain;
            animation: angel-float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.7));
        }

        @keyframes angel-float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        .angel-title {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .angel-desc {
            font-size: 1.2rem;
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .angel-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .angel-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #ccc;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .angel-stat-hit .stat-value {
            color: #FF69B4;
        }

        .angel-stat-dodge .stat-value {
            color: #40E0D0;
        }

        .angel-stat-type .stat-value {
            color: #9370DB;
            font-size: 1.2rem;
        }

        .angel-confirm-btn {
            background: linear-gradient(135deg, #5D5CDE, #4338CA);
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 12px 40px;
            border-radius: 50px;
            border: none;
            display: block;
            margin: 0 auto;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .angel-confirm-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(45deg);
            animation: angel-btn-shine 3s infinite;
        }

        @keyframes angel-btn-shine {
            0% { left: -100%; }
            30%, 100% { left: 100%; }
        }

        .angel-confirm-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        /* Settings */
        .stars-bg {
            background-image:
                radial-gradient(2px 2px at 20px 30px, #eee, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 90px 40px, #ddd, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 160px 120px, #fff, rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 200px 200px;
            animation: stars-scrolling 8s linear infinite;
            opacity: 0.6;
        }

        @keyframes stars-scrolling {
            from {
                background-position: 0 0;
            }
            to {
                background-position: 0 200px;
            }
        }

        .animation-delay-500 {
            animation-delay: 500ms;
        }

        /* Reset Confirm Dialog */
        .reset-confirm {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1002;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .reset-confirm.show {
            opacity: 1;
            pointer-events: auto;
        }

        .reset-dialog {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            max-width: 90%;
            width: 400px;
            text-align: center;
        }

        .reset-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
        }

        .reset-message {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            color: #555;
        }

        .reset-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .reset-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .confirm-btn {
            background: #5D5CDE;
            color: white;
        }

        .confirm-btn:hover {
            background: #4A49B0;
        }

        .cancel-btn {
            background: #f3f4f6;
            color: #333;
        }

        .cancel-btn:hover {
            background: #e5e7eb;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .cover-title {
                font-size: 2rem;
            }

            .cover-buttons {
                max-width: 250px;
            }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        /* Turn Indicator */
        .turn-indicator {
            width: 20px;
            height: 20px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
        }

        /* Network Status */
        #network-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50;
        }

        /* Loader */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #5D5CDE;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* CSV加載提示框樣式 */
        .csv-loading-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .csv-loading-card {
            background: linear-gradient(135deg, #000428, #004e92);
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            width: 400px;
            text-align: center;
            color: white;
        }

        .csv-loading-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .csv-loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }

        /* 添加新的攻擊類型指示器樣式 */
        .attack-type-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            z-index: 15;
        }

        .attack-type-1 {
            background-color: rgba(255, 0, 0, 0.7);
        }

        .attack-type-2 {
            background-color: rgba(0, 0, 255, 0.7);
        }

        .attack-type-3 {
            background-color: rgba(0, 255, 0, 0.7);
        }

        /* 回合转换提示样式 */
        .turn-transition-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .turn-transition-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .turn-transition-card {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 50, 0.8));
            border-radius: 15px;
            padding: 30px 60px;
            transform: scale(0.8) translateY(-30px);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .turn-transition-overlay.show .turn-transition-card {
            transform: scale(1) translateY(0);
        }

        .turn-transition-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        .blue-turn .turn-transition-title {
            color: #4169E1;
            text-shadow: 0 0 10px rgba(65, 105, 225, 0.7);
        }

        .red-turn .turn-transition-title {
            color: #DC143C;
            text-shadow: 0 0 10px rgba(220, 20, 60, 0.7);
        }

        .turn-transition-subtitle {
            font-size: 1.2rem;
            color: white;
            opacity: 0.8;
            position: relative;
            z-index: 10;
        }

        /* 动画效果 */
        .turn-transition-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(45deg);
            animation: shine 1.5s forwards ease-out;
            z-index: 1;
        }

        @keyframes shine {
            0% {
                transform: rotate(45deg) translateX(-100%) translateY(-100%);
            }
            100% {
                transform: rotate(45deg) translateX(100%) translateY(100%);
            }
        }

        /* 边框效果 */
        .blue-turn .turn-transition-card {
            box-shadow: 0 0 30px rgba(65, 105, 225, 0.5);
            border: 1px solid rgba(65, 105, 225, 0.5);
        }

        .red-turn .turn-transition-card {
            box-shadow: 0 0 30px rgba(220, 20, 60, 0.5);
            border: 1px solid rgba(220, 20, 60, 0.5);
        }

        /* 背景元素 */
        .turn-transition-bg-element {
            position: absolute;
            border-radius: 50%;
            opacity: 0.15;
            filter: blur(10px);
            z-index: 1;
            animation: float 3s ease-in-out infinite alternate;
        }

        .blue-turn .turn-transition-bg-element {
            background: radial-gradient(circle, #4169E1, transparent);
        }

        .red-turn .turn-transition-bg-element {
            background: radial-gradient(circle, #DC143C, transparent);
        }

        @keyframes float {
            0% {
                transform: translateY(0) scale(1);
            }
            100% {
                transform: translateY(-10px) scale(1.05);
            }
        }

        /* 数字计数动画 */
        .turn-counter-anim {
            position: absolute;
            left: 45%;
            transform: translateX(-50%);
            top: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            z-index: 10;
            opacity: 0;
            animation: countFade 1.5s forwards;
        }

        @keyframes countFade {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(0);
            }
            20% {
                opacity: 1;
            }
            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(-15px);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px);
            }
        }

        /* 将军警告样式 */
        #check-warning.show {
          opacity: 1;
          visibility: visible;
          animation: pulse-warning 2s infinite;
          pointer-events: all;
        }

        @keyframes pulse-warning {
           0%, 100% {
            transform: translateX(-50%) scale(1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
          }
          50% {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
          }
        }

    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen p-4">
    <!-- Cover Page -->
    <div id="cover-page" class="cover-page">
        <div class="space-bg" id="cover-space-bg"></div>
        <div class="flex justify-center w-full mb-4">
            <img src="./images/BluePlanet.png" alt="星球" class="max-w-[240px] h-auto">
        </div>
        <div class="flex justify-center w-full">
            <img src="./images/SRWCLogo.png" alt="超級機械人大戰Chess" class="max-w-[90%] h-auto mb-8">
        </div>
        <div class="cover-buttons">
            <button id="singleplayer-cover-btn" class="cover-button">開始遊戲</button>
            <button id="tutorial-cover-btn" class="cover-button">體驗戰鬥</button>
            <button id="settings-cover-btn" class="cover-button">遊戲設定</button>
            <a id="contact-cover-btn" href="https://www.instagram.com/srwfanfan" target="_blank" class="cover-button">聯絡作者</a>
        </div>
    </div>

    <!-- Victory Overlay -->
    <div id="victory-overlay" class="victory-overlay">
        <div id="victory-card" class="victory-card">
            <div id="victory-icon" class="victory-icon">🏆</div>
            <h2 id="victory-title" class="victory-title">勝利！</h2>
            <p id="victory-message" class="victory-message">恭喜您獲得勝利！</p>
            <div class="flex justify-center space-x-4">
                <button id="save-progress-btn" class="victory-reset">儲存進度</button>
                <button id="victory-reset" class="victory-reset">返回主畫面</button>
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[1000] flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-300">
        <div class="relative max-w-md w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform transition-all duration-500">
            <div class="absolute inset-0 overflow-hidden opacity-20">
                <div class="stars-bg absolute inset-0"></div>
            </div>

            <div class="relative p-6 md:p-8">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">遊戲設定</h2>
                </div>

                <div class="space-y-6 text-gray-300">
                    <!-- 戰鬥AI難度 -->
                    <div>
                        <label class="block mb-2 font-medium">戰鬥AI難度</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm">簡單</span>
                            <input type="range" id="combat-ai-difficulty" min="1" max="5" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm">困難</span>
                        </div>
                    </div>

                    <!-- 下棋AI難度 -->
                    <div>
                        <label class="block mb-2 font-medium">下棋AI難度</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm">簡單</span>
                            <input type="range" id="chess-ai-difficulty" min="1" max="5" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm">困難</span>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end mt-8">
                    <button id="settings-close-btn" class="px-6 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none">
                        關閉
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Combat Mini-Game Overlay -->
    <div id="combat-overlay" class="combat-overlay hidden">
        <div id="attacker-role" class="attacker-role">你是攻擊者</div>
        <div id="defender-role" class="defender-role">你是防守者</div>

        <div class="combat-wrapper mx-auto" style="width: 80%; max-width: 640px;">
            <!-- Attacker Info Panel -->
            <div class="combat-info-panel">
                <div class="attacker-info">
                    <img id="attacker-image" class="unit-image" src="" alt="攻擊機體">
                    <div class="unit-stats">
                        <div id="attacker-name" class="unit-name">攻擊者機體</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-pink-300">命中:</span>
                            <div class="stat-bar">
                                <div id="attacker-hit-bar" class="hit-stat" style="width: 60%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="combat-container" id="combat-container">
                <div class="space-background" id="space-background"></div>
                <div class="combat-info" id="combat-info">攻擊者 vs 防守者</div>
                <div class="timer" id="combat-timer">3</div>

                <div class="attacker-instruction" id="attacker-instruction">移動滑鼠瞄準，點擊左鍵射擊（僅一次機會）</div>
                <div class="defender-instruction" id="defender-instruction">移動滑鼠選擇方向，點擊左鍵進行閃避</div>

                <div class="crosshair" id="crosshair">
                    <div class="crosshair-horizontal"></div>
                    <div class="crosshair-vertical"></div>
                    <div class="crosshair-inner"></div>
                </div>

                <div class="defender" id="defender">
                    <!-- Defender image will be set dynamically -->
                </div>

                <div class="defender-target" id="defender-target"></div>

                <div class="combat-result" id="combat-result">攻擊者勝利！</div>
            </div>

            <!-- Defender Info Panel -->
            <div class="combat-info-panel mt-2">
                <div class="defender-info">
                    <div class="unit-stats">
                        <div id="defender-name" class="unit-name">防守者機體</div>
                        <div class="flex items-center mt-1">
                            <span class="text-sm mr-2 text-cyan-300">迴避:</span>
                            <div class="stat-bar">
                                <div id="defender-dodge-bar" class="dodge-stat" style="width: 80%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                    <img id="defender-image" class="unit-image" src="" alt="防守機體">
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Main Game UI -->
    <div class="max-w-7xl mx-auto" id="game-ui" style="display: none;">
        <div class="grid md:grid-cols-3 gap-8">
            <!-- Chess Board -->
            <div class="md:col-span-2">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow aspect-square flex items-center justify-center">
                    <div id="board-container" class="w-[93%] h-[93%] flex items-center justify-center">
                        <div class="chess-board" id="chess-board"></div>
                    </div>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="md:col-span-1 space-y-6">
                <!-- Piece Information Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">能力參數</h2>
                    <div id="piece-info" class="p-3 bg-gray-100 dark:bg-gray-700 rounded-lg h-[150px] flex flex-col justify-center items-center">
                        <div id="piece-info-default" class="text-center text-gray-500 dark:text-gray-400">
                            滑鼠移至棋子上方查看詳細資訊
                        </div>
                        <div id="piece-info-content" class="w-full hidden">
                            <div class="flex items-center mb-2">
                                <img id="piece-info-image" src="" alt="" class="w-16 h-16 object-contain mr-3">
                                <div>
                                    <h3 id="piece-info-name" class="font-bold"></h3>
                                    <p id="piece-info-type" class="text-sm"></p>
                                    <p id="piece-info-crosshair" class="text-sm text-purple-500 dark:text-purple-400"></p>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-pink-500 dark:text-pink-400">命中值:</span>
                                        <span id="piece-info-hit-value" class="text-sm font-bold text-pink-500 dark:text-pink-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-hit" class="bg-pink-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm text-cyan-500 dark:text-cyan-400">迴避值:</span>
                                        <span id="piece-info-dodge-value" class="text-sm font-bold text-cyan-500 dark:text-cyan-400">0</span>
                                    </div>
                                    <div class="bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1">
                                        <div id="piece-info-dodge" class="bg-cyan-500 rounded-full h-2" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Status Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow overflow-hidden">
                    <h2 class="text-xl font-semibold mb-3">遊戲狀態</h2>
                    <div class="hidden">
                        <span class="turn-indicator" id="turn-indicator"></span>
                        <span id="turn-text">藍方回合</span>
                    </div>
                    <div id="status-message" class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 dark:from-blue-700 dark:to-purple-800 text-white rounded-lg min-h-[60px] flex items-center justify-center font-bold text-center shadow-lg text-lg mb-4">
                        遊戲準備就緒。藍方先行。
                    </div>

                    <!-- Turn Counter -->
                    <div class="mb-4 p-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-center">
                        <span class="text-lg font-bold">回合數：</span>
                        <span id="turn-count" class="text-lg font-bold text-primary">0</span>
                    </div>
                </div>

                <!-- Game Controls Panel -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                    <h2 class="text-xl font-semibold mb-4">遊戲控制</h2>
                    <div class="flex justify-center space-x-4 mt-4">
                        <button id="load-progress-btn" class="px-6 py-3 bg-blue-500 text-white rounded-lg font-bold text-lg hover:bg-blue-600 transition">載入進度</button>
                        <button id="reset-btn" class="px-6 py-3 bg-red-500 text-white rounded-lg font-bold text-lg hover:bg-red-600 transition">重置遊戲</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Info Overlay -->
    <div id="level-info-overlay" class="level-info-overlay">
        <div class="level-info-card">
            <div class="level-header">
                <h1 id="level-title" class="level-title">第一話</h1>
                <h2 id="level-subtitle" class="level-subtitle"></h2>
            </div>

            <div class="level-content">
                <div class="level-image-container">
                    <img id="level-image" class="level-image" src="" alt="關卡圖片">
                </div>

                <div class="level-story">
                    <h3 class="level-story-title">故事簡介</h3>
                    <p id="level-story-content" class="level-story-content"></p>
                </div>

                <div class="level-conditions">
                    <h3 class="level-conditions-title">任務條件</h3>
                    <div id="victory-condition" class="victory-condition">
                        <span class="condition-icon">✓</span>
                        <span id="victory-text">勝利條件：吃掉對方的國王棋</span>
                    </div>
                    <div id="defeat-condition" class="defeat-condition">
                        <span class="condition-icon">✗</span>
                        <span id="defeat-text">戰敗條件：國王棋被對方吃掉</span>
                    </div>
                </div>
            </div>

            <div class="level-footer">
                <button id="start-level-btn" class="start-level-btn">開始任務</button>
            </div>
        </div>
    </div>

    <!-- 将军警告消息 -->
    <div id="check-warning" class="fixed top-[10%] left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-red-600 to-red-800 text-white py-4 px-6 rounded-lg shadow-lg z-[1000] flex items-center justify-center text-2xl font-bold opacity-0 invisible transition-all duration-500 pointer-events-none">
        <div class="text-3xl mr-3">⚠️</div>
        <div class="check-warning-text">您被將軍了！請立即應對！</div>
    </div>
    
    <!-- Event Dialog -->
    <div id="event-dialog" class="event-dialog">
        <div id="dialog-character" class="dialog-character">キャラクター</div>
        <div id="dialog-content" class="dialog-content">對話內容將顯示在這裡...</div>
        <div class="dialog-next">點擊繼續</div>
    </div>

    <!-- Mission Popup -->
    <div id="mission-popup" class="mission-popup">
        <div class="mission-title">
            <i>★</i>
            <span>新任務</span>
        </div>
        <div id="mission-desc" class="mission-desc">任務描述將顯示在這裡...</div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[1100] flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-500"></div>

    <!-- CSV加載提示框 -->
    <div id="csv-loading-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[2000] flex items-center justify-center" style="display: none;">
        <div class="relative max-w-md w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform" style="margin-top: 0; top: 50%; left: 50%; transform: translate(-50%, -50%); position: fixed;">
            <div class="absolute inset-0 overflow-hidden opacity-20">
                <div class="stars-bg absolute inset-0"></div>
            </div>
            <div class="relative p-6 md:p-8 text-center">
                <div class="w-16 h-16 mx-auto mb-4 border-4 border-t-primary border-r-transparent border-b-transparent border-l-transparent rounded-full animate-spin"></div>
                <h3 class="text-xl font-bold text-white mb-2">正在載入關卡數據</h3>
                <p id="csv-loading-message" class="text-gray-300">正在從外部數據源獲取關卡信息...</p>
            </div>
        </div>
    </div>

    <!-- 回合转换提示 -->
    <div id="turn-transition-overlay" class="turn-transition-overlay">
        <div id="turn-transition-card" class="turn-transition-card">
            <!-- 背景元素 -->
            <div class="turn-transition-bg-element" style="width: 100px; height: 100px; top: -30px; left: -30px;"></div>
            <div class="turn-transition-bg-element" style="width: 80px; height: 80px; bottom: -20px; right: -20px;"></div>

            <!-- 回合计数器动画 -->
            <div id="turn-counter-anim" class="turn-counter-anim">第 <span id="turn-number-anim">0</span> 回合</div>

            <!-- 主要内容 -->
            <h2 id="turn-transition-title" class="turn-transition-title">藍方回合</h2>
            <p id="turn-transition-subtitle" class="turn-transition-subtitle">請指揮您的機體行動</p>
        </div>
    </div>

    <script>
        // 預設使用Dark Mode
        document.documentElement.classList.add('dark');

        // 仍然監聽系統偏好變化，但預設保持dark mode
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            // 不管系統偏好如何，保持dark mode
            document.documentElement.classList.add('dark');
        });

        // Game state and constants
        const BOARD_SIZE = 8;
        const BLUE = 'blue';
        const RED = 'red';

        // Piece movement types
        const PAWN = 'pawn';
        const ROOK = 'rook';
        const KNIGHT = 'knight';
        const BISHOP = 'bishop';
        const QUEEN = 'queen';
        const KING = 'king';

        // Combat mode state
        let combatMode = {
            active: false,
            attacker: null,
            defender: null,
            attackerPos: null,
            defenderPos: null,
            timer: 3,
            timeRemaining: 3000, // in milliseconds
            timerInterval: null,
            frameRequest: null,
            lastFrameTime: 0,
            mouseX: 0,
            mouseY: 0,
            defenderX: 0,
            defenderY: 0,
            defenderTargetX: 0,
            defenderTargetY: 0,
            defenderMoving: false,
            defenderSpeed: 0, // will be set based on defender's dodge value as percentage of container
            crosshairSize: 0, // will be set based on attacker's hit value as percentage of container
            defenderSizePercent: 20, // Fixed defender size: 20% of container width
            isPlayerAttacker: false,
            isPlayerDefender: false,
            bulletFired: false,
            result: null // 'attacker' or 'defender'
        };

        // 隱藏要素相關代碼
        let Get_fa_gundam = 0;
        
        // 添加BGM及SE相關代碼
        let battleBgmPlayer = null;
        let introMusicPlayer = null;
        let boardBgmPlayer = null;
        let currentBattleBgmType = null;

        let beamGunSound = null;
        let beamSaberSound = null;
        let cosmoNovaSound = null;
        let thunderSound = null;
        let explosionSound = null;
        let soundsLoaded = false;

        // Game state
        let gameState = {
            board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
            currentTurn: BLUE,
            selectedPiece: null,
            validMoves: [],
            gameMode: 'single-player',
            blueCaptured: [],
            redCaptured: [],
            gameOver: false,
            winner: null,
            turnCount: 0 // 初始化回合計數
        };

        // AI移動時間追蹤
        let lastAIMoveTime = 0;
        let aiMoveCount = 0;

        // AI移動計時器引用 - 用於管理和清除計時器
        let aiMoveTimer = null;

        // 初始化空的關卡數據，將從CSV載入
        let levelData = [];

        // 播放戰鬥BGM
        function playBattleBGM(bgmtype) {
            // 如果要播放的音乐与当前正在播放的相同，不做任何改变
            if (currentBattleBgmType === bgmtype && battleBgmPlayer) {
                console.log('相同BGM已在播放中，继续播放');
                return;
            }

            // 如果已經有在播放的BGM，先停止
            if (battleBgmPlayer) {
                battleBgmPlayer.pause();
                battleBgmPlayer = null;
            }

            // 根據bgmtype選擇音樂URL
            let bgmUrl = '';
            switch(bgmtype) {
                case 'Gundam':
                    bgmUrl = './audio/SRWCBGM_Gundam.mp3';
                    break;
                case 'Wingzero':
                    bgmUrl = './audio/SRWCBGM_Wingzero.mp3';
                    break;
                case 'Cybuster':
                    bgmUrl = './audio/SRWCBGM_Cybuster.mp3';
                    break;
                case 'GetterRobot':
                    bgmUrl = './audio/SRWCBGM_GetterRobot.mp3';
                    break;
                default:
                    return; // 沒有匹配的BGM類型，不播放
            }

            // 更新当前播放的BGM类型
            currentBattleBgmType = bgmtype;

            // 創建新的音頻播放器
            battleBgmPlayer = new Audio(bgmUrl);
            battleBgmPlayer.loop = true; // 設置循環播放

            // 嘗試播放音樂
            try {
                battleBgmPlayer.play().catch(err => {
                    console.log('無法自動播放BGM:', err);
                    // 多數瀏覽器需要用戶交互才能播放音頻，此錯誤可以不處理
                });
            } catch (e) {
                console.error('播放BGM出錯:', e);
            }
        }

        // 停止戰鬥BGM
        function stopBattleBGM() {
            if (battleBgmPlayer) {
                battleBgmPlayer.pause();
                battleBgmPlayer.currentTime = 0;
                battleBgmPlayer = null;
            }
            // 重置当前BGM类型
            currentBattleBgmType = null;
            beamGunSound = null;
            explosionSound = null;
            soundsLoaded = false;
        }

        // 播放遊戲介紹音樂
        function playIntroMusic() {
            // 如果已經有在播放的音樂，先停止
            if (introMusicPlayer) {
                introMusicPlayer.pause();
                introMusicPlayer = null;
            }

            // 指定介紹音樂的URL
            const introMusicUrl = './audio/SRWCBGM_Intro.mp3';

            // 創建新的音頻播放器
            introMusicPlayer = new Audio(introMusicUrl);
            introMusicPlayer.loop = true; // 設置循環播放

            // 嘗試播放音樂
            try {
                introMusicPlayer.play().catch(err => {
                    console.log('無法自動播放介紹音樂:', err);
                    // 多數瀏覽器需要用戶交互才能播放音頻，此錯誤可以不處理
                });
            } catch (e) {
                console.error('播放介紹音樂出錯:', e);
            }
        }

        // 停止介紹音樂
        function stopIntroMusic() {
            if (introMusicPlayer) {
                introMusicPlayer.pause();
                introMusicPlayer.currentTime = 0;
                introMusicPlayer = null;
            }
        }

        // 播放關卡背景音樂 - 添加在 playIntroMusic 和 stopIntroMusic 函數後
        function playBoardBGM(bgmUrl) {
            // 如果沒有提供URL，直接返回
            if (!bgmUrl) return;

            // 先停止所有可能正在播放的音樂
            stopIntroMusic();
            stopBattleBGM();
            stopBoardBGM();

            // 創建新的音頻播放器
            boardBgmPlayer = new Audio(bgmUrl);
            boardBgmPlayer.loop = true; // 設置循環播放

            // 嘗試播放音樂
            try {
                boardBgmPlayer.play().catch(err => {
                    console.log('無法自動播放關卡背景音樂:', err);
                    // 多數瀏覽器需要用戶交互才能播放音頻，此錯誤可以不處理
                });
            } catch (e) {
                console.error('播放關卡背景音樂出錯:', e);
            }
        }

        // 停止關卡背景音樂
        function stopBoardBGM() {
            if (boardBgmPlayer) {
                boardBgmPlayer.pause();
                boardBgmPlayer.currentTime = 0;
                boardBgmPlayer = null;
            }
        }

        // 预加载战斗音效
        function preloadCombatSounds() {
            // 加载激光枪音效
            beamGunSound = new Audio('./soundeffects/SRWCSE_BeamGun.mp3');
            beamGunSound.load();

            // 加载爆炸音效
            explosionSound = new Audio('./soundeffects/SRWCSE_Explosion.mp3');
            explosionSound.load();

            // 加载光束剑音效
            beamSaberSound = new Audio('./soundeffects/SRWCSE_BeamSaber.mp3');
            beamSaberSound.load();

            cosmoNovaSound = new Audio('./soundeffects/SRWCSE_CosmoNova.mp3');
            cosmoNovaSound.load();

            thunderSound = new Audio('./soundeffects/SRWCSE_Thunder.mp3');
            thunderSound.load();

            // 设置加载完成标志
            soundsLoaded = true;

            console.log('战斗音效预加载完成');
        }

        // 播放音效的通用函数
        function playCombatSound(sound) {
            if (!sound || !soundsLoaded) return;

            try {
                // 克隆音效对象以支持重叠播放
                const soundClone = sound.cloneNode();
                soundClone.volume = 0.7; // 设置音量为70%
                soundClone.play().catch(err => {
                    console.log('无法播放音效:', err);
                });
            } catch (e) {
                console.error('播放音效出错:', e);
            }
        }

        // 保存进度到CSV文件
        function saveProgress() {
            // 获取当前通关的关卡数
            const completedLevel = levelManager ? levelManager.currentLevel : 0;
    
            // 生成第一行10位数字组合 - 关卡进度
            let hiddenCode1 = "";
            // 第一位是随机数字
            hiddenCode1 += Math.floor(Math.random() * 10);
            // 第二位是已完成关卡数值
            hiddenCode1 += completedLevel;
            // 后面8位是随机数字
            for (let i = 0; i < 8; i++) {
                hiddenCode1 += Math.floor(Math.random() * 10);
            }
    
            // 生成第二行10位数字组合 - FA Gundam状态
            let hiddenCode2 = "";
            // 前9位是0-1的随机整数
            for (let i = 0; i < 9; i++) {
                hiddenCode2 += Math.floor(Math.random() * 2);
            }
            // 最后一位是Get_fa_gundam的值
            hiddenCode2 += Get_fa_gundam;
    
            // 创建CSV内容，包含两行数据
            const csvContent = "game_code\n" + hiddenCode1 + "\n" + hiddenCode2;
    
            // 创建Blob对象
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    
            // 创建下载链接
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
    
            // 设置链接属性
            link.setAttribute("href", url);
            link.setAttribute("download", "srwcsave.csv");
            link.style.visibility = 'hidden';
    
            // 添加到文档并触发点击
            document.body.appendChild(link);
            link.click();
    
            // 清理
            document.body.removeChild(link);
    
            // 显示提示
            showToast("進度已保存");
        }

        // 加载进度
        function loadProgress() {
            // 创建文件输入元素
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            // 添加到文档
            document.body.appendChild(fileInput);
    
            // 设置文件选择处理
            fileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) {
                    document.body.removeChild(fileInput);
                    return;
                }
        
                // 显示加载提示
                const loadingOverlay = document.getElementById('csv-loading-overlay');
                loadingOverlay.style.display = 'flex';
                document.getElementById('csv-loading-message').textContent = "正在載入進度...";
        
                // 读取文件
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const lines = content.split('\n');
            
                    // 确保文件格式正确 - 至少有3行(标题行+两行数据)
                    if (lines.length < 3) {
                        document.getElementById('csv-loading-message').textContent = "進度檔案格式錯誤";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // 获取关卡进度代码和FA Gundam状态代码
                    const levelCode = lines[1].trim();
                    const gundamCode = lines[2].trim();
                
                    // 验证存档代码格式 - 应该都是10位数字
                    if (!/^\d{10}$/.test(levelCode) || !/^\d{10}$/.test(gundamCode)) {
                        document.getElementById('csv-loading-message').textContent = "進度檔案內容錯誤";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // 从第一个代码的第二位提取已完成关卡数
                    const completedLevel = parseInt(levelCode.charAt(1), 10);
                    if (isNaN(completedLevel)) {
                        document.getElementById('csv-loading-message').textContent = "進度檔案內容錯誤";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // 从第二个代码的最后一位提取Get_fa_gundam值
                    const faGundamValue = parseInt(gundamCode.charAt(9), 10);
                    if (isNaN(faGundamValue)) {
                        document.getElementById('csv-loading-message').textContent = "進度檔案內容錯誤";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 2000);
                        return;
                    }
            
                    // 设置全局变量Get_fa_gundam
                    Get_fa_gundam = faGundamValue;
                    console.log("从存档读取FA Gundam状态:", Get_fa_gundam);
            
                    // 检查是否已完成所有可用关卡
                    if (completedLevel < 5) {
                        // 根据完成的关卡数加载下一关
                        let nextLevelId = completedLevel + 1;
                        loadLevelById(nextLevelId, loadingOverlay);
                    } else {
                        // 已完成所有关卡，显示消息
                        document.getElementById('csv-loading-message').textContent = "您已完成所有可用關卡！";
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                            // 可选：返回主菜单
                            showCoverPage();
                        }, 3000);
                    }
                };
        
                reader.onerror = function() {
                    document.getElementById('csv-loading-message').textContent = "讀取檔案時發生錯誤";
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 2000);
                };
        
                // 开始读取文件
                reader.readAsText(file);
        
                // 清理
                document.body.removeChild(fileInput);
            };
    
            // 触发文件选择
            fileInput.click();
        }

        // 根据关卡ID加载关卡
        function loadLevelById(levelId, loadingOverlay) {
            // 根据关卡ID决定加载哪个CSV文件
            let csvUrl = "";
            if (levelId === 1) {
                csvUrl = "./stages/SRWCStage01.csv"; // 第一关
            } else if (levelId === 2) {
                csvUrl = "./stages/SRWCStage02.csv"; // 第二关
            } else if (levelId === 3) {
                csvUrl = "./stages/SRWCStage03.csv"; // 第三关
            } else if (levelId === 4) {
                csvUrl = "./stages/SRWCStage04.csv"; // 第四关
            } else {
                // 默认或未来关卡
                document.getElementById('csv-loading-message').textContent = "未找到對應關卡或關卡開發中";
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 2000);
                return;
            }
    
            // 加载关卡
            loadLevelsFromURL(csvUrl).then(success => {
                if (success) {
                    // 更新加载消息
                    document.getElementById('csv-loading-message').textContent = "正在預載圖片資源...";
            
                    // 预加载图片
                    const imagesToLoad = getAllImageURLsFromLevelData();
                    preloadImages(imagesToLoad).then(() => {
                        // 隐藏加载界面
                        loadingOverlay.style.display = 'none';
                
                        // 清理当前游戏状态
                        gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                        gameState.blueCaptured = [];
                        gameState.redCaptured = [];
                        gameState.currentTurn = BLUE;
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        gameState.gameOver = false;
                        gameState.winner = null;
                        gameState.turnCount = 0;
                    
                        // 更新UI
                        updateBoardDisplay();
                        updateCapturedPieces();
                        updateTurnIndicator();
                        updateTurnCountDisplay();
                
                        // 隐藏封面页面
                        coverPage.classList.add('hide');
                
                        // 显示游戏UI
                        gameUI.style.display = 'block';
                
                        // 加载关卡
                        const nextLevelId = window.levelData.length > 0 ? window.levelData[0].id : 1;
                        if (levelManager) {
                            levelManager.loadLevel(nextLevelId);
                        }
                    });
                } else {
                    // 加载失败
                    document.getElementById('csv-loading-message').textContent = "無法載入關卡數據";
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 2000);
                }
            }).catch(error => {
                console.error("載入關卡時出錯:", error);
                document.getElementById('csv-loading-message').textContent = "載入關卡時出錯: " + error.message;
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 2000);
            });
        }        
        
        /**
         * 将十六进制颜色转换为rgba格式
         * @param {string} hexColor - 十六进制颜色值 (#RRGGBB 或 #RGB 格式)
         * @param {number} alpha - 透明度 (0-1)
         * @return {string} rgba格式的颜色
         */
        function hexToRgba(hexColor, alpha = 1) {
            // 检查是否为空或无效值
            if (!hexColor || typeof hexColor !== 'string') {
                return `rgba(255, 20, 147, ${alpha})`; // 默认返回深粉红色
            }

            // 移除#号并标准化十六进制颜色
            let hex = hexColor.replace('#', '').trim();

            // 检查是否有效的十六进制值
            if (!/^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/.test(hex)) {
                return `rgba(255, 20, 147, ${alpha})`; // 无效时返回默认颜色
            }

            // 处理简写形式 (#RGB)
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }

            // 解析RGB值
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            // 返回rgba格式
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // =================== 多边形碰撞检测工具函数 ===================

        /**
         * 创建一个多边形对象
         * @param {Array} points - 多边形顶点数组，格式为 [{x, y}, {x, y}, ...]
         * @param {number} x - 多边形中心x坐标
         * @param {number} y - 多边形中心y坐标
         * @param {number} rotation - 旋转角度（度）
         * @return {Object} 多边形对象
         */
        function createPolygon(points, x, y, rotation = 0) {
            return {
                points: points,
                x: x,
                y: y,
                rotation: rotation,

                // 获取变换后的点
                getTransformedPoints: function() {
                    // 角度转弧度
                    const rad = (this.rotation * Math.PI) / 180;
                    const cos = Math.cos(rad);
                    const sin = Math.sin(rad);

                    return this.points.map(point => {
                        // 应用旋转
                        const rotatedX = point.x * cos - point.y * sin;
                        const rotatedY = point.x * sin + point.y * cos;

                        // 应用平移
                        return {
                            x: rotatedX + this.x,
                            y: rotatedY + this.y
                        };
                    });
                }
            };
        }

        /**
         * 检测多边形之间是否碰撞（使用分离轴定理SAT）
         * @param {Object} polygonA - 第一个多边形对象
         * @param {Object} polygonB - 第二个多边形对象
         * @return {boolean} 是否碰撞
         */
        function polygonsCollide(polygonA, polygonB) {
            const pointsA = polygonA.getTransformedPoints();
            const pointsB = polygonB.getTransformedPoints();

            // 获取所有边的法向量作为投影轴
            const axes = getAxes(pointsA).concat(getAxes(pointsB));

            // 在每个轴上检测投影是否重叠
            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                const projectionA = projectPolygon(pointsA, axis);
                const projectionB = projectPolygon(pointsB, axis);

                // 如果在任意轴上没有重叠，则多边形不碰撞
                if (!projectionOverlap(projectionA, projectionB)) {
                    return false;
                }
            }

            // 所有轴上都有重叠，多边形碰撞
            return true;
        }

        /**
         * 获取多边形所有边的法向量
         * @param {Array} points - 多边形顶点数组
         * @return {Array} 法向量数组
         */
        function getAxes(points) {
            const axes = [];

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];

                // 计算边的法向量
                const edge = {
                    x: p2.x - p1.x,
                    y: p2.y - p1.y
                };

                // 法向量（垂直于边）
                const normal = {
                    x: -edge.y,
                    y: edge.x
                };

                // 单位化
                const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                normal.x /= length;
                normal.y /= length;

                axes.push(normal);
            }

            return axes;
        }

        /**
         * 将多边形投影到轴上
         * @param {Array} points - 多边形顶点
         * @param {Object} axis - 投影轴
         * @return {Object} 投影区间 {min, max}
         */
        function projectPolygon(points, axis) {
            let min = Number.MAX_VALUE;
            let max = -Number.MAX_VALUE;

            points.forEach(point => {
                // 点在轴上的投影
                const projection = point.x * axis.x + point.y * axis.y;

                if (projection < min) min = projection;
                if (projection > max) max = projection;
            });

            return { min, max };
        }

        /**
         * 检查两个投影是否重叠
         * @param {Object} projectionA - 第一个投影 {min, max}
         * @param {Object} projectionB - 第二个投影 {min, max}
         * @return {boolean} 是否重叠
         */
        function projectionOverlap(projectionA, projectionB) {
            return !(projectionA.max < projectionB.min || projectionB.max < projectionA.min);
        }

        /**
         * 创建规则多边形
         * @param {number} sides - 边数
         * @param {number} radius - 半径
         * @return {Array} 多边形顶点数组
         */
        function createRegularPolygon(sides, radius) {
            const points = [];
            const angleStep = (2 * Math.PI) / sides;

            for (let i = 0; i < sides; i++) {
                const angle = i * angleStep;
                points.push({
                    x: radius * Math.cos(angle),
                    y: radius * Math.sin(angle)
                });
            }

            return points;
        }

        /**
         * 从SVG路径创建多边形
         * @param {string} svgPath - SVG路径字符串
         * @param {number} scale - 缩放因子
         * @return {Array} 多边形顶点数组
         */
        function createPolygonFromSVG(svgPath, scale = 1) {
            // 注意：这是简化版，只支持简单的移动和直线命令
            // 完整实现需要SVG路径解析库
            const points = [];
            const commands = svgPath.match(/[MLZ][^MLZ]*/g) || [];

            commands.forEach(cmd => {
                const type = cmd[0];
                const coords = cmd.slice(1).trim().split(/[\s,]+/).map(Number);

                if (type === 'M' || type === 'L') {
                    for (let i = 0; i < coords.length; i += 2) {
                        if (i + 1 < coords.length) {
                            points.push({
                                x: coords[i] * scale,
                                y: coords[i + 1] * scale
                            });
                        }
                    }
                }
            });

            return points;
        }

        /**
         * 创建指定类型的准星元素
         * @param {string} type - 准星类型
         * @param {string} color - 准星颜色（十六进制）
         * @param {number} size - 准星大小
         * @return {HTMLElement} 准星DOM元素
         */
        function createCrosshair(type, color, size) {
            // 创建准星容器
            const container = document.createElement('div');
            container.className = 'crosshair';
            container.style.width = `${size}px`;
            container.style.height = `${size}px`;

            // 解析颜色
            const rgbaColor = hexToRgba(color, 1);
            const rgbaColorFaint = hexToRgba(color, 0.5);

            // 计算参数
            const lineThickness = Math.max(2, Math.floor(size / 50)); // 线条最小2px
            const outerSize = Math.round(size * 0.8); // 外框大小为容器大小的80%
            const borderWidth = Math.max(2, Math.floor(size / 40)); // 边框宽度最小2px
            const dotSize = Math.max(4, Math.floor(size / 15)); // 中心点大小

            switch (type) {
                case 'Beam_Rifie':
                    // 圆形外框准星
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize}px;
                            height: ${outerSize}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            border-radius: 50%;
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            border-radius: 50%;
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Beam_Saber':
                    // 垂直长方形准星 (宽:高 = 1:6)
                    const frameWidth = Math.round(outerSize * 0.4); // 减小宽度以保持合理比例
                    const frameHeight = frameWidth * 6; // 高度是宽度的6倍

                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${frameWidth}px;
                            height: ${frameHeight}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Cosmo_Nova':
                    // 菱形外框准星
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize * 0.7}px;
                            height: ${outerSize * 0.7}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                case 'Destructive_Thunder':
                    // 使用不同的变量名避免冲突
                    const thunderSquareSize = Math.round(outerSize * 1); // 使用100%的外框大小
    
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${thunderSquareSize}px;
                            height: ${thunderSquareSize}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color}, 0 0 10px ${color};
                            animation: pulse 1s infinite alternate;
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                // 添加Getter_Beam准星类型
                case 'Getter_Beam':
                    // 水平长方形准星(宽:高 = 6:1)
                    const frameHeight = Math.round(outerSize * 0.4); // 较短的高度
                    const frameWidth = frameHeight * 6; // 宽度是高度的6倍
            
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${frameWidth}px;
                            height: ${frameHeight}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;
                    
                case 'diamond':
                    // 菱形外框准星
                    container.innerHTML = `
                        <div class="crosshair-frame" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${outerSize * 0.7}px;
                            height: ${outerSize * 0.7}px;
                            border: ${borderWidth}px solid ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 10px ${color};
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-horizontal" style="
                            position: absolute;
                            top: 50%;
                            left: 0;
                            width: 100%;
                            height: ${lineThickness}px;
                            background: linear-gradient(90deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateY(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-vertical" style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: ${lineThickness}px;
                            height: 100%;
                            background: linear-gradient(0deg, ${hexToRgba(color, 0)} 0%, ${rgbaColor} 50%, ${hexToRgba(color, 0)} 100%);
                            transform: translateX(-50%);
                            pointer-events: none;
                        "></div>
                        <div class="crosshair-dot" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${dotSize}px;
                            height: ${dotSize}px;
                            background-color: ${rgbaColor};
                            transform: translate(-50%, -50%) rotate(45deg);
                            box-shadow: 0 0 5px ${color};
                            pointer-events: none;
                        "></div>
                    `;
                    break;

                // ...其他准星类型保持不变...
            }

            return container;
        }

        // 显示回合转换提示
        function showTurnTransition(team, turnNumber) {
            const overlay = document.getElementById('turn-transition-overlay');
            const card = document.getElementById('turn-transition-card');
            const title = document.getElementById('turn-transition-title');
            const subtitle = document.getElementById('turn-transition-subtitle');
            const turnNumberAnim = document.getElementById('turn-number-anim');

            if (!overlay || !card || !title || !subtitle) return;

            // 设置回合数
            if (turnNumberAnim) {
                turnNumberAnim.textContent = turnNumber;
            }

            // 重置类
            card.classList.remove('blue-turn', 'red-turn');

            // 设置适当的队伍类和文本
            if (team === BLUE) {
                card.classList.add('blue-turn');
                title.textContent = '藍方回合';
                subtitle.textContent = '請指揮您的機體行動';
            } else {
                card.classList.add('red-turn');
                title.textContent = '紅方回合';
                subtitle.textContent = '敌方机体开始行动';
            }

            // 显示过渡
            overlay.classList.add('show');

            // 2秒后隐藏
            setTimeout(() => {
                overlay.classList.remove('show');

                // 重置动画元素以便下次显示
                setTimeout(() => {
                    const countElem = document.getElementById('turn-counter-anim');
                    if (countElem) {
                        // 克隆并替换元素以重置动画
                        const newCountElem = countElem.cloneNode(true);
                        countElem.parentNode.replaceChild(newCountElem, countElem);
                    }
                }, 500);
            }, 1000);
        }

        // CSV加載相關功能
        // 從URL獲取CSV數據
        async function fetchCSVFromURL(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error("獲取CSV數據時出錯:", error);
                throw error;
            }
        }

        // 解析CSV數據
        function parseCSV(csvText) {
            if (!csvText) return [];

            const lines = csvText.split('\n');
            const headers = lines[0].split(',');

            return lines.slice(1).filter(line => line.trim() !== '').map(line => {
                const values = line.split(',');
                const entry = {};

                headers.forEach((header, index) => {
                    entry[header] = values[index] || '';
                });

                return entry;
            });
        }

        // 從CSV數據創建關卡
        function createLevelsFromCSV(csvEntries) {
            const levels = [];
            let currentLevel = null;

            // 按CSV數據類型處理每一行
            csvEntries.forEach(entry => {
                switch (entry.data_type) {
                    case 'level_info':
                        // 創建新關卡
                        currentLevel = {
                            id: parseInt(entry.id),
                            title: entry.title,
                            subtitle: entry.subtitle,
                            storyImage: entry.storyImage,
                            storyDesc: entry.storyDesc,
                            boardImage: entry.boardImage,
                            boardbgm: entry.boardbgm,
                            pieceDefinitions: {},
                            initialBoardState: [],
                            events: []
                        };
                        levels.push(currentLevel);
                        break;

                    case 'piece_definition':
                        // 添加機體定義
                        if (currentLevel) {
                            // 確保team字段正確設置
                            const team = entry.team || (entry.id.includes('zaku') || entry.id.includes('red') ? RED : BLUE);

                            currentLevel.pieceDefinitions[entry.id] = {
                                team: team,
                                type: entry.type,
                                moveType: entry.moveType,
                                imgUrl: entry.imgUrl,
                                hit: parseInt(entry.hit) || 3,
                                dodge: parseInt(entry.dodge) || 3,
                                bgmtype: entry.bgmtype || '',
                                weapon_colour: entry.weapon_colour || '',
                                crosshairType: entry.crosshairType || 'Beam_Rifie' // 准星形状类型
                            };
                        }
                        break;

                    case 'initial_position':
                        // 添加初始位置
                        if (currentLevel) {
                            currentLevel.initialBoardState.push({
                                id: entry.id,
                                position: [parseInt(entry.position_row), parseInt(entry.position_col)]
                            });
                        }
                        break;

                    case 'condition':
                        // 設置勝利/失敗條件
                        if (currentLevel) {
                            const conditionObj = {
                                type: entry.condition_type,
                                description: entry.description
                            };

                            // 处理特定类型的条件
                            if (entry.condition_type === 'surviveNTurns') {
                                // 从描述中提取数字
                                const matches = entry.description.match(/\d+/);
                                const turns = matches ? parseInt(matches[0], 10) : 10; // 默认值为3，以防提取失败
                                conditionObj.turns = turns;
                                console.log(`从描述 "${entry.description}" 中提取到回合数: ${turns}`);
                            }

                            if (entry.id === 'victory') {
                                currentLevel.victoryCondition = conditionObj;
                            } else if (entry.id === 'defeat') {
                                currentLevel.defeatCondition = conditionObj;
                            }
                        }
                        break;

                    case 'event':
                        // 添加事件
                        if (currentLevel) {
                            const eventObj = {
                                type: entry.event_type,
                                condition: {},
                                action: {
                                    type: entry.action_type
                                },
                                once: entry.once === 'TRUE'
                            };

                            // 設置條件
                            if (entry.condition_turn) eventObj.condition.turn = parseInt(entry.condition_turn);
                            if (entry.condition_team) eventObj.condition.team = entry.condition_team;
                            if (entry.condition_pieceId) eventObj.condition.pieceId = entry.condition_pieceId;
                            if (entry.condition_row) eventObj.condition.row = parseInt(entry.condition_row);
                            if (entry.condition_col) eventObj.condition.col = parseInt(entry.condition_col);

                            // 根據動作類型設置動作參數
                            switch (entry.action_type) {
                                case 'spawnPiece':
                                    eventObj.action.pieceId = entry.action_pieceId;
                                    if (entry.action_findBestPosition === 'TRUE') eventObj.action.findBestPosition = true;
                                    if (entry.action_special === 'TRUE') eventObj.action.special = true;
                                    if (entry.action_title) eventObj.action.title = entry.action_title;
                                    if (entry.action_description) eventObj.action.description = entry.action_description;
                                    if (entry.action_buttonText) eventObj.action.buttonText = entry.action_buttonText;
                                    if (entry.aim_row) eventObj.action.aimRow = parseInt(entry.aim_row);
                                    if (entry.aim_col) eventObj.action.aimCol = parseInt(entry.aim_col);
                                    break;

                                // 添加 replacePiece 动作类型的处理
                                case 'replacePiece':
                                    // 设置 replacePiece 所需的所有参数
                                    if (entry.action_pieceId) eventObj.action.pieceId = entry.action_pieceId;
                                    if (entry.action_targetPieceId) eventObj.action.targetPieceId = entry.action_targetPieceId;
                                    if (entry.action_row) eventObj.action.row = parseInt(entry.action_row);
                                    if (entry.action_col) eventObj.action.col = parseInt(entry.action_col);
                                    if (entry.aim_row) eventObj.action.aimRow = parseInt(entry.aim_row);
                                    if (entry.aim_col) eventObj.action.aimCol = parseInt(entry.aim_col);
                                    if (entry.action_findBestPosition === 'TRUE') eventObj.action.findBestPosition = true;
                                    if (entry.action_special === 'TRUE') eventObj.action.special = true;
                                    if (entry.action_title) eventObj.action.title = entry.action_title;
                                    if (entry.action_description) eventObj.action.description = entry.action_description;
                                    if (entry.action_buttonText) eventObj.action.buttonText = entry.action_buttonText;
                                    break;

                                case 'dialog':
                                    eventObj.action.character = entry.action_character;
                                    eventObj.action.text = entry.action_text;
                                    break;

                                case 'removePiece':
                                    eventObj.action.position = [parseInt(entry.action_position_row), parseInt(entry.action_position_col)];
                                    eventObj.action.pieceId = entry.action_pieceId;  // Add this line to save the piece ID
                                    break;

                                case 'movePiece':
                                    eventObj.action.from = [parseInt(entry.action_from_row), parseInt(entry.action_from_col)];
                                    eventObj.action.to = [parseInt(entry.action_to_row), parseInt(entry.action_to_col)];
                                    break;

                                case 'showMission':
                                    eventObj.action.text = entry.action_text;
                                    break;
                            }

                            currentLevel.events.push(eventObj);
                        }
                        break;
                }
            });

            console.log("從CSV創建的關卡數據:", levels);
            return levels;
        }

        // 從URL加載關卡
        async function loadLevelsFromURL(url) {
            // 顯示加載界面
            const loadingOverlay = document.getElementById('csv-loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                // 獲取和解析CSV數據
                const csvText = await fetchCSVFromURL(url);
                const csvEntries = parseCSV(csvText);
                const levels = createLevelsFromCSV(csvEntries);

                // 替換全局關卡數據
                console.log(levels);
                if (levels.length > 0) {
                    window.levelData = levels;
                    console.log("成功從URL加載關卡數據");
                    return true;
                } else {
                    throw new Error("解析CSV後沒有獲得有效的關卡數據");
                }
            } catch (error) {
                console.error("加載關卡數據失敗:", error);
                // 顯示錯誤訊息
                document.getElementById('csv-loading-message').textContent = "加載關卡數據失敗: " + error.message;
                // 5秒後隱藏加載界面
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 5000);
                return false;
            }
        }

        // 獲取所有需要預載的圖片URL
        function getAllImageURLsFromLevelData() {
            const urls = [];

            window.levelData.forEach(level => {
                if (level.storyImage) urls.push(level.storyImage);
                if (level.boardImage) urls.push(level.boardImage);

                Object.values(level.pieceDefinitions).forEach(piece => {
                    if (piece.imgUrl) urls.push(piece.imgUrl);
                });
            });

            return [...new Set(urls)]; // 去除重複URL
        }

        // Initialize pieces and their properties
        const pieceDefinitions = {

        };

        // Image URLs for preloading
        const imageUrls = Object.values(pieceDefinitions).map(piece => piece.imgUrl);

        // DOM elements
        const coverPage = document.getElementById('cover-page');
        const singleplayerBtn = document.getElementById('singleplayer-cover-btn');
        const gameUI = document.getElementById('game-ui');

        const chessBoard = document.getElementById('chess-board');
        const turnIndicator = document.getElementById('turn-indicator');
        const turnText = document.getElementById('turn-text');
        const statusMessage = document.getElementById('status-message');
        const resetBtn = document.getElementById('reset-btn');
        const blueCapturedEl = document.getElementById('blue-captured');
        const redCapturedEl = document.getElementById('red-captured');
        const blueCapturedMobileEl = document.getElementById('blue-captured-mobile');
        const redCapturedMobileEl = document.getElementById('red-captured-mobile');
        const connectingOverlay = document.getElementById('connecting-overlay');
        const connectionMessage = document.getElementById('connection-message');
        const networkStatus = document.getElementById('network-status');
        const toast = document.getElementById('toast');
        const myRoomIdEl = document.getElementById('my-room-id');
        const copyIdBtn = document.getElementById('copy-id-btn');
        const joinRoomIdEl = document.getElementById('join-room-id');
        const connectBtn = document.getElementById('connect-btn');
        const connectionStatus = document.getElementById('connection-status');

        // Combat elements
        const combatOverlay = document.getElementById('combat-overlay');
        const combatContainer = document.getElementById('combat-container');
        const combatInfo = document.getElementById('combat-info');
        const combatTimer = document.getElementById('combat-timer');
        const crosshair = document.getElementById('crosshair');
        const defender = document.getElementById('defender');
        const defenderTarget = document.getElementById('defender-target');
        const spaceBackground = document.getElementById('space-background');
        const combatResult = document.getElementById('combat-result');
        const attackerRole = document.getElementById('attacker-role');
        const defenderRole = document.getElementById('defender-role');
        const attackerInstruction = document.getElementById('attacker-instruction');
        const defenderInstruction = document.getElementById('defender-instruction');

        // Victory overlay elements
        const victoryOverlay = document.getElementById('victory-overlay');
        const victoryCard = document.getElementById('victory-card');
        const victoryTitle = document.getElementById('victory-title');
        const victoryMessage = document.getElementById('victory-message');
        const victoryReset = document.getElementById('victory-reset');
        const victoryIcon = document.getElementById('victory-icon');

        // New combat info panel elements
        const attackerImage = document.getElementById('attacker-image');
        const defenderImage = document.getElementById('defender-image');
        const attackerName = document.getElementById('attacker-name');
        const defenderName = document.getElementById('defender-name');
        const attackerHitBar = document.getElementById('attacker-hit-bar');
        const defenderDodgeBar = document.getElementById('defender-dodge-bar');

        // Setup cover page space background
        function setupSpaceBackground(container) {
            // Clear any existing stars
            container.innerHTML = '';

            // Add stars
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;

                // Different star sizes
                const size = Math.random() * 2.5 + 1;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;

                // Different star brightness
                star.style.opacity = Math.random() * 0.7 + 0.3;

                container.appendChild(star);
            }

            // Add shooting stars
            for (let i = 0; i < 5; i++) {
                createShootingStar(container);
            }
        }

        // Create shooting star with random properties
        function createShootingStar(container) {
            const shootingStar = document.createElement('div');
            shootingStar.className = 'shooting-star';

            // Random position and angle
            const startX = Math.random() * 100;
            const startY = Math.random() * 100;
            const angle = Math.random() * 60 - 30; // -30 to 30 degrees

            shootingStar.style.left = `${startX}%`;
            shootingStar.style.top = `${startY}%`;
            shootingStar.style.width = `${Math.random() * 100 + 50}px`;
            shootingStar.style.transform = `rotate(${angle}deg)`;

            // Random delay and duration
            const delay = Math.random() * 15;
            shootingStar.style.animationDelay = `${delay}s`;

            container.appendChild(shootingStar);

            // Replace the shooting star after animation
            setTimeout(() => {
                if (container.contains(shootingStar)) {
                    container.removeChild(shootingStar);
                    createShootingStar(container);
                }
            }, (delay + 3) * 1000); // 3s is the animation duration
        }

        // Preload all game images with progress tracking
        function preloadImages(imageUrls) {
            return new Promise((resolve) => {
                if (imageUrls.length === 0) {
                    resolve();
                    return;
                }

                const uniqueUrls = [...new Set(imageUrls)]; // Remove duplicates
                let loadedCount = 0;
                let startTime = Date.now();
                let lastUpdateTime = startTime;
                let loadingRates = [];

                // Load each image
                uniqueUrls.forEach(url => {
                    const img = new Image();
                    img.onload = img.onerror = () => {
                        loadedCount++;

                        if (loadedCount === uniqueUrls.length) {
                            // Add a short delay to show 100%
                            setTimeout(resolve, 500);
                        }
                    };
                    img.src = url;
                });
            });
        }

        // Reset confirmation dialog
        resetBtn.addEventListener('click', () => {
          resetGame();
          showCoverPage();
        });

        // Victory reset button - 保留原始功能，但在關卡系統中會被動態修改
        victoryReset.addEventListener('click', () => {
            victoryOverlay.classList.remove('show');
            resetGame();
            showCoverPage();
        });

        // Create chess board UI
        function createBoard() {
            chessBoard.innerHTML = '';

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cellElement = document.createElement('div');
                    cellElement.className = `chess-cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;

                    // Add coordinates for reference
                    const coordElement = document.createElement('div');
                    coordElement.className = 'coordinate top-left';
                    coordElement.textContent = `${String.fromCharCode(97 + col)}${8 - row}`;
                    cellElement.appendChild(coordElement);

                    chessBoard.appendChild(cellElement);
                }
            }

            // Add event listeners to cells
            const cells = document.querySelectorAll('.chess-cell');
            cells.forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        // Initialize game board with pieces
        function initializeGame() {
            // Reset game state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: gameState.gameMode,
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null,
                turnCount: 0 // 新增回合計數器
            };

            // Hide any active victory overlay
            victoryOverlay.classList.remove('show');

            // Reset combat mode
            combatMode = {
                active: false,
                attacker: null,
                defender: null,
                attackerPos: null,
                defenderPos: null,
                timer: 3,
                timeRemaining: 3000,
                timerInterval: null,
                frameRequest: null,
                lastFrameTime: 0,
                mouseX: 0,
                mouseY: 0,
                defenderX: 0,
                defenderY: 0,
                defenderTargetX: 0,
                defenderTargetY: 0,
                defenderMoving: false,
                defenderSpeed: 0,
                crosshairSize: 0,
                defenderSizePercent: 20, // 固定防守者尺寸
                isPlayerAttacker: false,
                isPlayerDefender: false,
                bulletFired: false,
                result: null
            };

            // 創建第一關的默認初始棋盤布局
            const defaultBoardState = [

            ];

            // 使用默認布局初始化棋盤
            defaultBoardState.forEach(piece => {
                const { id, position } = piece;
                const [row, col] = position;

                if (pieceDefinitions[id]) {
                    gameState.board[row][col] = {
                        id: id,
                        team: pieceDefinitions[id].team,
                        type: pieceDefinitions[id].type,
                        moveType: pieceDefinitions[id].moveType,
                        imgUrl: pieceDefinitions[id].imgUrl,
                        hit: pieceDefinitions[id].hit,
                        dodge: pieceDefinitions[id].dodge,
                        hasMoved: false
                    };
                }
            });

            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();

            statusMessage.textContent = "遊戲準備就緒。藍方先行。";
        }

        // Reset the game completely
        function resetGame() {
            // 停止所有BGM
            stopBattleBGM();
            stopIntroMusic();
            stopBoardBGM();
            showCheckWarning(false);
            Get_fa_gundam = 0;
            resetRequestSent = false;
            resetRequestReceived = false;

            // Reset all game elements to initial state
            gameState = {
                board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                currentTurn: BLUE,
                selectedPiece: null,
                validMoves: [],
                gameMode: 'single-player', // Default to single player when resetting
                blueCaptured: [],
                redCaptured: [],
                gameOver: false,
                winner: null,
                turnCount: 0 // 重置回合計數
            };

            victoryOverlay.classList.remove('show');
            combatOverlay.classList.add('hidden');
        }

        // Show the cover page
        function showCoverPage() {
            // 停止BGM (在這裡插入)
            stopBattleBGM();
            stopBoardBGM();
            playIntroMusic()
            gameUI.style.display = 'none';
            coverPage.classList.remove('hide');

        }

        // Update the visual representation of the board
        function updateBoardDisplay() {
            try {
                console.log(`開始更新棋盤顯示，時間: ${Date.now() - window.gameLoadStartTime}ms`);

                // Clear all pieces - 添加安全檢查
                const cells = document.querySelectorAll('.chess-cell');
                if (!cells || cells.length === 0) {
                    console.error(`更新棋盤顯示錯誤: 未找到棋盤格子元素，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                    return;
                }

                cells.forEach(cell => {
                    try {
                        // Remove piece images and indicators
                        const existingImg = cell.querySelector('.piece-img');
                        if (existingImg) cell.removeChild(existingImg);

                        const indicators = cell.querySelectorAll('.valid-move-indicator');
                        indicators.forEach(indicator => {
                            try {
                                cell.removeChild(indicator);
                            } catch (e) {
                                console.error(`移除有效移動指示器時出錯: ${e.message}`);
                            }
                        });

                        // 移除攻击类型指示器
                        const atkIndicators = cell.querySelectorAll('.attack-type-indicator');
                        atkIndicators.forEach(indicator => {
                            try {
                                cell.removeChild(indicator);
                            } catch (e) {
                                console.error(`移除攻擊類型指示器時出錯: ${e.message}`);
                            }
                        });

                        cell.classList.remove('selected');
                    } catch (error) {
                        console.error(`清理棋盤格子時發生錯誤: ${error.message}`);
                    }
                });

                // Determine if we should flip the board perspective (for red player in multiplayer mode)
                const shouldFlipPerspective = gameState.gameMode === 'multiplayer' && typeof isHost !== 'undefined' && !isHost;

                // Place pieces according to current board state
                if (!gameState || !gameState.board) {
                    console.error(`更新棋盤顯示錯誤: gameState或board未定義，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                    return;
                }

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        try {
                            const piece = gameState.board[row][col];
                            if (piece) {
                                // Apply perspective flip for red player in multiplayer
                                let displayRow = row;
                                let displayCol = col;

                                if (shouldFlipPerspective) {
                                    // Flip coordinates for red player's perspective
                                    displayRow = BOARD_SIZE - 1 - row;
                                    displayCol = BOARD_SIZE - 1 - col;
                                }

                                const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                                if (!cell) {
                                    console.error(`未找到格子元素 [${displayRow},${displayCol}]，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                                    continue;
                                }

                                // Create piece image
                                const img = document.createElement('img');
                                img.src = piece.imgUrl;
                                img.alt = piece.type;
                                img.className = `piece-img ${piece.team === RED ? 'red-piece' : 'blue-piece'}`;
                                img.dataset.pieceId = piece.id;

                                // 紅色棋子水平翻轉
                                if (piece.team === RED) {
                                    img.style.transform = 'scaleX(-1)';
                                }

                                cell.appendChild(img);

                                // Highlight selected piece
                                if (gameState.selectedPiece &&
                                    gameState.selectedPiece.row === row &&
                                    gameState.selectedPiece.col === col) {
                                    cell.classList.add('selected');
                                }
                            }
                        } catch (error) {
                            console.error(`放置棋子 [${row},${col}] 時發生錯誤: ${error.message}`);
                        }
                    }
                }

                // Show valid moves if a piece is selected
                if (gameState.selectedPiece && Array.isArray(gameState.validMoves)) {
                    gameState.validMoves.forEach(move => {
                        try {
                            if (!move || typeof move.row === 'undefined' || typeof move.col === 'undefined') {
                                console.error(`無效的移動數據: ${JSON.stringify(move)}`);
                                return;
                            }

                            let displayRow = move.row;
                            let displayCol = move.col;

                            if (shouldFlipPerspective) {
                                // Flip coordinates for red player's perspective
                                displayRow = BOARD_SIZE - 1 - move.row;
                                displayCol = BOARD_SIZE - 1 - move.col;
                            }

                            const cell = document.querySelector(`.chess-cell[data-row="${displayRow}"][data-col="${displayCol}"]`);
                            if (!cell) {
                                console.error(`顯示有效移動時未找到格子 [${displayRow},${displayCol}]`);
                                return;
                            }

                            const indicator = document.createElement('div');
                            indicator.className = 'valid-move-indicator';

                            // If there's a piece at this position (capture)
                            if (gameState.board[move.row][move.col]) {
                                indicator.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            } else {
                                indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
                            }

                            cell.appendChild(indicator);
                        } catch (error) {
                            console.error(`顯示有效移動時發生錯誤: ${error.message}`);
                        }
                    });
                }

                // Set up piece hover events after updating the board
                try {
                    setupPieceHoverEvents();
                    console.log(`棋盤顯示更新完成，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`設置棋子懸停事件時發生錯誤: ${error.message}`);
                }
            } catch (error) {
                console.error(`更新棋盤顯示時發生嚴重錯誤，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
            }

            // 如果是玩家回合，检查将军状态
            if (gameState.currentTurn === BLUE && !gameState.gameOver) {
                checkPlayerKingInCheck();
            }
            
        }

        // Update turn indicator
        function updateTurnIndicator() {
            try {
                // 檢查必要的DOM元素是否存在
                const turnIndicator = document.getElementById('turn-indicator');
                const turnText = document.getElementById('turn-text');

                // 安全地更新UI元素
                if (turnIndicator) {
                    turnIndicator.style.backgroundColor = gameState.currentTurn === BLUE ? '#4169E1' : '#DC143C';
                }

                if (turnText) {
                    turnText.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合`;
                }
            } catch (error) {
                // 無聲失敗，避免中斷遊戲流程
            }
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            try {
                // 檢查必要的DOM元素是否存在
                const blueCapturedEl = document.getElementById('blue-captured');
                const redCapturedEl = document.getElementById('red-captured');
                const blueCapturedMobileEl = document.getElementById('blue-captured-mobile');
                const redCapturedMobileEl = document.getElementById('red-captured-mobile');

                // 清空現有的捕獲棋子 - 安全地操作
                if (blueCapturedEl) blueCapturedEl.innerHTML = '';
                if (redCapturedEl) redCapturedEl.innerHTML = '';
                if (blueCapturedMobileEl) blueCapturedMobileEl.innerHTML = '';
                if (redCapturedMobileEl) redCapturedMobileEl.innerHTML = '';

                if (!gameState || !Array.isArray(gameState.blueCaptured) || !Array.isArray(gameState.redCaptured)) {
                    return;
                }

                // 添加藍方捕獲的棋子
                gameState.blueCaptured.forEach(piece => {
                    const img = document.createElement('img');
                    img.src = piece.imgUrl || '';
                    img.alt = piece.type || 'Captured';
                    img.title = piece.type || 'Captured';
                    img.className = 'w-8 h-8 object-contain';

                    if (blueCapturedEl) blueCapturedEl.appendChild(img.cloneNode(true));
                    if (blueCapturedMobileEl) blueCapturedMobileEl.appendChild(img);
                });

                // 添加紅方捕獲的棋子
                gameState.redCaptured.forEach(piece => {
                    const img = document.createElement('img');
                    img.src = piece.imgUrl || '';
                    img.alt = piece.type || 'Captured';
                    img.title = piece.type || 'Captured';
                    img.className = 'w-8 h-8 object-contain';

                    if (redCapturedEl) redCapturedEl.appendChild(img.cloneNode(true));
                    if (redCapturedMobileEl) redCapturedMobileEl.appendChild(img);
                });
            } catch (error) {
                // 無聲失敗，避免中斷遊戲流程
            }
        }

        // 設置棋子懸停事件，顯示能力參數
        function setupPieceHoverEvents() {
            const pieceImages = document.querySelectorAll('.piece-img');
            const pieceInfoDefault = document.getElementById('piece-info-default');
            const pieceInfoContent = document.getElementById('piece-info-content');
            const pieceInfoImage = document.getElementById('piece-info-image');
            const pieceInfoName = document.getElementById('piece-info-name');
            const pieceInfoType = document.getElementById('piece-info-type');
            const pieceInfoCrosshair = document.getElementById('piece-info-crosshair');
            const pieceInfoHit = document.getElementById('piece-info-hit');
            const pieceInfoDodge = document.getElementById('piece-info-dodge');
            const pieceInfoHitValue = document.getElementById('piece-info-hit-value');
            const pieceInfoDodgeValue = document.getElementById('piece-info-dodge-value');

            pieceImages.forEach(img => {
                img.addEventListener('mouseenter', function() {
                    const pieceId = this.dataset.pieceId;

                    let pieceInfo = null;
                    if (window.levelData && levelManager && levelManager.currentLevel) {
                        const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                        if (currentLevelData && currentLevelData.pieceDefinitions && currentLevelData.pieceDefinitions[pieceId]) {
                            pieceInfo = currentLevelData.pieceDefinitions[pieceId];
                        }
                    }

                    if (!pieceInfo && pieceDefinitions[pieceId]) {
                        pieceInfo = pieceDefinitions[pieceId];
                    }

                    if (!pieceInfo) {
                        // 在棋盤上尋找這個棋子獲取其直接屬性
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                const piece = gameState.board[row][col];
                                if (piece && piece.id === pieceId) {
                                    pieceInfo = piece;
                                    break;
                                }
                            }
                            if (pieceInfo) break;
                        }
                    }

                    if (pieceInfo) {
                        // 顯示棋子資訊
                        pieceInfoDefault.classList.add('hidden');
                        pieceInfoContent.classList.remove('hidden');

                        // 設置資訊內容
                        pieceInfoImage.src = pieceInfo.imgUrl;
                        pieceInfoName.textContent = pieceInfo.type;

                        // 移動類型翻譯
                        let moveTypeText = "";
                        switch(pieceInfo.moveType) {
                            case PAWN: moveTypeText = "步兵"; break;
                            case ROOK: moveTypeText = "城堡"; break;
                            case KNIGHT: moveTypeText = "騎士"; break;
                            case BISHOP: moveTypeText = "主教"; break;
                            case QUEEN: moveTypeText = "皇后"; break;
                            case KING: moveTypeText = "國王"; break;
                        }

                        // 設置移動類型
                        pieceInfoType.textContent = `移動類型: ${moveTypeText}`;

                        // 設置武器类型/準星类型
                        if (pieceInfo.crosshairType) {
                            // 翻譯準星類型
                            let crosshairTypeText = "";
                            switch(pieceInfo.crosshairType) {
                                case "Beam_Rifie": crosshairTypeText = "光束步槍"; break;
                                case "Beam_Saber": crosshairTypeText = "光束劍"; break;
                                case "Cosmo_Nova": crosshairTypeText = "宇宙新星"; break;
                                case "Destructive_Thunder": crosshairTypeText = "破壞雷電"; break;
                                case "diamond": crosshairTypeText = "鑽石光束"; break;
                                case "triangle": crosshairTypeText = "三角光束"; break;
                                case "custom": crosshairTypeText = "自定義武器"; break;
                                default: crosshairTypeText = pieceInfo.crosshairType;
                            }
                            pieceInfoCrosshair.textContent = `武器類型: ${crosshairTypeText}`;
                            pieceInfoCrosshair.style.display = "block";
                        } else {
                            pieceInfoCrosshair.style.display = "none";
                        }

                        // 設置能力條和數值顯示
                        const maxValue = 5; // 假設最大值是5
                        const hitPercentage = (pieceInfo.hit / maxValue) * 100;
                        const dodgePercentage = (pieceInfo.dodge / maxValue) * 100;

                        pieceInfoHit.style.width = `${hitPercentage}%`;
                        pieceInfoDodge.style.width = `${dodgePercentage}%`;

                        // 設置實數值顯示
                        pieceInfoHitValue.textContent = pieceInfo.hit;
                        pieceInfoDodgeValue.textContent = pieceInfo.dodge;
                    }
                });

                img.addEventListener('mouseleave', function() {
                    // 重置為默認狀態
                    pieceInfoDefault.classList.remove('hidden');
                    pieceInfoContent.classList.add('hidden');
                });
            });
        }

        // 設置已捕獲棋子的折疊功能
        function setupCapturedToggle() {
            const capturedHeader = document.getElementById('captured-header');
            const capturedToggle = document.getElementById('captured-toggle');
            const capturedContent = document.getElementById('captured-content');

            if (capturedHeader && capturedToggle && capturedContent) {
                capturedHeader.addEventListener('click', function() {
                    capturedContent.classList.toggle('hidden');
                    capturedToggle.classList.toggle('rotate-180');
                });
            }
        }

        // Show victory screen function
        function showVictoryScreen(winnerTeam) {
            // Set victory card appearance based on winner
            if (winnerTeam === BLUE) {
                victoryCard.className = "victory-card blue-victory";
                victoryTitle.textContent = "勝利！";
                victoryMessage.textContent = "您成功達到勝利條件！可以進入下一話了！";
                victoryIcon.textContent = "🏆";
            } else {
                victoryCard.className = "victory-card red-victory";
                victoryTitle.textContent = "戰敗了！";
                victoryMessage.textContent = "您被敵方擊敗了！再接再厲吧！";
                victoryIcon.textContent = "🏆";
            }

            // Create confetti effect
            createConfetti(winnerTeam);

            // Show the victory overlay
            victoryOverlay.classList.add('show');
        }

        // Create confetti animation
        function createConfetti(winnerTeam) {
            // Clear any existing confetti
            const existingConfetti = document.querySelectorAll('.victory-confetti');
            existingConfetti.forEach(c => c.remove());

            // Colors based on winner
            const colors = winnerTeam === BLUE
                ? ['#4169E1', '#6495ED', '#1E90FF', '#00BFFF', '#87CEFA', '#B0E0E6']
                : ['#DC143C', '#FF0000', '#CD5C5C', '#FF4500', '#FF6347', '#FFA07A'];

            // Create new confetti pieces
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'victory-confetti';

                // Random position
                confetti.style.left = `${Math.random() * 100}%`;

                // Random color from winner's colors
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                // Random shape
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';

                // Random size
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size * (Math.random() + 0.5)}px`;

                // Random animation duration
                const duration = Math.random() * 3 + 2;
                confetti.style.animationDuration = `${duration}s`;

                // Random delay
                confetti.style.animationDelay = `${Math.random() * 5}s`;

                // Add to overlay
                victoryCard.appendChild(confetti);
            }
        }

        // Handle cell click
        function handleCellClick(event) {
            if (gameState.gameOver || combatMode.active) return;

            const cell = event.currentTarget;
            let row = parseInt(cell.dataset.row);
            let col = parseInt(cell.dataset.col);
            let originalRow = row, originalCol = col;

            // If we're in multiplayer and this is the red player, flip coordinates
            if (gameState.gameMode === 'multiplayer' && !isHost) {
                row = BOARD_SIZE - 1 - row;
                col = BOARD_SIZE - 1 - col;
                console.log(`點擊棋盤格子: [${originalRow},${originalCol}] → 翻轉為 [${row},${col}]`);
            } else {
                console.log(`點擊棋盤格子: [${row},${col}]`);
            }

            const piece = gameState.board[row][col];
            if (piece) {
                console.log(`該格子有 ${piece.team}方棋子: ${piece.id} (${piece.type})`);
            } else {
                console.log(`該格子沒有棋子`);
            }

            // If a piece is already selected
            if (gameState.selectedPiece) {
                console.log(`已選擇棋子的座標: [${gameState.selectedPiece.row},${gameState.selectedPiece.col}]`);
                const selectedPiece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                if (selectedPiece) {
                    console.log(`已選擇的棋子: ${selectedPiece.id}, 類型: ${selectedPiece.type}`);
                } else {
                    console.log('警告: 已選擇座標無棋子!');
                }

                // Check if clicked on same piece (deselect)
                if (row === gameState.selectedPiece.row && col === gameState.selectedPiece.col) {
                    console.log(`取消選擇棋子: [${row},${col}]`);
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                    return;
                }

                // Check if clicked on another piece of same team (change selection)
                if (piece && piece.team === selectedPiece.team) {
                    if (piece.team === gameState.currentTurn) {
                        gameState.selectedPiece = { row, col };
                        gameState.validMoves = calculateValidMoves(row, col);
                        updateBoardDisplay();
                    }
                    return;
                }

                // Check if the move is valid
                const validMove = gameState.validMoves.find(move => move.row === row && move.col === col);
                if (validMove) {
                    // Check if this is a capture move (there's an opponent's piece)
                    if (piece && piece.team !== selectedPiece.team) {
                        // Start the combat minigame
                        startCombat(selectedPiece, piece,
                                    { row: gameState.selectedPiece.row, col: gameState.selectedPiece.col },
                                    { row, col });
                    } else {
                        // Regular move
                        movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                    }
                }
            }
            // No piece selected yet, select a piece if it belongs to current player
            else if (piece && piece.team === gameState.currentTurn) {
                gameState.selectedPiece = { row, col };
                gameState.validMoves = calculateValidMoves(row, col);
                updateBoardDisplay();
            }

            // 在移动完成后，如果游戏没有结束，检查将军状态
            if (!gameState.gameOver && gameState.currentTurn === BLUE) {
                checkPlayerKingInCheck();
            }
            
        }

        // Calculate valid moves for a piece
        function calculateValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];

            let moves = [];

            switch (piece.moveType) {
                case PAWN:
                    moves = calculatePawnMoves(row, col, piece);
                    break;
                case ROOK:
                    moves = calculateRookMoves(row, col, piece);
                    break;
                case KNIGHT:
                    moves = calculateKnightMoves(row, col, piece);
                    break;
                case BISHOP:
                    moves = calculateBishopMoves(row, col, piece);
                    break;
                case QUEEN:
                    moves = calculateQueenMoves(row, col, piece);
                    break;
                case KING:
                    moves = calculateKingMoves(row, col, piece);
                    break;
            }

            // Filter out moves that would put the king in check
            return moves.filter(move => {
                // Create a deep copy of the board for simulation
                const tempBoard = JSON.parse(JSON.stringify(gameState.board));

                // Simulate the move
                tempBoard[move.row][move.col] = tempBoard[row][col];
                tempBoard[row][col] = null;

                // Find the king
                let kingPos = null;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const p = tempBoard[r][c];
                        if (p && p.team === piece.team && p.moveType === KING) {
                            kingPos = { row: r, col: c };
                            break;
                        }
                    }
                    if (kingPos) break;
                }

                // If king not found (unlikely), allow the move
                if (!kingPos) return true;

                // Check if the king would be in check after the move
                return !isInCheck(tempBoard, kingPos.row, kingPos.col, piece.team);
            });
        }

        // Check if a position is under attack
        function isInCheck(board, kingRow, kingCol, team) {
            const enemyTeam = team === BLUE ? RED : BLUE;

            // Check all opponent pieces to see if any can attack the king
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = board[row][col];
                    if (!piece || piece.team !== enemyTeam) continue;

                    // Get potential attack moves for this piece
                    let attackMoves;
                    switch (piece.moveType) {
                        case PAWN:
                            attackMoves = calculatePawnAttacks(row, col, piece);
                            break;
                        case ROOK:
                            attackMoves = calculateRookMoves(row, col, piece);
                            break;
                        case KNIGHT:
                            attackMoves = calculateKnightMoves(row, col, piece);
                            break;
                        case BISHOP:
                            attackMoves = calculateBishopMoves(row, col, piece);
                            break;
                        case QUEEN:
                            attackMoves = calculateQueenMoves(row, col, piece);
                            break;
                        case KING:
                            attackMoves = calculateKingMoves(row, col, piece, true);
                            break;
                    }

                    // If any move can reach the king's position, the king is in check
                    if (attackMoves.some(move => move.row === kingRow && move.col === kingCol)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // 显示将军警告
        function showCheckWarning(isShown) {
          const warningElement = document.getElementById('check-warning');
          if (!warningElement) return;
  
          if (isShown) {
            warningElement.classList.add('show');
    
            if ('vibrate' in navigator) {
              navigator.vibrate([200, 100, 200]);
            }
            // 添加1秒后自动隐藏
            setTimeout(() => {
              warningElement.classList.remove('show');
            }, 1000); // 1秒 = 1000毫秒  
          } else {
            warningElement.classList.remove('show');
          }
        }

        // 检查玩家国王是否被将军
        function checkPlayerKingInCheck() {
          // 找到玩家国王位置
          let kingPos = null;
          for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              const piece = gameState.board[r][c];
              if (piece && piece.team === BLUE && piece.moveType === KING) {
                kingPos = { row: r, col: c };
                break;
              }
            }
            if (kingPos) break;
          }
  
          // 如果找不到国王，返回false
          if (!kingPos) return false;
  
          // 检查国王是否被将军
          const inCheck = isInCheck(gameState.board, kingPos.row, kingPos.col, BLUE);
  
          // 显示或隐藏警告
          showCheckWarning(inCheck);
  
          return inCheck;
        }
        
        // Calculate pawn moves
        function calculatePawnMoves(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1; // Blue moves up, Red moves down

            // Forward move
            if (isValidPosition(row + direction, col) && !gameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });

                // Double move from starting position
                const startRow = piece.team === BLUE ? 6 : 1;
                if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }

            // Capture moves (diagonally)
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    const targetPiece = gameState.board[row + direction][captureCol];
                    if (targetPiece && targetPiece.team !== piece.team) {
                        moves.push({ row: row + direction, col: captureCol });
                    }
                }
            });

            return moves;
        }

        // Calculate pawn attack pattern (for check detection)
        function calculatePawnAttacks(row, col, piece) {
            const moves = [];
            const direction = piece.team === BLUE ? -1 : 1;

            // Pawns attack diagonally
            const captureCols = [col - 1, col + 1];
            captureCols.forEach(captureCol => {
                if (isValidPosition(row + direction, captureCol)) {
                    moves.push({ row: row + direction, col: captureCol });
                }
            });

            return moves;
        }

        // Calculate rook moves
        function calculateRookMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: 0 }, // up
                { rowDelta: 1, colDelta: 0 },  // down
                { rowDelta: 0, colDelta: -1 }, // left
                { rowDelta: 0, colDelta: 1 }   // right
            ];

            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;

                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];

                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }

                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });

            return moves;
        }

        // Calculate knight moves
        function calculateKnightMoves(row, col, piece) {
            const moves = [];
            const knightMoves = [
                { rowDelta: -2, colDelta: -1 },
                { rowDelta: -2, colDelta: 1 },
                { rowDelta: -1, colDelta: -2 },
                { rowDelta: -1, colDelta: 2 },
                { rowDelta: 1, colDelta: -2 },
                { rowDelta: 1, colDelta: 2 },
                { rowDelta: 2, colDelta: -1 },
                { rowDelta: 2, colDelta: 1 }
            ];

            knightMoves.forEach(move => {
                const newRow = row + move.rowDelta;
                const newCol = col + move.colDelta;

                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];

                    if (!targetPiece || targetPiece.team !== piece.team) {
                        // Empty square or enemy piece
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });

            return moves;
        }

        // Calculate bishop moves
        function calculateBishopMoves(row, col, piece) {
            const moves = [];
            const directions = [
                { rowDelta: -1, colDelta: -1 }, // up-left
                { rowDelta: -1, colDelta: 1 },  // up-right
                { rowDelta: 1, colDelta: -1 },  // down-left
                { rowDelta: 1, colDelta: 1 }    // down-right
            ];

            directions.forEach(dir => {
                let currentRow = row + dir.rowDelta;
                let currentCol = col + dir.colDelta;

                while (isValidPosition(currentRow, currentCol)) {
                    const targetPiece = gameState.board[currentRow][currentCol];

                    if (!targetPiece) {
                        // Empty square
                        moves.push({ row: currentRow, col: currentCol });
                    } else {
                        // Found a piece
                        if (targetPiece.team !== piece.team) {
                            // Enemy piece can be captured
                            moves.push({ row: currentRow, col: currentCol });
                        }
                        break; // Can't move past a piece
                    }

                    currentRow += dir.rowDelta;
                    currentCol += dir.colDelta;
                }
            });

            return moves;
        }

        // Calculate queen moves (combination of rook and bishop)
        function calculateQueenMoves(row, col, piece) {
            return [
                ...calculateRookMoves(row, col, piece),
                ...calculateBishopMoves(row, col, piece)
            ];
        }

        // Calculate king moves
        function calculateKingMoves(row, col, piece, forCheckDetection = false) {
            const moves = [];

            // King moves one square in any direction
            for (let rowDelta = -1; rowDelta <= 1; rowDelta++) {
                for (let colDelta = -1; colDelta <= 1; colDelta++) {
                    // Skip the current position
                    if (rowDelta === 0 && colDelta === 0) continue;

                    const newRow = row + rowDelta;
                    const newCol = col + colDelta;

                    if (isValidPosition(newRow, newCol)) {
                        const targetPiece = gameState.board[newRow][newCol];

                        if (!targetPiece || targetPiece.team !== piece.team) {
                            // For regular move calculation, ensure the king doesn't move into check
                            if (forCheckDetection) {
                                moves.push({ row: newRow, col: newCol });
                            } else {
                                // Check if the new position would be in check
                                const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                tempBoard[newRow][newCol] = tempBoard[row][col];
                                tempBoard[row][col] = null;

                                if (!isInCheck(tempBoard, newRow, newCol, piece.team)) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                            }
                        }
                    }
                }
            }

            // 檢查車王易位條件（僅在非檢測模式下計算）
            if (!forCheckDetection && !piece.hasMoved) {
                // 檢查國王是否處於被將軍狀態
                const kingInCheck = isInCheck(gameState.board, row, col, piece.team);
                if (!kingInCheck) {
                    // 獲取正確的國王初始列（根據棋子隊伍）
                    const kingRow = piece.team === BLUE ? 7 : 0;

                    // 只有當國王在初始位置時才考慮車王易位
                    if (row === kingRow && col === 4) {

                        // 檢查短易位條件（向右側車子方向易位）
                        checkCastling(moves, row, col, piece, 7, 1, kingRow);

                        // 檢查長易位條件（向左側車子方向易位）
                        checkCastling(moves, row, col, piece, 0, -1, kingRow);
                    }
                }
            }

            return moves;
        }

        // 輔助函數：檢查指定方向的車王易位條件
        function checkCastling(moves, kingRow, kingCol, king, rookCol, direction, initialRow) {
            // 確認車在正確位置且未移動過
            const rookPiece = gameState.board[initialRow][rookCol];
            if (!rookPiece || rookPiece.team !== king.team ||
                rookPiece.moveType !== ROOK || rookPiece.hasMoved) {
                return;
            }

            // 檢查國王和車之間是否有棋子
            const startCol = direction > 0 ? kingCol + 1 : rookCol + 1;
            const endCol = direction > 0 ? rookCol : kingCol;
            for (let col = startCol; col < endCol; col++) {
                if (gameState.board[kingRow][col] !== null) {
                    return; // 中間有棋子，不能易位
                }
            }

            // 檢查國王移動路徑上的格子是否受到攻擊
            const step1 = kingCol + direction;
            const step2 = kingCol + 2 * direction;

            // 創建臨時棋盤檢查國王移動路徑是否安全
            const tempBoard1 = JSON.parse(JSON.stringify(gameState.board));
            tempBoard1[kingRow][kingCol] = null;
            tempBoard1[kingRow][step1] = king;

            const tempBoard2 = JSON.parse(JSON.stringify(gameState.board));
            tempBoard2[kingRow][kingCol] = null;
            tempBoard2[kingRow][step2] = king;

            // 如果國王移動路徑上的格子沒有受到攻擊，則允許車王易位
            if (!isInCheck(tempBoard1, kingRow, step1, king.team) &&
                !isInCheck(tempBoard2, kingRow, step2, king.team)) {

                // 添加易位目標位置，並設置特殊標記
                moves.push({
                    row: kingRow,
                    col: step2,
                    castling: true,
                    rookCol: rookCol,
                    rookNewCol: direction > 0 ? step1 : step1  // 車的新位置
                });
            }
        }

        // Helper to check if a position is valid (on the board)
        function isValidPosition(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
        }

        // Move a piece without afterimage effect
        function movePiece(fromRow, fromCol, toRow, toCol) {
            console.log(`移動棋子: 從[${fromRow},${fromCol}]到[${toRow},${toCol}]`);
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];

            if (piece) {
                console.log(`移動的棋子: ${piece.id}, 類型: ${piece.type}`);
            }

            if (capturedPiece) {
                console.log(`捕獲的棋子: ${capturedPiece.id}, 類型: ${capturedPiece.type}`);
            }

            // 檢查此移動是否是車王易位
            let isCastling = false;
            let castlingRookCol = null;
            let castlingRookNewCol = null;

            if (piece && piece.moveType === KING) {
                // 檢查此移動是否為有效的車王易位
                const validMove = gameState.validMoves.find(move =>
                    move.row === toRow && move.col === toCol && move.castling === true
                );

                if (validMove) {
                    isCastling = true;
                    castlingRookCol = validMove.rookCol;
                    castlingRookNewCol = validMove.rookNewCol;
                }
            }

            // If capturing a piece, add to captured list
            if (capturedPiece) {
                if (capturedPiece.team === BLUE) {
                    gameState.blueCaptured.push(capturedPiece);
                } else {
                    gameState.redCaptured.push(capturedPiece);
                }

                // Check if captured piece is a king (game over)
                if (capturedPiece.moveType === KING) {
                    // 只有在没有自定义胜利条件或胜利条件是'captureKing'时才立即结束游戏
                    if (!gameState.victoryCondition || gameState.victoryCondition.type === 'captureKing') {
                        gameState.gameOver = true;
                        gameState.winner = piece.team;
                    }
                }

                // 在这里触发 pieceCaptured 事件
                if (typeof eventSystem !== 'undefined') {
                    console.log(`触发pieceCaptured事件，捕获者: ${piece.id}，被捕获: ${capturedPiece.id}`);
                    eventSystem.triggerEvent('pieceCaptured', {
                        capturedPiece: capturedPiece,
                        capturingPiece: piece
                    });
                }
            }

            // Move the piece in the game state
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // 如果是車王易位，還需要移動車子
            if (isCastling && castlingRookCol !== null && castlingRookNewCol !== null) {
                // 獲取車子
                const rook = gameState.board[toRow][castlingRookCol];
                if (rook) {
                    // 移動車子到新位置
                    gameState.board[toRow][castlingRookNewCol] = rook;
                    gameState.board[toRow][castlingRookCol] = null;

                    // 標記車子已經移動
                    rook.hasMoved = true;

                    console.log(`執行車王易位：國王從(${fromRow},${fromCol})到(${toRow},${toCol})，車子從(${toRow},${castlingRookCol})到(${toRow},${castlingRookNewCol})`);
                }
            }

            // Mark the piece as moved (important for pawns)
            piece.hasMoved = true;

            // Clear selection and valid moves
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            // Switch turns
            gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;

            // 當輪到藍方回合時增加回合數計數（每完成一個完整回合增加一）
            if (gameState.currentTurn === BLUE) {
                gameState.turnCount++;
                console.log(`回合數增加到: ${gameState.turnCount}`);

                // 添加此行显示回合过渡
                showTurnTransition(BLUE, gameState.turnCount);

                // 检查是否正在播放战斗BGM
                const wasBattleBgmPlaying = battleBgmPlayer !== null;
                stopBattleBGM();

                // 只有在之前正在播放战斗BGM时才从头播放boardbgm
                if (wasBattleBgmPlaying && levelManager && levelManager.currentLevel) {
                    // 从头播放关卡BGM
                    const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                    if (currentLevelData && currentLevelData.boardbgm) {
                        playBoardBGM(currentLevelData.boardbgm);
                    }
                }

                // 觸發回合開始事件
                if (typeof eventSystem !== 'undefined') {
                    console.log(`觸發藍方回合開始事件，回合數: ${gameState.turnCount}`);
                    eventSystem.triggerEvent('turnStart', {
                        team: BLUE,
                        turn: gameState.turnCount
                    });
                }
            } else {
                // 觸發回合開始事件(紅方)
                if (typeof eventSystem !== 'undefined') {
                    console.log(`觸發紅方回合開始事件，回合數: ${gameState.turnCount}`);
                    eventSystem.triggerEvent('turnStart', {
                        team: RED,
                        turn: gameState.turnCount
                    });
                }

             if (typeof eventSystem !== 'undefined') {
                    console.log(`触发pieceMove事件，从[${fromRow},${fromCol}]到[${toRow},${toCol}]`);
                    eventSystem.triggerEvent('pieceMove', {
                        piece: piece,
                        fromRow: fromRow,
                        fromCol: fromCol,
                        row: toRow,  // 注意这里使用toRow作为row
                        col: toCol   // 注意这里使用toCol作为col
                    });
                }

            }

            // Update UI
            updateBoardDisplay();
            updateTurnIndicator();
            updateCapturedPieces();
            updateTurnCountDisplay();

            // Update status message and show victory overlay if game is over
            if (gameState.gameOver) {
                const winnerTeam = gameState.winner === BLUE ? '藍方' : '紅方';
                statusMessage.textContent = `遊戲結束！${winnerTeam}勝利！`;

                // Show victory overlay with animation
                showVictoryScreen(gameState.winner);

                // 處理關卡完成或失敗
                if (levelManager && levelManager.isLevelActive) {
                    if (gameState.winner === BLUE) {
                        levelManager.levelComplete();
                    } else {
                        levelManager.levelFailed();
                    }
                }
            } else {
                statusMessage.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合。`;

                // 檢查關卡系統的額外勝利/戰敗條件
                if (levelManager && levelManager.isLevelActive) {
                    // 檢查額外的勝利條件
                    if (levelManager.checkVictoryCondition()) {
                        gameState.gameOver = true;
                        gameState.winner = BLUE;
                        statusMessage.textContent = `遊戲結束！藍方勝利！`;
                        showVictoryScreen(BLUE);
                        levelManager.levelComplete();
                        return;
                    }

                    // 檢查額外的戰敗條件
                    if (levelManager.checkDefeatCondition()) {
                        gameState.gameOver = true;
                        gameState.winner = RED;
                        statusMessage.textContent = `遊戲結束！紅方勝利！`;
                        showVictoryScreen(RED);
                        levelManager.levelFailed();
                        return;
                    }
                }
            }

            // If single player mode and it's AI's turn
            if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                console.log(`準備安排AI移動，當前回合: ${gameState.currentTurn}`);
                // 清除任何可能存在的之前的計時器
                if (aiMoveTimer) {
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }

                const aiDelay = 2000;
                aiMoveTimer = setTimeout(makeAIMove, aiDelay);
            }
            
            // 在交换回合后，如果现在是玩家回合，检查玩家国王是否被将军
            if (gameState.currentTurn === BLUE && !gameState.gameOver) {
                // AI刚刚移动完，现在是玩家回合，检查将军状态
                setTimeout(checkPlayerKingInCheck, 300); // 短暂延迟确保UI已更新
            }
            
        }

        // 更新回合數顯示
        function updateTurnCountDisplay() {
            const turnCountElement = document.getElementById('turn-count');
            if (turnCountElement) {
                turnCountElement.textContent = gameState.turnCount;
            }
        }

        // Initialize the combat shooting minigame - clean version with no visual elements
        function initSpaceBackground() {
            // 清空背景區域，確保沒有任何視覺元素
            spaceBackground.innerHTML = '';
            // 不添加任何星星、星雲或其他視覺元素，保持純灰色背景
        }

        // 設置戰鬥模式狀態追蹤
        let tutorialBattleState = {
            stage: 0, // 0: 初始, 1: 示範戰鬥完成, 2: 玩家防守戰鬥完成
            inProgress: false
        };

        // 體驗戰鬥按鈕
        document.getElementById('tutorial-cover-btn').onclick = function() {
            // 重置戰鬥狀態
            tutorialBattleState = {
                stage: 0,
                inProgress: false
            };

            // 隱藏封面
            coverPage.classList.add('hide');

            // 啟動第一階段：展示戰鬥
            startTutorialBattle();
        };

        // 啟動教學戰鬥序列
        function startTutorialBattle() {
            if (tutorialBattleState.inProgress) return;
            tutorialBattleState.inProgress = true;

            // 延遲一秒後開始相應階段的戰鬥
            setTimeout(() => {
                if (tutorialBattleState.stage === 0) {
                    // 第一階段：展示戰鬥 - 電腦自動對戰演示
                    console.log("開始第一階段：戰鬥示範 (Nu高達 vs 沙薩比)");

                    // 建立攻擊者 (Nu高達, 藍方) 和防守者 (沙薩比, 紅方)
                    const attackerPiece = {
                        id: 'nu_gundam',
                        team: BLUE,
                        type: 'Nu高達',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/uUhvX3b.png',
                        hit: 4,
                        dodge: 4
                    };

                    const defenderPiece = {
                        id: 'sazabi',
                        team: RED,
                        type: '沙薩比',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/90O9E1o.png',
                        hit: 4,
                        dodge: 4
                    };

                    // 替換結束戰鬥的函數，以便戰鬥結束後進入下一階段
                    const originalEndCombat = endCombat;
                    endCombat = function(winner) {
                        originalEndCombat(winner);

                        // 等待戰鬥結果顯示後進入下一階段
                        setTimeout(() => {
                            tutorialBattleState.stage = 1;
                            tutorialBattleState.inProgress = false;
                            startTutorialBattle(); // 啟動第二階段
                        }, 2000);
                    };

                    // 啟動展示戰鬥
                    startCombat(attackerPiece, defenderPiece, {row: 7, col: 3}, {row: 0, col: 3});

                } else if (tutorialBattleState.stage === 1) {
                    // 第二階段：玩家防守 - 由玩家扮演防守者
                    console.log("開始第二階段：玩家防守 (玩家Nu高達防守 vs 電腦沙薩比攻擊)");

                    // 建立攻擊者 (沙薩比, 現在為紅方) 和防守者 (Nu高達, 現在為藍方)
                    // 注意：我們交換了角色，但保持陣營顏色以確保玩家控制藍方
                    const attackerPiece = {
                        id: 'sazabi',
                        team: RED,
                        type: '沙薩比',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/90O9E1o.png',
                        hit: 4,
                        dodge: 4
                    };

                    const defenderPiece = {
                        id: 'nu_gundam',
                        team: BLUE,
                        type: 'Nu高達',
                        moveType: QUEEN,
                        imgUrl: 'https://i.imgur.com/uUhvX3b.png',
                        hit: 4,
                        dodge: 4
                    };

                    // 替換結束戰鬥的函數，以便戰鬥結束後返回封面頁面
                    const originalEndCombat = endCombat;
                    endCombat = function(winner) {
                        originalEndCombat(winner);

                        // 等待戰鬥結果顯示後返回封面頁面
                        setTimeout(() => {
                            tutorialBattleState.stage = 2;
                            tutorialBattleState.inProgress = false;

                            // 返回封面頁面
                            combatOverlay.classList.add('hidden');
                            showCoverPage();

                            // 恢復原始的endCombat函數
                            endCombat = originalEndCombat;
                        }, 2000);
                    };

                    // 啟動玩家防守戰鬥
                    startCombat(attackerPiece, defenderPiece, {row: 0, col: 3}, {row: 7, col: 3});
                }
            }, 1000);
        }

        // 修改combatIntroHTML变量中的HTML模板，在移动类型下方添加武器类型显示
        const combatIntroHTML = `
            <div id="combat-intro-overlay" class="fixed inset-0 bg-black bg-opacity-75 z-[150] flex items-start justify-center transition-opacity duration-500 opacity-0">
                <div class="relative w-full bg-gradient-to-b from-gray-900 to-gray-800 rounded-lg p-2 text-white overflow-hidden shadow-2xl mt-10" style="max-width: 430px;">
                    <div class="absolute inset-0 overflow-hidden">
                        <div class="stars-bg absolute inset-0"></div>
                    </div>
                    <div class="relative z-10">
                        <h2 class="text-center text-lg font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-blue-500">戰鬥即將開始!</h2>

                        <div class="flex flex-col md:flex-row justify-between items-center space-y-3 md:space-y-0 md:space-x-2">
                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-red-500 to-pink-600 text-white py-1 px-2 rounded-t-lg font-bold text-xs">
                                    攻擊方
                                </div>
                                <div class="bg-gray-900 p-2 rounded-b-lg border-2 border-t-0 border-pink-500">
                                    <img id="intro-attacker-img" src="" alt="攻擊機體" class="w-20 h-20 object-contain mx-auto mb-1">
                                    <h3 id="intro-attacker-name" class="text-sm font-bold mb-0.5 text-pink-300">攻擊機體名稱</h3>
                                    <p id="intro-attacker-type" class="text-xs mb-1 text-gray-300">移動類型</p>
                                    <p id="intro-attacker-weapon" class="text-xs mb-1 text-yellow-300">武器類型</p>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-pink-400 font-bold text-xs">命中:</span>
                                        <span id="intro-attacker-hit" class="font-mono font-bold text-pink-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 mb-1 rounded-full overflow-hidden">
                                        <div id="intro-attacker-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-cyan-400 font-bold text-xs">迴避:</span>
                                        <span id="intro-attacker-dodge" class="font-mono font-bold text-cyan-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 rounded-full overflow-hidden">
                                        <div id="intro-attacker-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="relative">
                                <div class="w-8 h-8 bg-gradient-to-r from-pink-500 to-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                                    VS
                                </div>
                                <div class="absolute -top-1 -left-1 w-2 h-2 bg-yellow-400 rounded-full animate-ping opacity-70"></div>
                                <div class="absolute -bottom-1 -right-1 w-2 h-2 bg-blue-400 rounded-full animate-ping opacity-70 animation-delay-500"></div>
                            </div>

                            <div class="flex-1 text-center">
                                <div class="bg-gradient-to-r from-cyan-500 to-blue-600 text-white py-1 px-2 rounded-t-lg font-bold text-xs">
                                    防守方
                                </div>
                                <div class="bg-gray-900 p-2 rounded-b-lg border-2 border-t-0 border-cyan-500">
                                    <img id="intro-defender-img" src="" alt="防守機體" class="w-20 h-20 object-contain mx-auto mb-1">
                                    <h3 id="intro-defender-name" class="text-sm font-bold mb-0.5 text-cyan-300">防守機體名稱</h3>
                                    <p id="intro-defender-type" class="text-xs mb-1 text-gray-300">移動類型</p>
                                    <p id="intro-defender-weapon" class="text-xs mb-1 text-yellow-300">武器類型</p>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-pink-400 font-bold text-xs">命中:</span>
                                        <span id="intro-defender-hit" class="font-mono font-bold text-pink-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 mb-1 rounded-full overflow-hidden">
                                        <div id="intro-defender-hit-bar" class="bg-gradient-to-r from-pink-500 to-pink-400 h-full rounded-full"></div>
                                    </div>
                                    <div class="flex items-center justify-between mb-0.5">
                                        <span class="text-cyan-400 font-bold text-xs">迴避:</span>
                                        <span id="intro-defender-dodge" class="font-mono font-bold text-cyan-300 text-xs">0</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1 rounded-full overflow-hidden">
                                        <div id="intro-defender-dodge-bar" class="bg-gradient-to-r from-cyan-500 to-cyan-400 h-full rounded-full"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="text-center mt-2">
                            <div id="intro-countdown" class="hidden">3</div>
                            <p class="text-gray-300 text-xs font-bold animate-pulse">準備進入戰鬥!</p>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Start combat mode with introduction window
        function startCombat(attackerPiece, defenderPiece, attackerPos, defenderPos) {
            // Store combat information
            preloadCombatSounds();
            combatMode.active = true;
            combatMode.attacker = attackerPiece;
            combatMode.defender = defenderPiece;
            combatMode.attackerPos = attackerPos;
            combatMode.defenderPos = defenderPos;

            // Determine if player is attacker or defender
            if (gameState.gameMode === 'single-player') {
                combatMode.isPlayerAttacker = attackerPiece.team === BLUE;
                combatMode.isPlayerDefender = defenderPiece.team === BLUE;
            }

            // 在戰鬥前暫停關卡背景音樂，但不清除它，以便戰鬥結束後可以繼續播放
            if (boardBgmPlayer) {
                boardBgmPlayer.pause();
            }

            // 在戰鬥資訊頁就開始播放BGM
            // 只為玩家棋子播放BGM
            if (combatMode.attacker.team === BLUE && combatMode.attacker.bgmtype) {
                // 攻擊者是玩家且有bgmtype
                playBattleBGM(combatMode.attacker.bgmtype);
            } else if (combatMode.defender.team === BLUE && combatMode.defender.bgmtype) {
                // 防守者是玩家且有bgmtype
                playBattleBGM(combatMode.defender.bgmtype);
            }

            // 創建並顯示介紹彈窗
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = combatIntroHTML;
            const introOverlay = tempDiv.firstElementChild;
            document.body.appendChild(introOverlay);

            // 暗化棋盤元素
            const boardDim = document.createElement('div');
            boardDim.id = 'board-dim';
            boardDim.className = 'fixed inset-0 bg-black bg-opacity-60 z-[140] transition-opacity duration-500 opacity-0';
            document.body.appendChild(boardDim);

            // 取得移動類型的中文名稱
            function getMoveTypeText(moveType) {
                switch(moveType) {
                    case PAWN: return "步兵";
                    case ROOK: return "城堡";
                    case KNIGHT: return "騎士";
                    case BISHOP: return "主教";
                    case QUEEN: return "皇后";
                    case KING: return "國王";
                    default: return "";
                }
            }

            function getWeaponTypeText(crosshairType) {
                switch(crosshairType) {
                    case "Beam_Rifie": return "光束步槍";
                    case "Beam_Saber": return "光束劍";
                    case "Cosmo_Nova": return "宇宙新星";
                    case "Destructive_Thunder": return "破壞雷電";
                    case "Getter_Beam": return "三一死光"; 
                    case "diamond": return "鑽石光束";
                    case "triangle": return "三角光束";
                    case "custom": return "自定義武器";
                    default: return crosshairType || "未知武器";
                }
            }

            // 填充介紹視窗數據
            const maxValue = 5; // 假設最大值是5

            // 攻擊方數據
            document.getElementById('intro-attacker-img').src = attackerPiece.imgUrl;
            document.getElementById('intro-attacker-name').textContent = attackerPiece.type;
            document.getElementById('intro-attacker-type').textContent = `移動類型: ${getMoveTypeText(attackerPiece.moveType)}`;
            document.getElementById('intro-attacker-weapon').textContent = `武器類型: ${getWeaponTypeText(attackerPiece.crosshairType)}`;
            document.getElementById('intro-attacker-hit').textContent = attackerPiece.hit;
            document.getElementById('intro-attacker-dodge').textContent = attackerPiece.dodge;
            document.getElementById('intro-attacker-hit-bar').style.width = `${(attackerPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-attacker-dodge-bar').style.width = `${(attackerPiece.dodge / maxValue) * 100}%`;

            // 防守方數據
            document.getElementById('intro-defender-img').src = defenderPiece.imgUrl;
            document.getElementById('intro-defender-name').textContent = defenderPiece.type;
            document.getElementById('intro-defender-type').textContent = `移動類型: ${getMoveTypeText(defenderPiece.moveType)}`;
            document.getElementById('intro-defender-weapon').textContent = `武器類型: ${getWeaponTypeText(defenderPiece.crosshairType)}`;
            document.getElementById('intro-defender-hit').textContent = defenderPiece.hit;
            document.getElementById('intro-defender-dodge').textContent = defenderPiece.dodge;
            document.getElementById('intro-defender-hit-bar').style.width = `${(defenderPiece.hit / maxValue) * 100}%`;
            document.getElementById('intro-defender-dodge-bar').style.width = `${(defenderPiece.dodge / maxValue) * 100}%`;

            // 延遲顯示元素，創造淡入效果
            setTimeout(() => {
                introOverlay.style.opacity = '1';
                boardDim.style.opacity = '1';
            }, 50);

            // 倒數計時
            let countdown = 3;
            const countdownEl = document.getElementById('intro-countdown');

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);

                    // 淡出介紹視窗和暗化層
                    introOverlay.style.opacity = '0';
                    boardDim.style.opacity = '0';

                    // 移除元素並開始戰鬥
                    setTimeout(() => {
                        if (introOverlay.parentNode) introOverlay.parentNode.removeChild(introOverlay);
                        if (boardDim.parentNode) boardDim.parentNode.removeChild(boardDim);

                        // 初始化戰鬥模式
                        initCombat();
                    }, 500); // 等待淡出動畫完成
                } else {
                    countdownEl.textContent = countdown;
                }
            }, 1000);

            // 實際初始化戰鬥
            function initCombat() {
                // Reset combat state
                combatMode.timer = 3;
                combatMode.timeRemaining = 3000;
                combatMode.lastFrameTime = 0;
                combatMode.bulletFired = false;
                combatMode.defenderMoving = false;
                combatMode.result = null;

                // 先隱藏結果文字
                combatResult.classList.remove('show');

                // 初始化太空背景
                initSpaceBackground();

                // 先顯示戰鬥容器
                combatOverlay.classList.remove('hidden');

                // 使用requestAnimationFrame等待下一繪製幀
                requestAnimationFrame(() => {
                    // 再用setTimeout給DOM一點時間完成實際渲染
                    setTimeout(() => {
                        // 獲取容器矩形尺寸（在容器完全渲染後）
                        const containerRect = combatContainer.getBoundingClientRect();

                        // 容器尺寸測量完成

                        // 設置角色信息顯示
                        attackerRole.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                        defenderRole.style.display = combatMode.isPlayerDefender ? 'block' : 'none';
                        attackerInstruction.style.display = combatMode.isPlayerAttacker ? 'block' : 'none';
                        defenderInstruction.style.display = combatMode.isPlayerDefender ? 'block' : 'none';

                        // 設置基於攻擊者命中值的十字準星大小（百分比方式）
                        // 計算百分比尺寸：(100% + (命中值-2)*35%) * (20% 的容器寬度)
                        const containerWidth = containerRect.width;
                        const baseSizePercent = 20; // 基礎大小為容器的20%
                        const hitMultiplier = 1 + (attackerPiece.hit - 2) * 0.35; // 命中值修正因子
                        const crosshairSizePercent = hitMultiplier * baseSizePercent;
                        combatMode.crosshairSize = containerWidth * (crosshairSizePercent / 100);
                        crosshair.style.width = `${crosshairSizePercent}%`;
                        crosshair.style.height = `${crosshairSizePercent}%`;

                        // 获取武器颜色和准星类型
                        const weaponColor = attackerPiece.weapon_colour || '#FF1493'; // 默认深粉红色
                        const crosshairType = attackerPiece.crosshairType || 'Beam_Rifie'; // 默认圆形

                        // 删除旧的准星内容
                        while (crosshair.firstChild) {
                            crosshair.removeChild(crosshair.firstChild);
                        }

                        // 创建新的准星元素
                        const newCrosshair = createCrosshair(crosshairType, weaponColor, combatMode.crosshairSize);

                        // 将新准星的内容添加到现有准星容器
                        crosshair.innerHTML = newCrosshair.innerHTML;

                        // 設置防守者尺寸為容器寬度的百分比
                        defender.style.width = `${combatMode.defenderSizePercent}%`;
                        defender.style.height = `${combatMode.defenderSizePercent}%`;

                        // 計算實際的防守者尺寸（基於容器寬度的百分比）
                        const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);

                        // 防守者速度基於容器寬度的百分比
                        // 計算速度百分比：(回避值 - 2)*乘數 + 基值 的容器寬度/幀
                        // 若玩家是防守者，使用較低的速度
                        let speedMultiplier = 1.5; // 默認乘數
                        let speedBase = 3; // 默認基值

                        if (combatMode.isPlayerDefender) {
                            // 玩家作為防守者時，降低移動速度
                            speedMultiplier = 0.8; // 降低乘數
                            speedBase = 1.5; // 降低基值
                        }

                        // 现在defenderSpeedPercent代表每秒移动多少百分比的容器宽度
                        const defenderSpeedPercent = (defenderPiece.dodge - 2) * speedMultiplier + speedBase;
                        // 转换为每秒多少像素
                        combatMode.defenderSpeed = containerRect.width * (defenderSpeedPercent / 100);

                        // Update combat info panel
                        attackerName.textContent = attackerPiece.type;
                        defenderName.textContent = defenderPiece.type;
                        attackerImage.src = attackerPiece.imgUrl;
                        defenderImage.src = defenderPiece.imgUrl;

                        // Apply responsive sizing to combat elements based on container width
                        const infoContainer = document.querySelector('.combat-info-panel');
                        if (infoContainer) {
                            const attackerInfo = document.querySelector('.attacker-info');
                            const defenderInfo = document.querySelector('.defender-info');
                            if (attackerInfo && defenderInfo) {
                                attackerInfo.style.height = '24%';
                                defenderInfo.style.height = '24%';
                            }
                        }

                        // Set stat bars
                        const maxHit = 5; // Assume 5 is max hit value
                        const maxDodge = 5; // Assume 5 is max dodge value

                        const hitPercentage = (attackerPiece.hit / maxHit) * 100;
                        const dodgePercentage = (defenderPiece.dodge / maxDodge) * 100;

                        attackerHitBar.style.width = `${hitPercentage}%`;
                        defenderDodgeBar.style.width = `${dodgePercentage}%`;

                        // Set combat info text
                        combatInfo.textContent = `${attackerPiece.type} vs ${defenderPiece.type}`;

                        // Set defender image
                        defender.innerHTML = `<img src="${defenderPiece.imgUrl}" alt="${defenderPiece.type}">`;

                        // 將防守者隨機放置在四個預設位置之一
                        // 隨機選擇一個位置 (0-3)
                        const positionIndex = Math.floor(Math.random() * 4);
                        let xPercent, yPercent;

                        // 根據隨機數選擇位置
                        switch(positionIndex) {
                            case 0: // 右下角
                                xPercent = 0.8;
                                yPercent = 0.8;
                                break;
                            case 1: // 右上角
                                xPercent = 0.8;
                                yPercent = 0.2;
                                break;
                            case 2: // 左下角
                                xPercent = 0.2;
                                yPercent = 0.8;
                                break;
                            case 3: // 左上角
                                xPercent = 0.2;
                                yPercent = 0.2;
                                break;
                        }

                        // 設置防守者位置為計算出的坐標
                        combatMode.defenderX = containerRect.width * xPercent;
                        combatMode.defenderY = containerRect.height * yPercent;

                        // 更新視覺位置
                        defender.style.left = `${combatMode.defenderX}px`;
                        defender.style.top = `${combatMode.defenderY}px`;

                        // 初始化防守者坐標完成
                        stopBoardBGM();

                        // Start crosshair near the defender but not directly on it
                        if (combatMode.isPlayerAttacker) {
                            combatMode.mouseX = containerRect.width / 2 + 50;
                            combatMode.mouseY = containerRect.height / 2 + 50;
                        } else {
                            // For AI, initialize offscreen until game starts
                            combatMode.mouseX = -100;
                            combatMode.mouseY = -100;
                        }

                        // 初始化滑鼠及準星位置完成

                        crosshair.style.left = `${combatMode.mouseX}px`;
                        crosshair.style.top = `${combatMode.mouseY}px`;

                        // Add event listeners for combat
                        if (combatMode.isPlayerAttacker) {
                            combatContainer.addEventListener('mousemove', handleAttackerMouseMove);
                            combatContainer.addEventListener('click', handleAttackerClick);
                            combatContainer.addEventListener('touchmove', handleAttackerTouchMove);
                            combatContainer.addEventListener('touchstart', handleAttackerTouch);
                        }

                        if (combatMode.isPlayerDefender) {
                            combatContainer.addEventListener('mousemove', handleDefenderMouseMove);
                            combatContainer.addEventListener('click', handleDefenderClick);
                            combatContainer.addEventListener('touchmove', handleDefenderTouchMove);
                            combatContainer.addEventListener('touchstart', handleDefenderTouch);

                            // Show the defender target indicator
                            defenderTarget.style.display = 'block';
                        }

                        // Start AI if needed
                        if (!combatMode.isPlayerAttacker) {
                            setTimeout(startAIAttacker, 1000); // Slight delay before AI attacks
                        }

                        if (!combatMode.isPlayerDefender) {
                            startAIDefender();
                        }

                        // Start combat animation frame loop
                        requestAnimationFrame(updateCombat);
                    }, 50); // 給DOM 50ms的時間完成渲染
                });
            }
        }

        // Handle attacker mouse movement
        function handleAttackerMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;

            const rect = combatContainer.getBoundingClientRect();

            // Get mouse position relative to container
            combatMode.mouseX = e.clientX - rect.left;
            combatMode.mouseY = e.clientY - rect.top;

            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
        }

        // Handle attacker touch movement
        function handleAttackerTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // Get touch position relative to container
            combatMode.mouseX = touch.clientX - rect.left;
            combatMode.mouseY = touch.clientY - rect.top;

            // Update crosshair position
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;
        }

        // Handle attacker click (shooting)
        function handleAttackerClick(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            shootLaser();
        }

        // Handle attacker touch (shooting)
        function handleAttackerTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerAttacker || combatMode.bulletFired) return;
            e.preventDefault();

            // 获取触摸点坐标
            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // 更新准星位置
            combatMode.mouseX = touch.clientX - rect.left;
            combatMode.mouseY = touch.clientY - rect.top;
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;

            // 准星位置更新后，延迟300毫秒再射击
            // 这给用户提供了瞄准的时间
            setTimeout(function() {
                if (combatMode.active && !combatMode.bulletFired) {
                    // 显示视觉反馈
                    crosshair.classList.add('firing');
                    // 射击
                    shootLaser();
                }
            }, 10);
        }

        // Handle defender mouse movement
        function handleDefenderMouseMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;

            const rect = combatContainer.getBoundingClientRect();

            // Record target position for click to move
            combatMode.defenderTargetX = e.clientX - rect.left;
            combatMode.defenderTargetY = e.clientY - rect.top;

            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }

        // Handle defender touch movement
        function handleDefenderTouchMove(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = combatContainer.getBoundingClientRect();

            // Record target position for touch to move
            combatMode.defenderTargetX = touch.clientX - rect.left;
            combatMode.defenderTargetY = touch.clientY - rect.top;

            // Update target indicator
            defenderTarget.style.left = `${combatMode.defenderTargetX}px`;
            defenderTarget.style.top = `${combatMode.defenderTargetY}px`;
        }

        // Handle defender click (evasive move)
        function handleDefenderClick(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            startDefenderMovement();
        }

        // Handle defender touch (evasive move)
        function handleDefenderTouch(e) {
            if (!combatMode.active || !combatMode.isPlayerDefender || combatMode.defenderMoving) return;
            e.preventDefault();
            startDefenderMovement();
        }

        // Start the defender movement to target
        function startDefenderMovement() {
            // 记录开始移动的时间
            combatMode.moveStartTime = Date.now();
            // 记录开始位置
            combatMode.moveStartX = combatMode.defenderX;
            combatMode.moveStartY = combatMode.defenderY;

            // 设置移动状态
            combatMode.defenderMoving = true;

            // 仍然保留时间限制确保移动不会无限持续
            setTimeout(() => {
                combatMode.defenderMoving = false;
            }, 200);
        }

        function shootLaser() {
            if (combatMode.bulletFired) return;

            combatMode.bulletFired = true;

            // 获取当前攻击者的武器颜色
            const weaponColor = combatMode.attacker.weapon_colour || '#FF1493'; // 默认深粉红色

            // 获取准星类型
            const crosshairType = combatMode.attacker.crosshairType || 'Beam_Rifie';

            // 根据准星类型播放不同的音效
            if (crosshairType === 'Beam_Saber') {
                // 播放光束剑音效
                playCombatSound(beamSaberSound);
            } else if (crosshairType === 'Cosmo_Nova') {
                // 播放宇宙新星音效
                playCombatSound(cosmoNovaSound);
            } else if (crosshairType === 'Destructive_Thunder') {
                // 播放雷电音效
                playCombatSound(thunderSound);
            } else {
                // 播放激光枪音效
                playCombatSound(beamGunSound);
            }   

            // 根据准星类型使用不同的攻击效果
            switch(crosshairType) {
                case 'Beam_Rifie':
                    createLaserBeamEffect(weaponColor);
                    break;
                case 'Beam_Saber':
                    createEnergyPulseEffect(weaponColor);
                    break;
                case 'Cosmo_Nova':
                    createConvergeShotEffect(weaponColor);
                    break;
                case 'Destructive_Thunder':
                    createThunderConvergenceEffect(weaponColor);
                    break;
                case 'Getter_Beam':
                    createGetterBeamEffect(weaponColor);
                    break;
                case 'diamond':
                    createScatterShotEffect(weaponColor);
                    break;
                case 'triangle':
                    createPowerBeamEffect(weaponColor);
                    break;
                case 'custom':
                    createSpiralBeamEffect(weaponColor);
                    break;
                default:
                    createLaserBeamEffect(weaponColor); // 默认使用激光效果
            }

            // Delayed hit detection - 150ms delay
            setTimeout(() => {
                // Check hit detection after delay
                checkHit();

                // If missed, end combat after a short delay
                if (!combatMode.result) {
                    setTimeout(() => {
                        endCombat('defender');
                    }, 500);
                }
            }, 150); // 延遲150毫秒進行命中判定
        }

        function createLaserBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // Create multiple laser beams for a more spectacular effect
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    // Main laser beam
                    const laser = document.createElement('div');
                    laser.className = 'laser';

                    // Position laser at crosshair
                    laser.style.left = `${combatMode.mouseX}px`;
                    laser.style.top = `${combatMode.mouseY}px`;

                    // Random angle for visual variety
                    const baseAngle = i * 60; // Spread evenly around 360 degrees
                    const angle = baseAngle + (Math.random() * 20 - 10); // Small random variation
                    const length = containerRect.width * 1.5; // Longer laser

                    laser.style.width = `${length}px`;
                    laser.style.height = `${Math.random() * 3 + 5}px`; // Thicker lasers (5-8px)
                    laser.style.transform = `rotate(${angle}deg)`;

                    // 使用棋子的武器颜色设置激光样式
                    laser.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 0.5)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.5)} 100%)`;
                    laser.style.boxShadow = `0 0 10px ${weaponColor}, 0 0 20px ${weaponColor}`;

                    combatContainer.appendChild(laser);

                    // Add a glow effect behind the laser
                    const glow = document.createElement('div');
                    glow.className = 'laser-glow';
                    glow.style.left = `${combatMode.mouseX}px`;
                    glow.style.top = `${combatMode.mouseY}px`;
                    glow.style.width = `${length}px`;
                    glow.style.height = `${Math.random() * 10 + 20}px`; // Thicker glow
                    glow.style.transform = `rotate(${angle}deg)`;

                    // 设置光晕颜色
                    glow.style.background = hexToRgba(weaponColor, 0.1);

                    combatContainer.appendChild(glow);

                    // Remove after animation
                    setTimeout(() => {
                        if (laser.parentNode) laser.parentNode.removeChild(laser);
                        if (glow.parentNode) glow.parentNode.removeChild(glow);
                    }, 300);
                }, i * 40); // Stagger the laser beams
            }
        }

        function createEnergyPulseEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // 计算长方形准星的尺寸和顶部位置
            // 假设准星的高度是宽度的6倍，为容器的outerSize*0.4*6
            const outerSize = combatMode.crosshairSize * 0.8; // 外框大小为容器大小的80%
            const frameWidth = Math.round(outerSize * 0.4);
            const frameHeight = frameWidth * 6; // 高度是宽度的6倍

            // 计算准星顶部位置（从鼠标位置上移frameHeight/2）
            const saberTopY = combatMode.mouseY - frameHeight / 2;

            // 添加必要的CSS，调整能量柱动画只到容器高度
            addCSSIfNeeded(`
                @keyframes energyPulse {
                    0% { height: 0; opacity: 0.8; }
                    30% { opacity: 1; }
                    90% { height: ${containerRect.height - saberTopY}px; }
                    100% { height: ${containerRect.height - saberTopY}px; opacity: 0; }
                }

                @keyframes pulseGlow {
                    0% { opacity: 0.3; transform: scale(1); }
                    50% { opacity: 0.6; transform: scale(1.2); }
                    100% { opacity: 0; transform: scale(1.5); }
                }

                @keyframes shockwaveRing {
                    0% { width: 0; height: 0; opacity: 0.7; }
                    100% { width: ${containerRect.width * 0.7}px; height: ${containerRect.width * 0.7}px; opacity: 0; }
                }
            `);

            // 主能量柱效果 - 从准星顶部开始
            const pulse = document.createElement('div');
            pulse.style.position = 'absolute';
            pulse.style.left = `${combatMode.mouseX}px`;
            pulse.style.top = `${saberTopY}px`; // 设置为准星顶部位置
            pulse.style.width = `${Math.max(30, containerRect.width * 0.05)}px`; // 宽度为容器宽度的5%，最小30px
            pulse.style.transformOrigin = 'center top';
            pulse.style.background = `linear-gradient(0deg, ${hexToRgba(weaponColor, 0.3)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.3)} 100%)`;
            pulse.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
            pulse.style.zIndex = '15';
            pulse.style.animation = 'energyPulse 0.45s forwards'; // 略微缩短动画时间
            pulse.style.transform = 'translateX(-50%)';
            combatContainer.appendChild(pulse);

            // 添加能量柱顶部起始特效
            const pulseStart = document.createElement('div');
            pulseStart.style.position = 'absolute';
            pulseStart.style.left = `${combatMode.mouseX}px`;
            pulseStart.style.top = `${saberTopY}px`;
            pulseStart.style.width = `${Math.max(40, containerRect.width * 0.07)}px`; // 略宽于能量柱
            pulseStart.style.height = `${Math.max(40, containerRect.width * 0.07)}px`;
            pulseStart.style.borderRadius = '50%';
            pulseStart.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, transparent 70%)`;
            pulseStart.style.boxShadow = `0 0 15px ${weaponColor}`;
            pulseStart.style.transform = 'translate(-50%, -50%)';
            pulseStart.style.zIndex = '16';
            pulseStart.style.opacity = '1';
            pulseStart.style.animation = 'pulseGlow 0.4s forwards';
            combatContainer.appendChild(pulseStart);

            // 添加脉冲圆环效果 - 在准星顶部位置
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.left = `${combatMode.mouseX}px`;
                    ring.style.top = `${saberTopY}px`; // 设置为准星顶部位置
                    ring.style.borderRadius = '50%';
                    ring.style.border = `3px solid ${hexToRgba(weaponColor, 0.7)}`;
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.zIndex = '14';
                    ring.style.animation = 'shockwaveRing 0.7s forwards ease-out';
                    combatContainer.appendChild(ring);

                    setTimeout(() => {
                        if (ring.parentNode) ring.parentNode.removeChild(ring);
                    }, 700);
                }, i * 150); // 加快圆环出现频率
            }

            // 添加地面光晕效果 - 准星与地面相交位置
            setTimeout(() => {
                const glow = document.createElement('div');
                glow.style.position = 'absolute';
                glow.style.left = `${combatMode.mouseX}px`;
                glow.style.top = `${containerRect.height}px`; // 底部
                glow.style.width = `${Math.max(70, containerRect.width * 0.12)}px`; // 稍微增加宽度
                glow.style.height = `${Math.max(35, containerRect.height * 0.06)}px`; // 稍微增加高度
                glow.style.background = `radial-gradient(ellipse at center, ${hexToRgba(weaponColor, 0.9)} 0%, ${hexToRgba(weaponColor, 0.2)} 60%, transparent 100%)`;
                glow.style.borderRadius = '50%';
                glow.style.filter = 'blur(6px)'; // 增强模糊效果
                glow.style.transform = 'translateX(-50%)';
                glow.style.zIndex = '13';
                glow.style.animation = 'pulseGlow 0.8s forwards';
                combatContainer.appendChild(glow);

                // 添加地面冲击波
                const groundRing = document.createElement('div');
                groundRing.style.position = 'absolute';
                groundRing.style.left = `${combatMode.mouseX}px`;
                groundRing.style.top = `${containerRect.height}px`; // 底部
                groundRing.style.transform = 'translate(-50%, 0)';
                groundRing.style.borderRadius = '50% 50% 0 0'; // 只有上半圆
                groundRing.style.height = `${containerRect.height * 0.05}px`;
                groundRing.style.border = `2px solid ${hexToRgba(weaponColor, 0.6)}`;
                groundRing.style.borderBottom = 'none';
                groundRing.style.zIndex = '12';
                groundRing.style.opacity = '0.7';
                groundRing.style.animation = 'shockwaveRing 0.6s forwards ease-out';
                groundRing.style.width = '0';
                combatContainer.appendChild(groundRing);

                setTimeout(() => {
                    if (groundRing.parentNode) groundRing.parentNode.removeChild(groundRing);
                    if (glow.parentNode) glow.parentNode.removeChild(glow);
                }, 800);
            }, 150); // 能量柱到达地面的时间

            // 清理元素
            setTimeout(() => {
                if (pulse.parentNode) pulse.parentNode.removeChild(pulse);
                if (pulseStart.parentNode) pulseStart.parentNode.removeChild(pulseStart);
            }, 800);
        }

        function createConvergeShotEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // 添加必要的CSS
            addCSSIfNeeded(`
                @keyframes convergeShot {
                    0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.3; }
                    90% { transform: translate(-50%, -50%) scale(0.4); opacity: 0.8; }
                    100% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; }
                }
        
                @keyframes centralExplosion {
                    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; }
                    50% { opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
                }

                @keyframes convergeParticle {
                    0% { transform: translate(var(--tx), var(--ty)) scale(1); opacity: 1; }
                    90% { transform: translate(0, 0) scale(0.6); opacity: 0.8; }
                    100% { transform: translate(0, 0) scale(0.2); opacity: 0; }
                }
            `);

            // 创建中心汇聚区域
            const convergeZone = document.createElement('div');
            convergeZone.style.position = 'absolute';
            convergeZone.style.left = `${combatMode.mouseX}px`;
            convergeZone.style.top = `${combatMode.mouseY}px`;
            convergeZone.style.width = `${containerRect.width * 0.05}px`; // 初始较小
            convergeZone.style.height = `${containerRect.width * 0.05}px`;
            convergeZone.style.borderRadius = '50%';
            convergeZone.style.background = `radial-gradient(circle, ${hexToRgba(weaponColor, 0.7)} 0%, ${hexToRgba(weaponColor, 0.3)} 70%, transparent 100%)`;
            convergeZone.style.boxShadow = `0 0 10px ${weaponColor}`;
            convergeZone.style.zIndex = '16';
            convergeZone.style.animation = 'convergeShot 0.7s forwards';
            convergeZone.style.transform = 'translate(-50%, -50%) scale(1.5)';
            combatContainer.appendChild(convergeZone);

            // 创建汇聚粒子
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) + (Math.random() * 20 - 10); // 将360度分成12份
                const radian = (angle * Math.PI) / 180;
                const distance = containerRect.width * (0.2 + Math.random() * 0.3); // 20%-50%的容器宽度

                const tx = Math.cos(radian) * distance;
                const ty = Math.sin(radian) * distance;

                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.left = `${combatMode.mouseX}px`;
                particle.style.top = `${combatMode.mouseY}px`;
                particle.style.width = `${8 + Math.random() * 7}px`; // 8-15px
                particle.style.height = `${8 + Math.random() * 7}px`;
                particle.style.borderRadius = '50%';
                particle.style.background = `${hexToRgba(weaponColor, 0.9)}`;
                particle.style.boxShadow = `0 0 10px ${weaponColor}`;
                particle.style.zIndex = '17';

                // 使用CSS变量传递不同的起始位置（与散射相反）
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                // 初始位置设置在外围
                particle.style.transform = `translate(${tx}px, ${ty}px)`;
                particle.style.animation = 'convergeParticle 0.7s forwards';

                combatContainer.appendChild(particle);

                // 清理粒子
                setTimeout(() => {
                    if (particle.parentNode) particle.parentNode.removeChild(particle);
                }, 700);
            }

            // 粒子汇聚后，创建中心爆炸效果
            setTimeout(() => {
                const centerExplosion = document.createElement('div');
                centerExplosion.style.position = 'absolute';
                centerExplosion.style.left = `${combatMode.mouseX}px`;
                centerExplosion.style.top = `${combatMode.mouseY}px`;
                centerExplosion.style.width = `${containerRect.width * 0.15}px`; // 比初始区域大
                centerExplosion.style.height = `${containerRect.width * 0.15}px`;
                centerExplosion.style.borderRadius = '50%';
                centerExplosion.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, ${hexToRgba(weaponColor, 0.2)} 70%, transparent 100%)`;
                centerExplosion.style.boxShadow = `0 0 30px ${weaponColor}, 0 0 50px ${weaponColor}`;
                centerExplosion.style.zIndex = '18';
                centerExplosion.style.animation = 'centralExplosion 0.5s forwards';
                centerExplosion.style.transform = 'translate(-50%, -50%) scale(0.2)';
                combatContainer.appendChild(centerExplosion);

                // 添加光晕波纹
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const ripple = document.createElement('div');
                        ripple.style.position = 'absolute';
                        ripple.style.left = `${combatMode.mouseX}px`;
                        ripple.style.top = `${combatMode.mouseY}px`;
                        ripple.style.width = `${containerRect.width * 0.1 * (i+1)}px`;
                        ripple.style.height = `${containerRect.width * 0.1 * (i+1)}px`;
                        ripple.style.borderRadius = '50%';
                        ripple.style.border = `2px solid ${hexToRgba(weaponColor, 0.8 - i*0.2)}`;
                        ripple.style.boxShadow = `0 0 15px ${weaponColor}`;
                        ripple.style.zIndex = '17';
                        ripple.style.transform = 'translate(-50%, -50%) scale(0)';
                        ripple.style.animation = 'centralExplosion 0.4s forwards';
                        combatContainer.appendChild(ripple);

                        // 清理波纹
                        setTimeout(() => {
                            if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
                        }, 400);
                    }, i * 100); // 依次产生波纹
                }

                // 清理中心爆炸
                setTimeout(() => {
                    if (centerExplosion.parentNode) centerExplosion.parentNode.removeChild(centerExplosion);
                }, 500);
            }, 650); // 在粒子快要汇聚完成时触发爆炸

            // 清理汇聚区域
            setTimeout(() => {
                if (convergeZone.parentNode) convergeZone.parentNode.removeChild(convergeZone);
            }, 700);
        }

        function createThunderConvergenceEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();
            const centerX = combatMode.mouseX;
            const centerY = combatMode.mouseY;
    
            // 添加必要的CSS - 简化动画定义
            addCSSIfNeeded(`
                @keyframes thunderBolt {
                    0% { stroke-dashoffset: 2000; opacity: 0; }
                    15% { opacity: 1; }
                    40% { stroke-dashoffset: 0; opacity: 1; }
                    100% { opacity: 0; }
                }

                @keyframes thunderPulse {
                    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
                    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }

                @keyframes thunderRipple {
                    0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; stroke-width: 8px; }
                    100% { transform: translate(-50%, -50%) scale(3); opacity: 0; stroke-width: 1px; }
                }
            `);

            // 闪电颜色：主色和高亮色
            const baseColor = weaponColor;
            const highlightColor = '#FFFFFF'; // 白色高亮部分

            // 中心爆发效果
            const centerEffect = document.createElement('div');
            centerEffect.style.position = 'absolute';
            centerEffect.style.left = `${centerX}px`;
            centerEffect.style.top = `${centerY}px`;
            centerEffect.style.width = `${containerRect.width * 0.15}px`;
            centerEffect.style.height = `${containerRect.width * 0.15}px`;
            centerEffect.style.borderRadius = '50%';
            centerEffect.style.background = `radial-gradient(circle, ${highlightColor} 0%, ${hexToRgba(baseColor, 0.9)} 30%, ${hexToRgba(baseColor, 0.2)} 70%, transparent 100%)`;
            centerEffect.style.boxShadow = `0 0 30px ${baseColor}, 0 0 50px ${baseColor}`;
            centerEffect.style.zIndex = '19';
            centerEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
            centerEffect.style.animation = 'thunderPulse 0.8s forwards';
            combatContainer.appendChild(centerEffect);
    
            // 优化点1: 从四个方向创建汇聚的闪电，但减少每个方向的闪电数量
            const directions = [
                { angle: 45, label: 'rightDown'}, // 右下
                { angle: 135, label: 'leftDown'}, // 左下
                { angle: 225, label: 'leftUp'},   // 左上
                { angle: 315, label: 'rightUp'}   // 右上
            ];

            // 优化点1: 减少闪电数量 - 从2-4条减少到1-2条
            directions.forEach((dir, i) => {
                // 减少闪电数量
                const boltCount = 1 + Math.floor(Math.random() * 2);
        
                for (let j = 0; j < boltCount; j++) {
                    setTimeout(() => {
                        createLightningBolt(dir.angle, i * 80 + j * 60, j);
                }, i * 80 + j * 60);
                }
            });

            // 优化点4: 减少漣漪效果 - 只保留1个涟漪
            setTimeout(() => {
                const ripple = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                ripple.style.position = 'absolute';
                ripple.style.left = '0';
                ripple.style.top = '0';
                ripple.style.width = '100%';
                ripple.style.height = '100%';
                ripple.style.zIndex = '17';
                ripple.setAttribute('viewBox', `0 0 ${containerRect.width} ${containerRect.height}`);
        
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', containerRect.width * 0.1);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', baseColor);
                circle.setAttribute('stroke-width', '3');
                circle.style.animation = 'thunderRipple 0.8s forwards';
                circle.style.transformOrigin = `${centerX}px ${centerY}px`;
                circle.style.filter = `drop-shadow(0 0 5px ${baseColor})`;
        
                ripple.appendChild(circle);
                combatContainer.appendChild(ripple);
        
                setTimeout(() => {
                    if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
                }, 1000);
            }, 800);

            // 创建中心爆发光圈效果
            setTimeout(() => {
                // 中心爆发光圈
                const burstEffect = document.createElement('div');
                burstEffect.style.position = 'absolute';
                burstEffect.style.left = `${centerX}px`;
                burstEffect.style.top = `${centerY}px`;
                burstEffect.style.width = `${containerRect.width * 0.35}px`; // 稍微减小爆发范围
                burstEffect.style.height = `${containerRect.width * 0.35}px`;
                burstEffect.style.borderRadius = '50%';
                burstEffect.style.background = `radial-gradient(circle, ${highlightColor} 0%, ${hexToRgba(baseColor, 0.5)} 40%, transparent 70%)`;
                burstEffect.style.boxShadow = `0 0 60px ${baseColor}`; // 减少阴影层级
                burstEffect.style.zIndex = '20';
                burstEffect.style.transform = 'translate(-50%, -50%) scale(0.1)';
                burstEffect.style.animation = 'thunderPulse 0.8s forwards';
                burstEffect.style.opacity = '0.9';
                combatContainer.appendChild(burstEffect);

                setTimeout(() => {
                    if (burstEffect.parentNode) burstEffect.parentNode.removeChild(burstEffect);
                }, 800);
        
                // 优化点4: 减少散射效果 - 从12条减少到6条
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60); // 改为每60度一条
                    setTimeout(() => {
                        const scatter = document.createElement('div');
                        scatter.style.position = 'absolute';
                        scatter.style.left = `${centerX}px`;
                        scatter.style.top = `${centerY}px`;
                        scatter.style.width = '4px';
                        scatter.style.height = `${30 + Math.random() * 20}px`;
                        scatter.style.background = baseColor;
                        scatter.style.boxShadow = `0 0 8px ${baseColor}`; // 减少阴影强度
                        scatter.style.zIndex = '16';
                        scatter.style.transformOrigin = 'center bottom';
                        scatter.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                
                        // 创建动画
                        const keyframes = `
                            @keyframes scatterAnim${i} {
                                0% { transform: translate(-50%, -100%) rotate(${angle}deg) scaleY(0.1); opacity: 1; }
                                100% { transform: translate(-50%, -100%) rotate(${angle}deg) scaleY(${3 + Math.random() * 2}); opacity: 0; }
                            }
                        `;
                        addCSSIfNeeded(keyframes);
                        scatter.style.animation = `scatterAnim${i} 0.5s forwards`;
                    
                        combatContainer.appendChild(scatter);
                        setTimeout(() => {
                            if (scatter.parentNode) scatter.parentNode.removeChild(scatter);
                        }, 500);
                    }, Math.random() * 150);
                }
            }, 850); // 当所有闪电汇聚到中心后

            // 清理中心效果
            setTimeout(() => {
                if (centerEffect.parentNode) centerEffect.parentNode.removeChild(centerEffect);
            }, 1000);
    
            // 创建闪电效果函数
            function createLightningBolt(angle, delay, index) {
                // 使用 SVG 创建闪电路径
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.style.position = 'absolute';
                svg.style.left = '0';
                svg.style.top = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '18';
                svg.setAttribute('viewBox', `0 0 ${containerRect.width} ${containerRect.height}`);

                // 计算起点和终点
                const distance = Math.max(containerRect.width, containerRect.height) * 0.8;

                // 根据角度计算起点（从边缘开始）
                const startX = centerX + Math.cos(angle * Math.PI / 180) * distance;
                const startY = centerY + Math.sin(angle * Math.PI / 180) * distance;

                // 设定主闪电的宽度 - 保持闪电粗细但更高效
                const mainWidth = 5 + Math.floor(Math.random() * 3); // 5-7px
        
                // 生成闪电的路径
                const paths = [];
        
                // 主闪电路径
                const mainPath = generateLightningPath(startX, startY, centerX, centerY, 0.3, 5, index);
                const mainLightning = createLightningPathElement(mainPath, baseColor, mainWidth, 0.9, delay);
                paths.push(mainLightning);
        
                // 闪电内发光效果
                const innerGlow = createLightningPathElement(mainPath, highlightColor, mainWidth * 0.6, 0.7, delay);
                paths.push(innerGlow);
        
                // 优化点3: 减少模糊效果 - 只保留一层外发光，减少模糊半径
                const outerGlow = createLightningPathElement(mainPath, baseColor, mainWidth * 2, 0.3, delay);
                outerGlow.setAttribute('filter', `blur(3px)`); // 减少模糊半径
                paths.push(outerGlow);
        
                // 优化点2: 减少分支闪电 - 控制在0-1个分支
                const branchCount = Math.floor(Math.random() * 2); // 0或1个分支
            
                for (let i = 0; i < branchCount; i++) {
                    const segmentIndex = Math.floor(Math.random() * 3) + 1;
                    const segmentRatio = (segmentIndex / 5) + Math.random() * 0.15;
            
                    const branchStartX = startX * (1 - segmentRatio) + centerX * segmentRatio;
                    const branchStartY = startY * (1 - segmentRatio) + centerY * segmentRatio;
            
                    // 随机分支角度偏移
                    const branchAngleOffset = (Math.random() * 60 - 30);
                    const branchAngle = angle + branchAngleOffset;
            
                    // 计算分支终点 - 缩短分支长度
                    const branchLength = distance * (1 - segmentRatio) * (0.3 + Math.random() * 0.2);
                    const branchEndX = branchStartX - Math.cos(branchAngle * Math.PI / 180) * branchLength;
                    const branchEndY = branchStartY - Math.sin(branchAngle * Math.PI / 180) * branchLength;
            
                    // 生成分支路径
                    const branchPath = generateLightningPath(
                        branchStartX, branchStartY, branchEndX, branchEndY, 
                        0.4, 2, index + i + 10 // 减少分支段数
                    );
            
                    // 分支宽度较主闪电细
                    const branchWidth = mainWidth * 0.5;
            
                    // 创建分支及其发光效果
                    const branch = createLightningPathElement(branchPath, baseColor, branchWidth, 0.8, delay + 100);
                    paths.push(branch);
            
                    // 优化点3: 分支不加模糊效果
                }
        
                // 将所有路径添加到SVG
                paths.forEach(path => svg.appendChild(path));

                // 添加到容器
                combatContainer.appendChild(svg);

                // 定时清理
                setTimeout(() => {
                    if (svg.parentNode) svg.parentNode.removeChild(svg);
                }, delay + 1000); // 缩短清理时间
            }
    
            // 创建闪电路径元素
            function createLightningPathElement(pathData, color, width, opacity, delay) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', width);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', opacity);
        
                // 简化发光效果
                path.setAttribute('filter', `drop-shadow(0 0 2px ${color})`);
        
                // 添加闪电动画
                path.style.strokeDasharray = 2000;
                path.style.strokeDashoffset = 2000;
                path.style.animation = `thunderBolt 0.8s ${delay}ms forwards`; // 缩短动画时间
        
                return path;
            }
    
            // 生成闪电路径数据 - 使用更简单的算法
            function generateLightningPath(startX, startY, endX, endY, displacementFactor, segments, seed) {
                let pathData = `M${startX},${startY} `;
        
                // 简化计算
                const dx = (endX - startX) / segments;
                const dy = (endY - startY) / segments;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
        
                // 使用简化的伪随机函数
                const seededRandom = function(min, max) {
                 const x = Math.sin(seed * 9999 + arguments.callee.count++) * 10000;
                    return (x - Math.floor(x)) * (max - min) + min;
                };
        seededRandom.count = 0;
        
        let currentX = startX;
        let currentY = startY;

        for (let i = 1; i <= segments; i++) {
            // 向终点移动一段
            const ratio = i / segments;
            const targetX = startX + dx * i;
            const targetY = startY + dy * i;
    
            // 添加随机偏移（除了最后一段直接连到中心）
            if (i < segments) {
                // 随着接近终点减小偏移
                const maxDeviation = segmentLength * displacementFactor * (1 - ratio * 0.5);
                
                // 添加随机偏移
                const perpAngle = Math.atan2(endY - startY, endX - startX) + Math.PI / 2;
                const randomDeviation = seededRandom(-1, 1) * maxDeviation;
                const deviationX = Math.cos(perpAngle) * randomDeviation;
                const deviationY = Math.sin(perpAngle) * randomDeviation;
        
                currentX = targetX + deviationX;
                currentY = targetY + deviationY;
            } else {
                // 最后一段直接连到中心
                currentX = endX;
                currentY = endY;
            }
            
            pathData += `L${currentX},${currentY} `;
        }
        
        return pathData;
    }
}
        
        function createScatterShotEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // 添加必要的CSS
            addCSSIfNeeded(`
                @keyframes scatterShot {
                    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0.8; }
                    50% { opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }

                @keyframes scatterParticle {
                    0% { transform: translate(0, 0) scale(1); opacity: 1; }
                    100% { transform: translate(var(--tx), var(--ty)) scale(0.3); opacity: 0; }
                }
            `);

            // 创建中心爆破效果
            const centerBlast = document.createElement('div');
            centerBlast.style.position = 'absolute';
            centerBlast.style.left = `${combatMode.mouseX}px`;
            centerBlast.style.top = `${combatMode.mouseY}px`;
            centerBlast.style.width = `${containerRect.width * 0.1}px`; // 宽度为容器宽度的10%
            centerBlast.style.height = `${containerRect.width * 0.1}px`;
            centerBlast.style.borderRadius = '50%';
            centerBlast.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.9)} 30%, ${hexToRgba(weaponColor, 0.1)} 70%, transparent 100%)`;
            centerBlast.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
            centerBlast.style.zIndex = '18';
            centerBlast.style.animation = 'scatterShot 0.6s forwards';
            centerBlast.style.transform = 'translate(-50%, -50%) scale(0.2)';
            combatContainer.appendChild(centerBlast);

            // 创建散射粒子
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) + (Math.random() * 20 - 10); // 将360度分成12份
                const radian = (angle * Math.PI) / 180;
                const distance = containerRect.width * (0.2 + Math.random() * 0.3); // 20%-50%的容器宽度

                const tx = Math.cos(radian) * distance;
                const ty = Math.sin(radian) * distance;

                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.left = `${combatMode.mouseX}px`;
                particle.style.top = `${combatMode.mouseY}px`;
                particle.style.width = `${8 + Math.random() * 7}px`; // 8-15px
                particle.style.height = `${8 + Math.random() * 7}px`;
                particle.style.borderRadius = '50%';
                particle.style.background = `${hexToRgba(weaponColor, 0.9)}`;
                particle.style.boxShadow = `0 0 10px ${weaponColor}`;
                particle.style.zIndex = '17';

                // 使用CSS变量传递不同的移动位置
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                particle.style.animation = 'scatterParticle 0.7s forwards';

                combatContainer.appendChild(particle);

                // 清理粒子
                setTimeout(() => {
                    if (particle.parentNode) particle.parentNode.removeChild(particle);
                }, 700);
            }

            // 清理中心爆破
            setTimeout(() => {
                if (centerBlast.parentNode) centerBlast.parentNode.removeChild(centerBlast);
            }, 600);
        }

        function createPowerBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // 添加必要的CSS
            addCSSIfNeeded(`
                @keyframes powerBeam {
                    0% { transform: scaleX(0); opacity: 0.3; }
                    10% { transform: scaleX(0.1); opacity: 1; }
                    20% { transform: scaleX(1); }
                    80% { opacity: 1; width: ${containerRect.width * 1.2}px; }
                    100% { opacity: 0; width: ${containerRect.width * 1.2}px; }
                }

                @keyframes powerBeamCharge {
                    0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0.5; }
                    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
                    90% { transform: translate(-50%, -50%) scale(0.1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                }
            `);

            // 首先创建充能效果
            const chargeEffect = document.createElement('div');
            chargeEffect.style.position = 'absolute';
            chargeEffect.style.left = `${combatMode.mouseX}px`;
            chargeEffect.style.top = `${combatMode.mouseY}px`;
            chargeEffect.style.width = `${containerRect.width * 0.08}px`; // 宽度为容器宽度的8%
            chargeEffect.style.height = `${containerRect.width * 0.08}px`;
            chargeEffect.style.borderRadius = '50%';
            chargeEffect.style.background = `radial-gradient(circle, white 0%, ${hexToRgba(weaponColor, 0.8)} 30%, transparent 70%)`;
            chargeEffect.style.boxShadow = `0 0 30px ${weaponColor}`;
            chargeEffect.style.zIndex = '16';
            chargeEffect.style.animation = 'powerBeamCharge 0.4s forwards';
            chargeEffect.style.transform = 'translate(-50%, -50%) scale(0.3)';
            combatContainer.appendChild(chargeEffect);

            // 然后在充能效果结束后创建主射线
            setTimeout(() => {
                // 创建主射线
                const beam = document.createElement('div');
                beam.style.position = 'absolute';
                beam.style.left = `${combatMode.mouseX}px`;
                beam.style.top = `${combatMode.mouseY}px`;
                beam.style.width = '0'; // 初始宽度为0，动画中会扩展
                beam.style.height = `${containerRect.width * 0.15}px`; // 高度为容器宽度的15%
                beam.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 1)}, ${hexToRgba(weaponColor, 0.7)})`;
                beam.style.boxShadow = `0 0 20px ${weaponColor}, 0 0 40px ${weaponColor}`;
                beam.style.zIndex = '17';
                beam.style.transformOrigin = 'left center';
                beam.style.animation = 'powerBeam 0.6s forwards';

                combatContainer.appendChild(beam);

                // 添加射线内部光效
                const beamGlow = document.createElement('div');
                beamGlow.style.position = 'absolute';
                beamGlow.style.left = `${combatMode.mouseX}px`;
                beamGlow.style.top = `${combatMode.mouseY}px`;
                beamGlow.style.width = '0'; // 与主射线同步
                beamGlow.style.height = `${containerRect.width * 0.08}px`; // 略窄于主射线
                beamGlow.style.background = `linear-gradient(90deg, white, ${hexToRgba(weaponColor, 0.8)} 30%, ${hexToRgba(weaponColor, 0.5)} 70%)`;
                beamGlow.style.filter = 'blur(3px)';
                beamGlow.style.zIndex = '16';
                beamGlow.style.transformOrigin = 'left center';
                beamGlow.style.animation = 'powerBeam 0.6s forwards';

                combatContainer.appendChild(beamGlow);

                // 清理射线
                setTimeout(() => {
                    if (beam.parentNode) beam.parentNode.removeChild(beam);
                    if (beamGlow.parentNode) beamGlow.parentNode.removeChild(beamGlow);
                }, 600);
            }, 300); // 在充能效果后显示射线

            // 清理充能效果
            setTimeout(() => {
                if (chargeEffect.parentNode) chargeEffect.parentNode.removeChild(chargeEffect);
            }, 400);
        }

        function createGetterBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();
            const centerX = combatMode.mouseX;
            const centerY = combatMode.mouseY;

            // 添加必要的CSS
            addCSSIfNeeded(`
                @keyframes getterScanLine {
                    0% { opacity: 0.8; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `);

            // 水平长方形准星的参数计算
            const outerSize = combatMode.crosshairSize * 0.8; // 外框大小为容器大小的80%
            const frameHeight = Math.round(outerSize * 0.4); // 较短的高度
            const frameWidth = frameHeight * 6; // 宽度是高度的6倍
    
            // 预先计算扫描线数量和时间参数
            const scanCount = 7; // 创建7条扫描线
            const scanDuration = 100; // 每条线的持续时间(毫秒)
            const scanDelay = 50; // 线之间的延迟(毫秒)
    
            // 播放光束音效
            playCombatSound(beamGunSound);
    
            // 创建扫描线动画
            for (let i = 0; i < scanCount; i++) {
                setTimeout(() => {
                    // 在长方形内随机高度创建扫描线
                    const randomOffset = (Math.random() - 0.5) * frameHeight;
                    const scanY = centerY + randomOffset;
            
                    // 创建扫描线
                    const scanLine = document.createElement('div');
                    scanLine.style.position = 'absolute';
                    scanLine.style.height = '5px'; // 加粗扫描线
                    scanLine.style.width = `${frameWidth}px`;
                    scanLine.style.left = `${centerX - frameWidth/2}px`;
                    scanLine.style.top = `${scanY}px`;
                    scanLine.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 0.3)} 0%, ${hexToRgba(weaponColor, 1)} 50%, ${hexToRgba(weaponColor, 0.3)} 100%)`;
                    scanLine.style.boxShadow = `0 0 10px ${weaponColor}, 0 0 20px ${weaponColor}`;
                    scanLine.style.zIndex = '9';
                    scanLine.style.animation = 'getterScanLine 0.3s forwards';
            
                    // 添加到容器
                    combatContainer.appendChild(scanLine);
            
                    // 清理扫描线
                    setTimeout(() => {
                        if (scanLine.parentNode) scanLine.parentNode.removeChild(scanLine);
                    }, 300);
                }, i * scanDelay);
            }
    
            // 延迟检查命中 - 在最后一条扫描线后
            setTimeout(() => {
                checkHit();
            }, scanCount * scanDelay + 150);
        }
            
        function createSpiralBeamEffect(weaponColor) {
            const containerRect = combatContainer.getBoundingClientRect();

            // 添加必要的CSS
            addCSSIfNeeded(`
                @keyframes spiralWave {
                    0% { transform: translate(-50%, -50%) scale(0.3) rotate(0deg); opacity: 0.7; }
                    100% { transform: translate(-50%, -50%) scale(2) rotate(720deg); opacity: 0; }
                }

                @keyframes spiralBeam {
                    0% { transform: rotate(var(--startAngle)) translateX(10px); opacity: 0.2; width: 0; }
                    20% { opacity: 1; }
                    100% { transform: rotate(var(--endAngle)) translateX(var(--distance)); opacity: 0; width: ${containerRect.width * 0.6}px; }
                }
            `);

            // 创建中心螺旋效果
            const spiral = document.createElement('div');
            spiral.style.position = 'absolute';
            spiral.style.left = `${combatMode.mouseX}px`;
            spiral.style.top = `${combatMode.mouseY}px`;
            spiral.style.width = `${containerRect.width * 0.2}px`; // 宽度为容器宽度的20%
            spiral.style.height = `${containerRect.width * 0.2}px`;
            spiral.style.background = `conic-gradient(from 0deg,
                                        ${hexToRgba(weaponColor, 0)} 0%,
                                        ${hexToRgba(weaponColor, 0.8)} 25%,
                                        ${hexToRgba(weaponColor, 1)} 50%,
                                        ${hexToRgba(weaponColor, 0.8)} 75%,
                                        ${hexToRgba(weaponColor, 0)} 100%)`;
            spiral.style.borderRadius = '50%';
            spiral.style.zIndex = '16';
            spiral.style.transform = 'translate(-50%, -50%) scale(0.3)';
            spiral.style.animation = 'spiralWave 1s forwards';
            spiral.style.boxShadow = `0 0 30px ${weaponColor}`;
            combatContainer.appendChild(spiral);

            // 创建发散的能量束
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const startAngle = i * 60; // 平均分布在360度
                    const endAngle = startAngle + (Math.random() * 120 + 180); // 旋转180-300度
                    const distance = containerRect.width * (0.4 + Math.random() * 0.3); // 40%-70%的容器宽度

                    const beam = document.createElement('div');
                    beam.style.position = 'absolute';
                    beam.style.left = `${combatMode.mouseX}px`;
                    beam.style.top = `${combatMode.mouseY}px`;
                    beam.style.height = `${4 + Math.random() * 4}px`; // 4-8px高
                    beam.style.background = `linear-gradient(90deg, ${hexToRgba(weaponColor, 1)}, ${hexToRgba(weaponColor, 0.7)} 70%, transparent)`;
                    beam.style.boxShadow = `0 0 10px ${weaponColor}`;
                    beam.style.transformOrigin = 'left center';
                    beam.style.zIndex = '15';

                    // 使用CSS变量传递不同的角度和距离
                    beam.style.setProperty('--startAngle', `${startAngle}deg`);
                    beam.style.setProperty('--endAngle', `${endAngle}deg`);
                    beam.style.setProperty('--distance', `${distance}px`);
                    beam.style.animation = 'spiralBeam 0.8s forwards';

                    combatContainer.appendChild(beam);

                    // 清理能量束
                    setTimeout(() => {
                        if (beam.parentNode) beam.parentNode.removeChild(beam);
                    }, 800);
                }, i * 100); // 错开发射时间
            }

            // 清理螺旋效果
            setTimeout(() => {
                if (spiral.parentNode) spiral.parentNode.removeChild(spiral);
            }, 1000);
        }

        // 辅助函数：动态添加CSS
        function addCSSIfNeeded(cssText) {
            // 为每次添加的CSS创建唯一ID
            const cssId = 'custom-effect-css-' + Math.random().toString(36).substr(2, 9);

            // 检查是否已存在相同的CSS
            if (!document.getElementById(cssId)) {
                const head = document.head || document.getElementsByTagName('head')[0];
                const style = document.createElement('style');
                style.id = cssId;
                style.type = 'text/css';

                if (style.styleSheet) {
                    // IE8 及以下
                    style.styleSheet.cssText = cssText;
                } else {
                    // 现代浏览器
                    style.appendChild(document.createTextNode(cssText));
                }

                head.appendChild(style);
            }
        }

        // 检查是否命中
        function checkHit() {
            const containerRect = combatContainer.getBoundingClientRect();

            // 计算防守者中心位置
            const defenderCenterX = combatMode.defenderX;
            const defenderCenterY = combatMode.defenderY;

            // 计算准星中心位置
            const crosshairCenterX = combatMode.mouseX;
            const crosshairCenterY = combatMode.mouseY;

            // 计算防守者大小和准星大小
            const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);
            const defenderRadius = defenderSize / 2;
            const crosshairRadius = combatMode.crosshairSize / 2;

            // 使用当前准星形状（默认是圆形）
            const crosshairType = combatMode.attacker.crosshairType || 'Beam_Rifie';

            // 根据准星类型创建不同的碰撞形状
            let hitDetected = false;

            if (crosshairType === 'Beam_Rifie' || !crosshairType) {
                // 使用简单的圆形碰撞检测（原有的方法）
                const dx = crosshairCenterX - defenderCenterX;
                const dy = crosshairCenterY - defenderCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                hitDetected = distance < (defenderRadius + crosshairRadius);
            } else {
                // 使用多边形碰撞检测
                let crosshairPoints;
                let defenderPoints;

                // 创建防守者的碰撞形状（通常是圆形）
                defenderPoints = createRegularPolygon(8, defenderRadius); // 用8边形近似圆形

                // 根据准星类型创建不同形状
                switch (crosshairType) {
                    case 'Beam_Saber':
                        // 创建正方形准星
                        const halfSize = crosshairRadius * 0.8; // 稍微缩小以匹配视觉大小
                        crosshairPoints = [
                            {x: -halfSize, y: -halfSize},
                            {x: halfSize, y: -halfSize},
                            {x: halfSize, y: halfSize},
                            {x: -halfSize, y: halfSize}
                        ];
                        break;

                    case 'Cosmo_Nova':
                        // 创建菱形准星
                        const Cosmo_NovaSize = crosshairRadius * 1.2;
                        crosshairPoints = [
                            {x: 0, y: -Cosmo_NovaSize},
                            {x: Cosmo_NovaSize, y: 0},
                            {x: 0, y: Cosmo_NovaSize},
                            {x: -Cosmo_NovaSize, y: 0}
                        ];
                        break;

                    case 'Destructive_Thunder':
                        // 使用与 Beam_Saber 相同的方形碰撞检测，但使用不同的变量名
                        const thunderSize = crosshairRadius * 0.8; // 稍微缩小以匹配视觉大小
                        crosshairPoints = [
                            {x: -thunderSize, y: -thunderSize},
                            {x: thunderSize, y: -thunderSize},
                            {x: thunderSize, y: thunderSize},
                            {x: -thunderSize, y: thunderSize}
                        ];
                        break;

                    // 添加Getter_Beam形状
                    case 'Getter_Beam':
                        // 水平长方形准星，宽:高 = 6:1
                        const getterBeamHeight = crosshairRadius * 0.4; // 高度较小
                        const getterBeamWidth = getterBeamHeight * 6; // 宽度是高度的6倍
                        crosshairPoints = [
                            {x: -getterBeamWidth/2, y: -getterBeamHeight/2},
                            {x: getterBeamWidth/2, y: -getterBeamHeight/2},
                            {x: getterBeamWidth/2, y: getterBeamHeight/2},
                            {x: -getterBeamWidth/2, y: getterBeamHeight/2}
                        ];
                        break;
                        
                    case 'diamond':
                        // 创建菱形准星
                        const diamondSize = crosshairRadius * 1.2;
                        crosshairPoints = [
                            {x: 0, y: -diamondSize},
                            {x: diamondSize, y: 0},
                            {x: 0, y: diamondSize},
                            {x: -diamondSize, y: 0}
                        ];
                        break;

                    case 'triangle':
                        // 创建三角形准星
                        const triangleSize = crosshairRadius * 1.3;
                        crosshairPoints = [
                            {x: 0, y: -triangleSize},
                            {x: triangleSize * 0.866, y: triangleSize * 0.5}, // cos(30°), sin(30°)
                            {x: -triangleSize * 0.866, y: triangleSize * 0.5}
                        ];
                        break;

                    default:
                        // 默认使用圆形（用16边形近似）
                        crosshairPoints = createRegularPolygon(16, crosshairRadius);
                }

                // 创建多边形对象
                const crosshairPolygon = createPolygon(crosshairPoints, crosshairCenterX, crosshairCenterY, 0);
                const defenderPolygon = createPolygon(defenderPoints, defenderCenterX, defenderCenterY, 0);

                // 检测碰撞
                hitDetected = polygonsCollide(crosshairPolygon, defenderPolygon);
            }

            // 如果命中，创建爆炸效果
            if (hitDetected) {
                createExplosion(defenderCenterX, defenderCenterY);
                endCombat('attacker');
                return true;
            }

            return false;
        }

        // 創建爆炸效果 - 百分比方式！
        function createExplosion(x, y) {
            // 播放爆炸音效
            playCombatSound(explosionSound);

            // 主爆炸
            const explosion = document.createElement('div');
            explosion.className = 'explosion';

            // 使用百分比定位
            const containerRect = combatContainer.getBoundingClientRect();
            const xPercent = (x / containerRect.width) * 100;
            const yPercent = (y / containerRect.height) * 100;

            explosion.style.left = `${xPercent}%`;
            explosion.style.top = `${yPercent}%`;
            combatContainer.appendChild(explosion);

            // Create spark particles - MORE AND PRETTIER
            for (let i = 0; i < 40; i++) { // Doubled from 20 to 40 particles
                const spark = document.createElement('div');
                spark.className = 'spark';

                // Random position around explosion center
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 70 + 30; // Increased distance
                const sparkX = x + Math.cos(angle) * distance;
                const sparkY = y + Math.sin(angle) * distance;

                spark.style.left = `${sparkX}px`;
                spark.style.top = `${sparkY}px`;

                // Enhanced color palette
                const colors = [
                    '#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB', '#FFFFFF',
                    '#FF00FF', '#DA70D6', '#EE82EE', '#FF77FF', '#FFD700'
                ];
                const color = colors[Math.floor(Math.random() * colors.length)];
                spark.style.backgroundColor = color;
                spark.style.color = color; // For box-shadow glow

                // Animation
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkSpeed = Math.random() * 150 + 100; // Faster particles
                const sparkDuration = Math.random() * 600 + 600; // Longer duration

                combatContainer.appendChild(spark);

                // Animate the spark
                let startTime = null;
                function animateSpark(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = (timestamp - startTime) / sparkDuration;

                    if (progress < 1) {
                        const moveX = Math.cos(sparkAngle) * sparkSpeed * progress;
                        const moveY = Math.sin(sparkAngle) * sparkSpeed * progress;

                        spark.style.left = `${sparkX + moveX}px`;
                        spark.style.top = `${sparkY + moveY}px`;
                        spark.style.opacity = 1 - progress;

                        requestAnimationFrame(animateSpark);
                    } else {
                        if (spark.parentNode) {
                            spark.parentNode.removeChild(spark);
                        }
                    }
                }

                requestAnimationFrame(animateSpark);
            }

            // Secondary explosions for more spectacular effect
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const secondaryExplosion = document.createElement('div');
                    secondaryExplosion.className = 'explosion';
                    // Position secondary explosions slightly offset from main explosion
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = (Math.random() - 0.5) * 60;
                    secondaryExplosion.style.left = `${x + offsetX}px`;
                    secondaryExplosion.style.top = `${y + offsetY}px`;
                    // Make secondary explosions smaller
                    secondaryExplosion.style.transform = 'translate(-50%, -50%) scale(0.7)';
                    combatContainer.appendChild(secondaryExplosion);

                    // Remove secondary explosion after animation
                    setTimeout(() => {
                        if (secondaryExplosion.parentNode) {
                            secondaryExplosion.parentNode.removeChild(secondaryExplosion);
                        }
                    }, 600);
                }, i * 200); // Stagger the secondary explosions
            }

            // Remove explosion after animation
            setTimeout(() => {
                if (explosion.parentNode) {
                    explosion.parentNode.removeChild(explosion);
                }
            }, 600);
        }

        // Update combat state
        function updateCombat(timestamp) {
            if (!combatMode.active) return;

            // First frame initialization
            if (!combatMode.lastFrameTime) {
                combatMode.lastFrameTime = timestamp;
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
                return;
            }

            const deltaTime = timestamp - combatMode.lastFrameTime;
            combatMode.lastFrameTime = timestamp;

            // Update timer
            if (!combatMode.result && !combatMode.bulletFired) {
                combatMode.timeRemaining -= deltaTime;
                combatMode.timer = Math.max(0, Math.ceil(combatMode.timeRemaining / 1000));
                combatTimer.textContent = combatMode.timer;

                // Check if time's up
                if (combatMode.timeRemaining <= 0) {
                    // Defender wins if time runs out
                    endCombat('defender');
                }
            }

            // Update defender position
            // 更新防守者位置
            if (combatMode.defenderMoving && !combatMode.result) {
                // 计算已经过的时间（毫秒）
                const elapsedTime = Date.now() - combatMode.moveStartTime;

                // 计算移动方向向量
                const dx = combatMode.defenderTargetX - combatMode.moveStartX;
                const dy = combatMode.defenderTargetY - combatMode.moveStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) { // 如果距目标还有一段距离
                    // 将速度从像素/帧转换为像素/秒
                    const speedPerSecond = combatMode.defenderSpeed * 60; // 假设60FPS作为基准

                    // 计算这段时间内应该移动的距离比例（0到1之间）
                    // 200ms是最大移动时间，但可能提前到达目标
                    const moveRatio = Math.min(elapsedTime / 200, 1.0);

                    // 计算比例距离移动
                    const moveDistance = Math.min(speedPerSecond * (elapsedTime / 1000), distance);
                    const moveRatio2 = moveDistance / distance;

                    // 使用平滑的基于时间的插值
                    combatMode.defenderX = combatMode.moveStartX + dx * moveRatio2;
                    combatMode.defenderY = combatMode.moveStartY + dy * moveRatio2;

                    // 确保防守者不会离开容器边界
                    const containerRect = combatContainer.getBoundingClientRect();
                    const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);
                    combatMode.defenderX = Math.max(defenderSize / 2,
                                        Math.min(containerRect.width - defenderSize / 2,
                                               combatMode.defenderX));
                    combatMode.defenderY = Math.max(defenderSize / 2,
                                        Math.min(containerRect.height - defenderSize / 2,
                                               combatMode.defenderY));

                    // 更新视觉位置
                    defender.style.left = `${combatMode.defenderX}px`;
                    defender.style.top = `${combatMode.defenderY}px`;
                } else {
                    // 到达目标位置，停止移动
                    combatMode.defenderMoving = false;
                }
            }

            // Continue animation
            if (combatMode.active) {
                combatMode.frameRequest = requestAnimationFrame(updateCombat);
            }
        }

        // AI for defender movement
        function startAIDefender() {
            if (!combatMode.active) return;

            const containerRect = combatContainer.getBoundingClientRect();
            const isTouch = isTouchDevice();

            // Set initial target for AI defender
            combatMode.defenderTargetX = combatMode.defenderX;
            combatMode.defenderTargetY = combatMode.defenderY;

            const chooseEvasiveDirection = () => {
                if (!combatMode.active || combatMode.result || combatMode.defenderMoving) return;

                // Calculate random movement distance based on dodge value
                // Formula: (dodge值-2)*5% + 10% 的容器寬度
                // 觸控裝置上減少移動距離，使AI更容易被命中
                const moveDistanceMultiplier = 1.0;
                const moveDistancePercent = ((combatMode.defender.dodge - 2) * 5 + 10) * moveDistanceMultiplier;
                const moveDistance = containerRect.width * (moveDistancePercent / 100);

                // Choose a random direction to move
                const angle = Math.random() * Math.PI * 2;

                // Use the new moveDistance formula instead of random distance
                combatMode.defenderTargetX = containerRect.width / 2 + Math.cos(angle) * moveDistance;
                combatMode.defenderTargetY = containerRect.height / 2 + Math.sin(angle) * moveDistance;

                // 計算實際的防守者尺寸 (使用defenderSizePercent實時計算)
                const defenderSize = containerRect.width * (combatMode.defenderSizePercent / 100);

                // Keep within bounds
                combatMode.defenderTargetX = Math.max(defenderSize / 2,
                                                    Math.min(containerRect.width - defenderSize / 2,
                                                            combatMode.defenderTargetX));
                combatMode.defenderTargetY = Math.max(defenderSize / 2,
                                                    Math.min(containerRect.height - defenderSize / 2,
                                                            combatMode.defenderTargetY));

                // Start movement
                startDefenderMovement();
            };

            // Perform evasive movement occasionally
            // 觸控裝置上更慢的閃避頻率
            const evasionInterval = 800;

            const aiInterval = setInterval(() => {
                if (!combatMode.active) {
                    clearInterval(aiInterval);
                    return;
                }

                chooseEvasiveDirection();
            }, evasionInterval);

            // Initial evasion with longer delay on touch devices
            const initialDelay = 500;
            setTimeout(chooseEvasiveDirection, initialDelay);
        }

        // 檢測是否為觸控裝置
        function isTouchDevice() {
            return ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0);
        }

        // AI for attacker (aiming and shooting)
        function startAIAttacker() {
            if (!combatMode.active || combatMode.bulletFired) return;

            const containerRect = combatContainer.getBoundingClientRect();
            const isTouch = isTouchDevice();

            // Set initial crosshair position
            combatMode.mouseX = containerRect.width / 2;
            combatMode.mouseY = containerRect.height / 2;
            crosshair.style.left = `${combatMode.mouseX}px`;
            crosshair.style.top = `${combatMode.mouseY}px`;

            // 觸控裝置上更慢的追蹤間隔
            const trackingInterval = 300;

            // Start tracking defender - 在觸控裝置上更慢
            const trackInterval = setInterval(() => {
                if (!combatMode.active || combatMode.bulletFired) {
                    clearInterval(trackInterval);
                    return;
                }

                // Move crosshair toward defender with some error margin
                const difficultyFactor = 1 - (combatMode.attacker.hit * 0.1);

                // 觸控裝置上使用更大的誤差範圍
                const errorMultiplier = 200;
                const errorX = (Math.random() - 0.5) * errorMultiplier * difficultyFactor;
                const errorY = (Math.random() - 0.5) * errorMultiplier * difficultyFactor;

                combatMode.mouseX = combatMode.defenderX + errorX;
                combatMode.mouseY = combatMode.defenderY + errorY;

                crosshair.style.left = `${combatMode.mouseX}px`;
                crosshair.style.top = `${combatMode.mouseY}px`;
            }, trackingInterval);

            // 觸控裝置上更長的射擊延遲
            const minDelay = 500;
            const maxRandomDelay = 2000;
            const shootDelay = minDelay + Math.random() * maxRandomDelay;

            setTimeout(() => {
                if (combatMode.active && !combatMode.bulletFired) {
                    shootLaser();
                }
                clearInterval(trackInterval);
            }, shootDelay);
        }

        // 修改endCombat函數，修復防守者勝利時回合計數問題
        function endCombat(winner) {
            if (combatMode.result) return; // Already ended

            combatMode.result = winner;
            console.log(`戰鬥結束: ${winner === 'attacker' ? '攻擊者' : '防守者'}勝利`);
            console.log(`攻擊者位置: [${combatMode.attackerPos.row},${combatMode.attackerPos.col}], 防守者位置: [${combatMode.defenderPos.row},${combatMode.defenderPos.col}]`);

            // Show result
            combatResult.textContent = winner === 'attacker'
                ? `${combatMode.attacker.type} 勝利！`
                : `${combatMode.defender.type} 成功閃避！`;

            combatResult.classList.add('show');

            // Remove event listeners
            combatContainer.removeEventListener('mousemove', handleAttackerMouseMove);
            combatContainer.removeEventListener('click', handleAttackerClick);
            combatContainer.removeEventListener('touchmove', handleAttackerTouchMove);
            combatContainer.removeEventListener('touchstart', handleAttackerTouch);

            combatContainer.removeEventListener('mousemove', handleDefenderMouseMove);
            combatContainer.removeEventListener('click', handleDefenderClick);
            combatContainer.removeEventListener('touchmove', handleDefenderTouchMove);
            combatContainer.removeEventListener('touchstart', handleDefenderTouch);

            // End combat and update game state after a delay
            setTimeout(() => {
                combatOverlay.classList.add('hidden');
                combatMode.active = false;

                if (combatMode.frameRequest) {
                    cancelAnimationFrame(combatMode.frameRequest);
                    combatMode.frameRequest = null;
                }

                // 在更改遊戲狀態前，確保清除任何可能排隊的AI移動計時器
                if (aiMoveTimer) {
                    clearTimeout(aiMoveTimer);
                    aiMoveTimer = null;
                }

                // Update game state based on combat result
                if (winner === 'attacker') {
                    // Attacker wins - complete the capture
                    const { attackerPos, defenderPos } = combatMode;
                    movePiece(attackerPos.row, attackerPos.col, defenderPos.row, defenderPos.col);
                } else {
                    // Defender wins - pieces stay where they are, but turn changes
                    // 保存當前回合以檢查是否發生回合轉換
                    const previousTurn = gameState.currentTurn;

                    // 切換回合
                    gameState.currentTurn = gameState.currentTurn === BLUE ? RED : BLUE;

                    // 當紅方(AI)攻擊失敗，回合轉回藍方時，回合數應該增加
                    if (previousTurn === RED && gameState.currentTurn === BLUE) {
                        gameState.turnCount++;
                        console.log(`防守成功後回合數增加到: ${gameState.turnCount}`);

                        // 添加此行显示回合过渡
                        showTurnTransition(BLUE, gameState.turnCount);

                        // 检查是否正在播放战斗BGM
                        const wasBattleBgmPlaying = battleBgmPlayer !== null;
                        stopBattleBGM();

                        // 只有在之前正在播放战斗BGM时才从头播放boardbgm
                        if (wasBattleBgmPlaying && levelManager && levelManager.currentLevel) {
                            // 从头播放关卡BGM
                            const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                            if (currentLevelData && currentLevelData.boardbgm) {
                                playBoardBGM(currentLevelData.boardbgm);
                            }
                        }

                        // 觸發回合開始事件
                        if (typeof eventSystem !== 'undefined') {
                            console.log(`防守成功後觸發藍方回合開始事件，回合數: ${gameState.turnCount}`);
                            eventSystem.triggerEvent('turnStart', {
                                team: BLUE,
                                turn: gameState.turnCount
                            });
                        }
                    }

                    // 更新介面
                    updateTurnIndicator();
                    updateTurnCountDisplay(); // 增加這一行，確保顯示正確的回合數
                    statusMessage.textContent = `${gameState.currentTurn === BLUE ? '藍方' : '紅方'}回合。`;

                    // Clear selection
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    updateBoardDisplay();
                }

                // If AI's turn after combat, schedule its move
                if (gameState.gameMode === 'single-player' && gameState.currentTurn === RED && !gameState.gameOver) {
                    aiMoveTimer = setTimeout(makeAIMove, 500);
                }
            }, 1500);
        }

        // AI Move Logic
        function makeAIMove() {
            // 確保是AI的回合再執行移動 - 新增檢查以防止錯誤回合移動
            if (gameState.gameOver || combatMode.active || gameState.currentTurn !== RED) {
                return;
            }

            const now = Date.now();
            aiMoveCount++;

            // 記錄移動時間
            lastAIMoveTime = now;

            // Find all pieces of current team (RED for AI)
            const aiTeam = RED;
            let allPossibleMoves = [];

            // Collect all possible moves
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.team === aiTeam) {
                        const validMoves = calculateValidMoves(row, col);
                        validMoves.forEach(move => {
                            allPossibleMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                piece: piece,
                                targetPiece: gameState.board[move.row][move.col]
                            });
                        });
                    }
                }
            }

            // If no moves, game over - but we don't show victory screen for this case
            if (allPossibleMoves.length === 0) {
                gameState.gameOver = true;
                gameState.winner = BLUE;
                statusMessage.textContent = `遊戲結束！藍方通過將軍獲勝！`;
                // 移除勝利畫面的顯示，只改變遊戲狀態和訊息
                return;
            }

            // Prioritize moves
            allPossibleMoves.sort((a, b) => {
                // Prioritize captures over non-captures
                if (a.targetPiece && !b.targetPiece) return -1;
                if (!a.targetPiece && b.targetPiece) return 1;

                // For captures, prioritize higher value pieces
                if (a.targetPiece && b.targetPiece) {
                    const aValue = getPieceValue(a.targetPiece.moveType);
                    const bValue = getPieceValue(b.targetPiece.moveType);
                    if (aValue !== bValue) return bValue - aValue;
                }

                // Add some randomness
                return Math.random() - 0.5;
            });

            // Choose the best move
            const chosenMove = allPossibleMoves[0];

            // AI選擇移動完成

            // If move is a capture, initiate combat
            if (chosenMove.targetPiece) {
                gameState.selectedPiece = { row: chosenMove.fromRow, col: chosenMove.fromCol };
                startCombat(chosenMove.piece, chosenMove.targetPiece,
                            { row: chosenMove.fromRow, col: chosenMove.fromCol },
                            { row: chosenMove.toRow, col: chosenMove.toCol });
            } else {
                // Regular move
                movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
            }
        }

        // Helper to get piece values for AI decision making
        function getPieceValue(moveType) {
            switch(moveType) {
                case PAWN: return 1;
                case KNIGHT: return 3;
                case BISHOP: return 3;
                case ROOK: return 5;
                case QUEEN: return 9;
                case KING: return 100;
                default: return 0;
            }
        }

        // Show toast notification
        function showToast(message, duration = 2000) {
            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        function sendGameState() {
            if (connection && connection.open) {
                connection.send({
                    type: 'gameState',
                    state: gameState
                });
            }
        }

        // Initialize the cover page space background
        setupSpaceBackground(document.getElementById('cover-space-bg'));

        // 新增序章頁面的HTML
        const prologueHTML = `
        <div id="prologue-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[400] flex items-start justify-center opacity-0 transition-opacity duration-500">
            <div class="relative max-w-3xl w-full mx-4 md:mx-auto bg-gradient-to-b from-gray-900 to-black rounded-lg overflow-hidden shadow-2xl transform transition-transform duration-500 scale-95" style="margin-top: 5vh;">
                <div class="absolute inset-0 overflow-hidden opacity-20">
                    <div class="stars-bg absolute inset-0"></div>
                </div>

                <div class="relative p-6 md:p-8">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl md:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">序</h2>
                    </div>

                    <div class="space-y-4 text-gray-300 leading-relaxed mb-8 md:text-lg">
                        <p>基爾基爾鋼與闘神·諾亞事件後的和平時代，原星球上的超級機械人們逐漸重建家園，部分機械人選擇離開星球，前往宇宙建立新的生活空間。然而，宇宙中資源的有限性與對原星球資源的依賴，使得居於宇宙的機械人逐漸與地球產生矛盾。宇宙聯合軍宣布獨立，並向地球發動侵略戰爭。</p>
                        <p>面對同胞間的自相殘殺，英雄們再次集結，誓要阻止這場戰爭。然而，在這場衝突背後，似乎隱藏著更大的陰謀……</p>
                    </div>

                    <div class="flex justify-center">
                        <button id="prologue-continue-btn" class="px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                            繼續
                        </button>
                    </div>
                </div>
            </div>
        </div>
        `;

        // 關卡系統代碼 ------------------------------
        // 關卡管理系統
        const levelManager = {
            currentLevel: 0,
            isLevelActive: false,

            // 加載指定關卡
            loadLevel: function(levelId) {
                console.log("加載關卡:", levelId);
                const levelInfo = window.levelData.find(level => level.id === levelId);
                if (!levelInfo) {
                    console.error(`關卡 ${levelId} 不存在`);
                    return false;
                }

                this.currentLevel = levelId;
                this.isLevelActive = true;

                // 顯示關卡資訊頁
                this.showLevelInfo(levelInfo);

                return true;
            },

            // 顯示關卡資訊頁 - 添加安全檢查
            showLevelInfo: function(levelInfo) {
                console.log("顯示關卡信息:", levelInfo.title);

                try {
                    // 設置關卡標題和副標題（添加安全檢查）
                    const levelTitleEl = document.getElementById('level-title');
                    const levelSubtitleEl = document.getElementById('level-subtitle');
                    const levelStoryContentEl = document.getElementById('level-story-content');
                    const victoryTextEl = document.getElementById('victory-text');
                    const defeatTextEl = document.getElementById('defeat-text');
                    const startLevelBtnEl = document.getElementById('start-level-btn');
                    const levelInfoOverlay = document.getElementById('level-info-overlay');

                    if (levelTitleEl) {
                        levelTitleEl.textContent = levelInfo.title;
                    } else {
                        console.error(`錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - level-title 元素不存在`);
                    }

                    if (levelSubtitleEl) {
                        levelSubtitleEl.textContent = levelInfo.subtitle || '';
                    }

                    // 設置關卡圖片
                    const levelImage = document.getElementById('level-image');
                    if (levelImage) {
                        if (levelInfo.storyImage) {
                            levelImage.src = levelInfo.storyImage;
                            levelImage.style.display = 'block';
                        } else {
                            levelImage.style.display = 'none';
                        }
                    }

                    // 設置故事簡介
                    if (levelStoryContentEl) {
                        levelStoryContentEl.textContent = levelInfo.storyDesc || '無故事簡介';
                    }

                    // 設置勝利條件和戰敗條件
                    if (victoryTextEl) {
                        victoryTextEl.textContent = '勝利條件：' + (levelInfo.victoryCondition.description || '吃掉對方的國王棋');
                    }

                    if (defeatTextEl) {
                        defeatTextEl.textContent = '戰敗條件：' + (levelInfo.defeatCondition.description || '國王棋被對方吃掉');
                    }

                    // 添加開始按鈕事件
                    if (startLevelBtnEl) {
                        startLevelBtnEl.onclick = () => {
                            this.startLevel(levelInfo);
                        };
                    }

                    // 顯示關卡信息頁面
                    if (levelInfoOverlay) {
                        levelInfoOverlay.classList.add('show');
                    } else {
                        console.error(`錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - level-info-overlay 元素不存在`);
                    }
                } catch (error) {
                    console.error(`關卡信息顯示錯誤，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // 開始關卡 - 添加安全檢查和適當的延遲
            startLevel: function(levelInfo) {
                console.log("開始關卡:", levelInfo.title);
                try {
                    // 隱藏關卡信息頁面
                    const levelInfoOverlay = document.getElementById('level-info-overlay');
                    if (levelInfoOverlay) {
                        levelInfoOverlay.classList.remove('show');
                    } else {
                        console.error(`錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - level-info-overlay 元素不存在`);
                    }

                    // 播放關卡背景音樂
                    if (levelInfo.boardbgm) {
                        playBoardBGM(levelInfo.boardbgm);
                    }

                    // 延遲一下確保UI更新完成
                    setTimeout(() => {
                        // 顯示遊戲UI
                        if (gameUI) {
                            gameUI.style.display = 'block';
                        }

                        // 初始化關卡
                        this.initializeLevel(levelInfo);

                    }, 100); // 給DOM 100ms的時間完成渲染
                } catch (error) {
                    console.error(`關卡開始錯誤，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // 初始化關卡 - 添加錯誤處理和日誌
            initializeLevel: function(levelInfo) {
                console.log("初始化關卡");
                console.log("已加载的事件:", eventSystem.events);
                try {
                    // 確認levelInfo存在
                    if (!levelInfo) {
                        console.error(`初始化關卡錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - levelInfo為null`);
                        return;
                    }

                    // 1. 設置棋盤圖紙
                    this.setBoardImage(levelInfo.boardImage);

                    // 2. 設置棋盤狀態（棋子位置）
                    this.setInitialBoardState(levelInfo.initialBoardState);

                    // 3. 設置勝利條件
                    this.setVictoryCondition(levelInfo.victoryCondition);

                    // 4. 設置戰敗條件
                    this.setDefeatCondition(levelInfo.defeatCondition);

                    // 5. 回合數歸零
                    if (gameState) {
                        gameState.turnCount = 0;
                        updateTurnCountDisplay();
                    } else {
                        console.error(`初始化關卡錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - gameState為null`);
                    }

                    // 6. 載入該關卡的特別事件
                    if (levelInfo.events) {
                        this.loadLevelEvents(levelInfo.events);
                    }

                    console.log(`關卡初始化完成，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`關卡初始化錯誤，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // 設置棋盤圖紙 - 添加安全檢查和錯誤處理
            setBoardImage: function(imagePath) {
                try {
                    if (!imagePath) {
                        console.log(`設置棋盤圖紙：未提供圖片路徑，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                        return;
                    }

                    const chessBoardElement = document.querySelector('.chess-board');
                    if (chessBoardElement) {
                        chessBoardElement.style.backgroundImage = `url('${imagePath}')`;
                        console.log(`設置棋盤圖紙成功，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                    } else {
                        console.error(`設置棋盤圖紙錯誤：.chess-board元素不存在，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                    }
                } catch (error) {
                    console.error(`設置棋盤圖紙發生異常，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // 設置初始棋盤狀態 - 從關卡中讀取機體定義
            setInitialBoardState: function(initialState) {
                try {
                    if (!gameState || !BOARD_SIZE || typeof initializeGame !== 'function') {
                        console.error(`設置初始棋盤狀態錯誤時間: ${Date.now() - window.gameLoadStartTime}ms - gameState或初始化函數不可用`);
                        return;
                    }

                    // 如果沒有提供初始狀態，則使用默認初始化
                    if (!initialState) {
                        console.log(`未提供初始棋盤狀態，使用默認初始化，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                        initializeGame();
                        return;
                    }

                    // 清空當前棋盤
                    gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                    gameState.blueCaptured = [];
                    gameState.redCaptured = [];
                    gameState.currentTurn = BLUE;
                    gameState.selectedPiece = null;
                    gameState.validMoves = [];
                    gameState.gameOver = false;
                    gameState.winner = null;

                    console.log(`開始設置 ${initialState.length} 個棋子，時間: ${Date.now() - window.gameLoadStartTime}ms`);

                    // 獲取當前關卡的機體定義
                    const currentLevelData = window.levelData.find(level => level.id === this.currentLevel);
                    if (!currentLevelData || !currentLevelData.pieceDefinitions) {
                        console.error(`無法找到關卡 ${this.currentLevel} 的機體定義`);
                        return;
                    }

                    const levelPieceDefinitions = currentLevelData.pieceDefinitions;

                    // 根據提供的初始狀態設置棋子
                    initialState.forEach(piece => {
                    if (!piece || !piece.id || !piece.position || !Array.isArray(piece.position) || piece.position.length !== 2) {
                        console.error(`無效的棋子定義: ${JSON.stringify(piece)}`);
                        return;
                    }

                    const { id, position } = piece;
                    const [row, col] = position;

                    // Create a variable for the potentially modified ID
                    let actualPieceId = id;
    
                    // Check if we should replace gundam with fa_gundam
                    if (Get_fa_gundam === 1 && id === 'gundam') {
                        actualPieceId = 'fa_gundam';
                        console.log(`Replacing gundam with fa_gundam at position [${row},${col}]`);
                    }

                    if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                        console.error(`棋子位置超出範圍: [${row},${col}]`);
                        return;
                    }

                    // Check if the piece definition exists using actualPieceId
                    if (!levelPieceDefinitions[actualPieceId]) {
                        console.error(`在關卡 ${this.currentLevel} 中未定義的棋子ID: ${actualPieceId}`);
                        return;
                    }

                    // Use the potentially modified piece ID for creating the piece
                    const pieceDefinition = levelPieceDefinitions[actualPieceId];
                    gameState.board[row][col] = {
                        id: actualPieceId, // Use the potentially modified ID
                        team: pieceDefinition.team,
                        type: pieceDefinition.type,
                        moveType: pieceDefinition.moveType,
                        imgUrl: pieceDefinition.imgUrl,
                        hit: pieceDefinition.hit,
                        dodge: pieceDefinition.dodge,
                        bgmtype: pieceDefinition.bgmtype || '',
                        weapon_colour: pieceDefinition.weapon_colour || '',
                        crosshairType: pieceDefinition.crosshairType || 'Beam_Rifie',
                        hasMoved: false
                    };
                });
                    console.log(`棋盤初始化完成，更新UI，時間: ${Date.now() - window.gameLoadStartTime}ms`);

                    // 安全更新UI
                    if (typeof updateBoardDisplay === 'function') updateBoardDisplay();
                    else console.error(`updateBoardDisplay 函數不可用，時間: ${Date.now() - window.gameLoadStartTime}ms`);

                    if (typeof updateCapturedPieces === 'function') updateCapturedPieces();
                    else console.error(`updateCapturedPieces 函數不可用，時間: ${Date.now() - window.gameLoadStartTime}ms`);

                    if (typeof updateTurnIndicator === 'function') updateTurnIndicator();
                    else console.error(`updateTurnIndicator 函數不可用，時間: ${Date.now() - window.gameLoadStartTime}ms`);
                } catch (error) {
                    console.error(`設置初始棋盤狀態發生異常，時間: ${Date.now() - window.gameLoadStartTime}ms`, error);
                }
            },

            // 設置勝利條件
            setVictoryCondition: function(condition) {
                // 保存勝利條件到遊戲狀態
                if (gameState) {
                    gameState.victoryCondition = condition;
                }
            },

            // 設置戰敗條件
            setDefeatCondition: function(condition) {
                // 保存戰敗條件到遊戲狀態
                if (gameState) {
                    gameState.defeatCondition = condition;
                }
            },

            // 加載關卡事件
            loadLevelEvents: function(events) {
                // 清除之前的所有事件
                eventSystem.clearEvents();

                // 如果沒有事件，直接返回
                if (!events || events.length === 0) return;

                // 註冊所有關卡事件
                events.forEach(event => {
                    eventSystem.registerEvent(event);
                });
            },

            // 檢查勝利條件
            checkVictoryCondition: function() {
                if (!gameState || !gameState.victoryCondition) return false;

                // 根據不同的勝利條件類型進行檢查
                switch (gameState.victoryCondition.type) {
                    case 'captureKing':
                        // 這個在movePiece函數中已經處理了
                        break;

                    case 'surviveNTurns':
                        // 檢查是否存活了指定回合數
                        return gameState.turnCount >= gameState.victoryCondition.turns;

                    case 'reachPosition':
                        // 檢查特定棋子是否到達了特定位置
                        return this.checkPiecePosition(
                            gameState.victoryCondition.pieceId,
                            gameState.victoryCondition.position
                        );

                    case 'captureAllPieces':
                        // 檢查是否捕獲了所有敵方棋子
                        return this.checkAllPiecesCaptured(RED);

                    // 可以添加更多勝利條件類型
                }

                return false;
            },

            // 檢查戰敗條件
            checkDefeatCondition: function() {
                if (!gameState || !gameState.defeatCondition) return false;

                // 根據不同的戰敗條件類型進行檢查
                switch (gameState.defeatCondition.type) {
                    case 'kingCaptured':
                        // 這個在movePiece函數中已經處理了
                        break;

                    case 'turnLimit':
                        // 檢查是否超過了回合限制
                        return gameState.turnCount > gameState.defeatCondition.turns;

                    case 'pieceDestroyed':
                        // 檢查特定棋子是否被破壞
                        return this.checkPieceDestroyed(
                            gameState.defeatCondition.pieceId
                        );

                    // 可以添加更多戰敗條件類型
                }

                return false;
            },

            // 檢查特定棋子是否在特定位置
            checkPiecePosition: function(pieceId, position) {
                if (!gameState || !gameState.board) return false;

                const [targetRow, targetCol] = position;
                if (targetRow < 0 || targetRow >= BOARD_SIZE || targetCol < 0 || targetCol >= BOARD_SIZE) {
                    return false;
                }

                const piece = gameState.board[targetRow][targetCol];
                return piece && piece.id === pieceId;
            },

            // 檢查特定棋子是否被破壞
            checkPieceDestroyed: function(pieceId) {
                if (!gameState || !gameState.board) return false;

                // 在所有棋盤位置尋找這個棋子
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.id === pieceId) {
                            return false; // 棋子仍然存在
                        }
                    }
                }

                return true; // 棋子不存在，已被破壞
            },

            // 檢查是否所有敵方棋子被捕獲
            checkAllPiecesCaptured: function(team) {
                if (!gameState || !gameState.board) return false;

                // 在棋盤上尋找指定隊伍的棋子
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.team === team) {
                            return false; // 仍有敵方棋子
                        }
                    }
                }

                return true; // 所有敵方棋子已被捕獲
            },

            // 關卡完成處理
            levelComplete: function() {
                console.log("關卡完成");
                // 在勝利畫面顯示後，提供進入下一關的選項
                // 修改勝利畫面的按鈕文本
                const victoryResetBtn = document.getElementById('victory-reset');
                if (victoryResetBtn) {
                    victoryResetBtn.textContent = '進入下一話';

                    // 克隆按鈕並替換以移除所有事件監聽器
                    const newBtn = victoryResetBtn.cloneNode(true);
                    if (victoryResetBtn.parentNode) {
                        victoryResetBtn.parentNode.replaceChild(newBtn, victoryResetBtn);
                    }

                    // 添加新的點擊事件
                    newBtn.onclick = () => {
                        if (victoryOverlay) {
                            victoryOverlay.classList.remove('show');
                        }
                        this.nextLevel();
                    };
                }
            },

            // 關卡失敗處理
            levelFailed: function() {
                console.log("關卡失敗");
                // 修改勝利畫面的按鈕文本
                const victoryResetBtn = document.getElementById('victory-reset');
                if (victoryResetBtn) {
                    victoryResetBtn.textContent = '重試本關';

                    // 克隆按鈕並替換以移除所有事件監聽器
                    const newBtn = victoryResetBtn.cloneNode(true);
                    if (victoryResetBtn.parentNode) {
                        victoryResetBtn.parentNode.replaceChild(newBtn, victoryResetBtn);
                    }

                    // 添加新的點擊事件
                    newBtn.onclick = () => {
                        if (victoryOverlay) {
                            victoryOverlay.classList.remove('show');
                        }
                        this.retryLevel();
                    };
                }
            },

            // 進入下一關
            nextLevel: function() {
                console.log("進入下一關");
    
                // 隱藏勝利畫面
                if (victoryOverlay) {
                    victoryOverlay.classList.remove('show');
                }
    
                // 顯示加載界面
                const loadingOverlay = document.getElementById('csv-loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                    const loadingMessage = document.getElementById('csv-loading-message');
                    if (loadingMessage) {
                        loadingMessage.textContent = "正在載入第二關數據...";
                    }
                }
    
                // 根據當前關卡ID決定載入哪個CSV文件
                let nextCsvUrl = "";
                if (this.currentLevel === 1) {
                    // 從第一關到第二關
                    nextCsvUrl = "./stages/SRWCStage02.csv";
                } else if (this.currentLevel === 2) {
                    // 从第二关到第三关
                    nextCsvUrl = "./stages/SRWCStage03.csv";
                } else if (this.currentLevel === 3) {
                    // 从第三关到第四关
                    nextCsvUrl = "./stages/SRWCStage04.csv";
                } else {
                    // 其他情況（未來可能的第五關等）
                    this.showComingSoonMessage();
                    return;
                }
    
                // 載入下一關的CSV
                loadLevelsFromURL(nextCsvUrl).then(success => {
                    if (success) {
                        // 更新加載消息
                        const loadingMessage = document.getElementById('csv-loading-message');
                        if (loadingMessage) {
                            loadingMessage.textContent = "正在預載圖片資源...";
                        }
            
                        // 預載圖片
                        console.log("開始預載圖片...");
                        const imagesToLoad = getAllImageURLsFromLevelData();
                        preloadImages(imagesToLoad).then(() => {
                            // 隱藏加載界面
                            if (loadingOverlay) {
                                loadingOverlay.style.display = 'none';
                            }
                
                            // 清理當前遊戲狀態
                            gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                            gameState.blueCaptured = [];
                            gameState.redCaptured = [];
                            gameState.currentTurn = BLUE;
                            gameState.selectedPiece = null;
                            gameState.validMoves = [];
                            gameState.gameOver = false;
                            gameState.winner = null;
                            gameState.turnCount = 0;
                
                            // 更新UI
                            updateBoardDisplay();
                            updateCapturedPieces();
                            updateTurnIndicator();
                            updateTurnCountDisplay();
                
                            // 載入第二關
                            const nextLevelId = window.levelData.length > 0 ? window.levelData[0].id : 1;
                            this.loadLevel(nextLevelId);
                        });
                    } else {
                        // 載入失敗
                        console.error("無法載入下一關數據");
                        this.showComingSoonMessage();
                    }
                }).catch(error => {
                    console.error("載入下一關時出錯:", error);
                    this.showComingSoonMessage();
                });
            },

            // 顯示"敬請期待"的消息
            showComingSoonMessage: function() {
                // 創建一個符合遊戲風格的"敬請期待"彈窗
                const comingSoonHTML = `
                <div id="coming-soon-overlay" class="fixed inset-0 bg-black bg-opacity-80 z-[500] flex items-center justify-center opacity-0 transition-opacity duration-500">
                    <div class="relative max-w-md w-full bg-gradient-to-b from-gray-900 to-gray-800 rounded-lg p-6 text-white overflow-hidden shadow-2xl transform transition-all duration-500 scale-95">
                        <div class="absolute inset-0 overflow-hidden opacity-20">
                            <div class="stars-bg absolute inset-0"></div>
                        </div>

                        <div class="relative z-10">
                            <div class="text-center mb-6">
                                <h2 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 inline-block">敬請期待</h2>
                            </div>

                            <div class="flex justify-center mb-6">
                                <div class="w-24 h-24 rounded-full bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center animate-pulse">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-14 w-14 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                    </svg>
                                </div>
                            </div>

                            <p class="text-center text-gray-300 mb-6">第二話正在開發中，敬請期待後續更新！</p>

                            <div class="flex justify-center">
                                <button id="coming-soon-btn" class="px-6 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-full font-semibold transition transform hover:scale-105 hover:shadow-lg focus:outline-none">
                                    返回主畫面
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                `;

                // 添加彈窗到頁面
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = comingSoonHTML;
                const comingSoonOverlay = tempDiv.firstElementChild;
                document.body.appendChild(comingSoonOverlay);

                // 設置按鈕事件
                const comingSoonBtn = document.getElementById('coming-soon-btn');
                if (comingSoonBtn) {
                    comingSoonBtn.addEventListener('click', () => {
                        // 淡出彈窗
                        comingSoonOverlay.style.opacity = '0';
                        comingSoonOverlay.querySelector('div[class*="scale-95"]').classList.add('scale-90');

                        // 延遲後移除彈窗並返回主畫面
                        setTimeout(() => {
                            if (comingSoonOverlay.parentNode) {
                                comingSoonOverlay.parentNode.removeChild(comingSoonOverlay);
                            }
                            // 返回標題畫面
                            resetGame();
                            showCoverPage();
                        }, 500);
                    });
                }

                // 延遲顯示彈窗，創造淡入效果
                setTimeout(() => {
                    comingSoonOverlay.style.opacity = '1';
                    comingSoonOverlay.querySelector('div[class*="scale-95"]').classList.remove('scale-95');
                }, 50);
            },

            // 重試當前關卡
            retryLevel: function() {
                console.log("重試當前關卡");
                this.loadLevel(this.currentLevel);
            },

            // 顯示遊戲通關畫面
            showGameComplete: function() {
                // 這裡可以實現遊戲通關後的畫面
                alert("恭喜你! 已完成所有關卡!");

                // 返回標題畫面
                resetGame();
                showCoverPage();
            }
        };

        // 事件系統 - 重構為更通用的模組化結構
        const eventSystem = {
            // 事件存儲：按類型分類
            events: {},

            // 動作處理器註冊表
            actionHandlers: {},

            // 初始化事件系統
            init: function() {
                console.log("初始化事件系統");
                // 清空事件和處理器
                this.events = {};
                this.actionHandlers = {};

                // 註冊標準事件類型
                this.registerEventType("turnStart");
                this.registerEventType("pieceMove");
                this.registerEventType("pieceCaptured");

                // 註冊標準動作處理器
                this.registerActionHandler("spawnPiece", this.handleSpawnPieceAction);
                this.registerActionHandler("showMission", this.handleShowMissionAction);
                this.registerActionHandler("replacePiece", this.handleReplacePieceAction);
                // 已移除註冊spawnAngelGundam處理器

                console.log("事件系統初始化完成");
                return this;
            },

            // 註冊事件類型
            registerEventType: function(eventType) {
                if (!this.events[eventType]) {
                    this.events[eventType] = [];
                }
                return this;
            },

            // 清除所有事件
            clearEvents: function() {
                for (const eventType in this.events) {
                    this.events[eventType] = [];
                }
                return this;
            },

            // 從關卡數據加載事件
            loadEventsFromLevel: function(levelEvents) {
                console.log("從關卡加載事件");
                this.clearEvents();

                if (!levelEvents || levelEvents.length === 0) {
                    console.log("關卡沒有定義事件");
                    return this;
                }

                levelEvents.forEach((event, index) => {
                    const success = this.registerEvent(event);
                    console.log(`註冊事件 ${index + 1}/${levelEvents.length}: ${success ? '成功' : '失敗'}`);
                });

                return this;
            },

            // 註冊單個事件
            registerEvent: function(event) {
                if (!event || !event.type) {
                    console.error("無效的事件定義:", event);
                    return false;
                }

                // 確保事件類型已註冊
                if (!this.events[event.type]) {
                    this.registerEventType(event.type);
                }

                // 檢查事件動作是否有效
                if (!event.action || !event.action.type) {
                    console.error("事件缺少有效的動作:", event);
                    return false;
                }

                // 確保動作類型已註冊處理器
                if (!this.actionHandlers[event.action.type]) {
                    console.warn(`未註冊的動作類型 '${event.action.type}', 但仍會註冊事件`);
                }

                // 添加事件
                this.events[event.type].push(event);
                return true;
            },

            // 註冊動作處理器
            registerActionHandler: function(actionType, handlerFunction) {
                if (typeof handlerFunction !== 'function') {
                    console.error(`Invalid handler for action type '${actionType}'`);
                    return this;
                }

                this.actionHandlers[actionType] = handlerFunction;
                return this;
            },

            // 觸發事件
            triggerEvent: function(eventType, context) {
                if (!eventType || !this.events[eventType]) {
                    console.log(`没有找到${eventType}类型的事件`);
                    return;
                }

                console.log(`觸發事件類型: ${eventType}`, context || {});
                console.log(`该事件类型存在${this.events[eventType].length}个事件处理程序`);

                const eventsToRemove = [];

                this.events[eventType].forEach((event, index) => {
                    console.log(`检查事件${index+1}的条件:`, event.condition);
                    // 檢查事件條件
                    if (this.checkEventCondition(event, context)) {
                        console.log(`事件${index+1}条件满足, 執行動作: ${event.action.type}`);
                        // 執行事件動作
                        this.executeAction(event.action, context);

                        // 如果事件只觸發一次，標記為移除
                        if (event.once) {
                            eventsToRemove.push(index);
                        }
                      } else {
                        console.log(`事件${index+1}条件不满足, 期望team=${event.condition.team}, pieceId=${event.condition.pieceId}, 位置[${event.condition.row},${event.condition.col}]`);

                        let actualTeam = '未知';
                        let actualPieceId = '未知';

                        if (context) {
                            if (context.team) actualTeam = context.team;
                            else if (context.piece && context.piece.team) actualTeam = context.piece.team;
                            else if (context.capturedPiece && context.capturedPiece.team) actualTeam = context.capturedPiece.team;
                            else if (context.capturingPiece && context.capturingPiece.team) actualTeam = context.capturingPiece.team;

                            if (context.piece && context.piece.id) actualPieceId = context.piece.id;
                            else if (context.capturedPiece && context.capturedPiece.id) actualPieceId = context.capturedPiece.id;
                            else if (context.capturingPiece && context.capturingPiece.id) actualPieceId = context.capturingPiece.id;
                        }

                        console.log(`实际team=${actualTeam}, pieceId=${actualPieceId}, 位置[${context ? context.row : undefined},${context ? context.col : undefined}]`);
                      }
                });

                // 從後向前刪除標記的事件
                for (let i = eventsToRemove.length - 1; i >= 0; i--) {
                    this.events[eventType].splice(eventsToRemove[i], 1);
                }
            },

            // 檢查事件條件
            checkEventCondition: function(event, context) {
                // 如果沒有條件，則視為條件滿足
                if (!event.condition) return true;

                const condition = event.condition;

                // 條件是一個物件，包含多個屬性作為條件
                if (typeof condition === 'object') {
                    let allConditionsMet = true;

                    // 檢查回合數條件
                    if ('turn' in condition) {
                        if (!gameState) return false;
                        if (gameState.turnCount !== condition.turn) {
                            allConditionsMet = false;
                        }
                    }

                    // 檢查隊伍條件
                    if ('team' in condition) {
                        // 檢查所有可能的隊伍位置
                        let teamMatched = false;
                        if (context) {
                            if (context.team === condition.team) {
                                teamMatched = true;
                            } else if (context.piece && context.piece.team === condition.team) {
                                teamMatched = true;
                            } else if (context.capturedPiece && context.capturedPiece.team === condition.team) {
                                teamMatched = true;
                            } else if (context.capturingPiece && context.capturingPiece.team === condition.team) {
                                teamMatched = true;
                            }
                        }

                        if (!teamMatched) {
                            allConditionsMet = false;
                        }
                    }

                    // 检查棋子ID条件
                    if ('pieceId' in condition) {
                        // 檢查各種可能的棋子ID位置
                        let pieceIdMatched = false;
                        if (context) {
                           // 对于 pieceCaptured 事件，只检查 capturedPiece
                            if (event.type === 'pieceCaptured') {
                                // 只检查被捕获的棋子ID，不检查攻击方ID
                                if (context.capturedPiece && context.capturedPiece.id === condition.pieceId) {
                                    pieceIdMatched = true;
                                }
                            }
                        }

                        if (!pieceIdMatched) {
                            allConditionsMet = false;
                        }
                    }

                    // 檢查位置條件
                    if ('row' in condition && 'col' in condition) {
                        if (!context || context.row !== condition.row || context.col !== condition.col) {
                            allConditionsMet = false;
                        }
                    }

                    // 自訂條件處理器（如果存在）
                    if ('custom' in condition && typeof condition.custom === 'function') {
                        if (!condition.custom(context, gameState)) {
                            allConditionsMet = false;
                        }
                    }

                    return allConditionsMet;
                }

                // 其他條件類型的處理可以擴展...

                return true; // 默認條件滿足
            },

            // 執行動作
            executeAction: function(action, context) {
                if (!action || !action.type) {
                    console.error("無效的動作:", action);
                    return;
                }

                const handler = this.actionHandlers[action.type];

                if (!handler) {
                    console.error(`未找到動作處理器: ${action.type}`);
                    return;
                }

                try {
                    // 使用綁定的this調用處理器
                    handler.call(this, action, context);
                } catch (error) {
                    console.error(`執行動作 ${action.type} 時發生錯誤:`, error);
                }
            },

            // ==== 動作處理器 ====

            // 生成棋子動作 - 增強版
            handleSpawnPieceAction: function(action, context) {
                console.log("執行生成棋子動作:", action);
                const { pieceId, position, special, aimRow, aimCol } = action;

                if (!pieceId) {
                    console.error("生成棋子動作缺少必要參數 pieceId:", action);
                    return;
                }

                // 如果提供了position，直接生成棋子
                if (position && Array.isArray(position) && position.length === 2) {
                    // 檢查是否需要特殊效果
                    if (special) {
                        this.spawnPieceWithSpecialEffect(pieceId, position, action, context);
                    } else {
                        this.spawnPiece(pieceId, position, context);
                    }
                    return;
                }

                // 如果没有提供position，嘗試找到最佳位置
                if (typeof aimRow === 'number' && typeof aimCol === 'number') {
                    const targetPosition = [aimRow, aimCol];

                    // 检查目标位置是否已被占用
                    if (gameState.board[aimRow][aimCol] !== null) {
                        console.warn('已被佔用:', targetPosition);
                        // 目标位置被占用，寻找替代位置
                        if (action.findBestPosition) {
                            const bestPosition = this.findBestPositionForPiece(pieceId, action);
                            if (bestPosition) {
                                console.log(`位置 [${aimRow},${aimCol}] 已被佔用，改為使用最佳位置: [${bestPosition[0]},${bestPosition[1]}]`);
                                if (special) {
                                    this.spawnPieceWithSpecialEffect(pieceId, bestPosition, action, context);
                                } else {
                                    this.spawnPiece(pieceId, bestPosition, context);
                                }
                            } else {
                                console.error(`無法為 ${pieceId} 找到合適的生成位置`);
                            }
                        } else {
                            console.error(`目標位置 [${aimRow},${aimCol}] 已被佔用，且未啟用自動尋找位置`);
                        }
                    } else {
                        // 目标位置未被占用，直接生成
                        if (special) {
                            this.spawnPieceWithSpecialEffect(pieceId, targetPosition, action, context);
                        } else {
                            this.spawnPiece(pieceId, targetPosition, context);
                        }
                    }
                      return;
                }


                if (action.findBestPosition) {
                    const bestPosition = this.findBestPositionForPiece(pieceId, action);
                    if (bestPosition) {
                        if (special) {
                            this.spawnPieceWithSpecialEffect(pieceId, bestPosition, action, context);
                        } else {
                            this.spawnPiece(pieceId, bestPosition, context);
                        }
                    } else {
                        console.error(`無法為 ${pieceId} 找到合適的生成位置`);
                    }
                    return;
                }

                console.error("生成棋子動作缺少位置參數，且未啟用自動尋找位置:", action);
            },

            // 顯示任務提示動作
            handleShowMissionAction: function(action, context) {
                console.log("執行顯示任務提示動作:", action);
                const { text } = action;

                if (!text) {
                    console.error("任務提示動作缺少必要參數:", action);
                    return;
                }

                this.showMissionPopup(text);
            },

            // 添加替换棋子动作处理器
            handleReplacePieceAction: function(action, context) {
                console.log("执行替换棋子动作:", action);
                const { position, pieceId, row, col, targetPieceId, special } = action;
                
                // 确定要替换的棋子位置
                let targetRow, targetCol;

                // 如果直接提供了位置
                if (position && Array.isArray(position) && position.length === 2) {
                    [targetRow, targetCol] = position;
                }
                // 如果提供了行列
                else if (typeof row === 'number' && typeof col === 'number') {
                    targetRow = row;
                    targetCol = col;
                }
                // 如果上下文提供了位置
                else if (context && typeof context.row === 'number' && typeof context.col === 'number') {
                    targetRow = context.row;
                    targetCol = context.col;
                }
                // 搜索棋子ID
                else if (targetPieceId) {
                    const foundPosition = this.findPiecePosition(targetPieceId);
                    if (foundPosition) {
                        [targetRow, targetCol] = foundPosition;
                    } else {
                        console.error(`未找到ID为 ${targetPieceId} 的棋子，无法执行替换`);
                        return;
                    }
                } else {
                    console.error("替换棋子动作缺少有效位置参数:", action);
                    return;
                }

                // 验证位置有效性
                if (targetRow < 0 || targetRow >= BOARD_SIZE || targetCol < 0 || targetCol >= BOARD_SIZE) {
                    console.error(`无效的替换位置: [${targetRow},${targetCol}]`);
                    return;
                }

                // 保存原位置棋子信息，用于后续替换和效果显示
                const originalPiece = gameState.board[targetRow][targetCol];
                if (!originalPiece) {
                    console.warn(`位置 [${targetRow},${targetCol}] 没有棋子可替换`);
                    // 如果没有原棋子，则直接在该位置生成新棋子
                    if (special) {
                        this.spawnPieceWithSpecialEffect(pieceId, [targetRow, targetCol], action, context);
                    } else {
                        this.spawnPiece(pieceId, [targetRow, targetCol], context);
                    }
                    return;
                }

                // 从棋盘上移除原棋子
                gameState.board[targetRow][targetCol] = null;

                // 触发棋子移除事件
                this.triggerEvent('pieceRemoved', {
                    piece: originalPiece,
                    row: targetRow,
                    col: targetCol
                });

                // 生成新棋子到同一位置
                if (special) {
                // 使用特效生成
                    const replacementAction = {
                        ...action,
                        originalPiece: originalPiece // 传递原棋子信息
                    };
                    this.spawnPieceWithSpecialEffect(pieceId, [targetRow, targetCol], replacementAction, context);
                } else {
                    // 普通生成
                    this.spawnPiece(pieceId, [targetRow, targetCol], context);
                }

                if (action.pieceId === 'fa_gundam') {
                    console.log("FA Gundam has been unlocked!");
                    Get_fa_gundam = 1;
                }
                
                // 更新棋盘显示
                updateBoardDisplay();
            },

            // 辅助函数：查找棋子位置
            findPiecePosition: function(pieceId) {
                if (!gameState || !gameState.board) return null;

                // 在棋盘上查找指定ID的棋子
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.id === pieceId) {
                            return [row, col];
                        }
                    }
                }

                return null; // 未找到棋子
            },

            // 已移除生成天使高達特殊動作處理器

            // ==== 動作實現函數 ====

            // 生成棋子 - 從關卡定義讀取棋子數據
            spawnPiece: function(pieceId, position, context) {
                if (!gameState || !BOARD_SIZE) {
                    console.error('遊戲狀態不可用');
                    return;
                }

                const [row, col] = position;

                // 檢查位置是否有效
                if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                    console.error('無效的棋子位置:', position);
                    return;
                }

                // 檢查該位置是否為空
                if (gameState.board[row][col] !== null) {
                    console.warn('目標位置已被佔用:', position);
                    return;
                }

                // 從當前關卡獲取棋子定義
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions) {
                    console.error(`無法找到關卡 ${levelManager.currentLevel} 的機體定義`);
                    return;
                }

                const levelPieceDefinitions = currentLevelData.pieceDefinitions;

                // 檢查棋子定義是否存在
                if (!levelPieceDefinitions[pieceId]) {
                    console.error(`在關卡 ${levelManager.currentLevel} 中未定義的棋子ID: ${pieceId}`);
                    return;
                }

                const pieceDefinition = levelPieceDefinitions[pieceId];

                // 創建棋子實例
                gameState.board[row][col] = {
                    id: pieceId,
                    team: pieceDefinition.team,
                    type: pieceDefinition.type,
                    moveType: pieceDefinition.moveType,
                    imgUrl: pieceDefinition.imgUrl,
                    hit: pieceDefinition.hit,
                    dodge: pieceDefinition.dodge,
                    bgmtype: pieceDefinition.bgmtype,
                    weapon_colour: pieceDefinition.weapon_colour,
                    crosshairType: pieceDefinition.crosshairType,
                    hasMoved: false
                };

                // 觸發棋子生成事件
                this.triggerEvent('pieceSpawned', {
                    piece: gameState.board[row][col],
                    row: row,
                    col: col
                });

                // 更新棋盤顯示
                updateBoardDisplay();
            },

            // 在 spawnPieceWithSpecialEffect 函数中添加针对替换的处理
            spawnPieceWithSpecialEffect: function(pieceId, position, action, context) {
                console.log("使用特殊效果生成棋子:", pieceId, "在位置", position);

                // 获取坐标位置的字母数字表示（如A1、B2等）
                const row = position[0];
                const col = position[1];
                const colLetter = String.fromCharCode(65 + col); // A, B, C...
                const rowNumber = 8 - row; // 1, 2, 3...
                const positionText = `${colLetter}${rowNumber}`;

                // 从当前关卡获取棋子定义
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions || !currentLevelData.pieceDefinitions[pieceId]) {
                    console.error(`无法找到棋子 ${pieceId} 的定义`);
                    return;
                }

                const pieceDefinition = currentLevelData.pieceDefinitions[pieceId];

                // 检查是否为替换操作
                const isReplacement = action.originalPiece !== undefined;
                let replacementHTML = '';

                if (isReplacement) {
                    // 添加原棋子信息的显示
                    const originalPiece = action.originalPiece;
                    replacementHTML = `
                    <div class="flex justify-center items-center space-x-4 my-4">
                        <div class="flex flex-col items-center">
                            <img src="${originalPiece.imgUrl}" alt="${originalPiece.type}" class="w-16 h-16 object-contain mb-2">
                            <span class="text-sm text-gray-400">原始棋子</span>
                        </div>
                        <div class="flex items-center text-yellow-500">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                            </svg>
                        </div>
                        <div class="flex flex-col items-center">
                            <img src="${pieceDefinition.imgUrl}" alt="${pieceDefinition.type}" class="w-16 h-16 object-contain mb-2">
                            <span class="text-sm text-gray-400">新棋子</span>
                        </div>
                    </div>
                    `;
                }

                // 创建特殊效果HTML
                const specialEffectHTML = `
                <div id="special-piece-confirm-overlay" class="angel-confirm-overlay">
                    <div class="angel-confirm-card" style="position: absolute; top: 10%; left: 50%; transform: translateX(-50%);">
                        <div class="angel-header">
                            <img src="${pieceDefinition.imgUrl}" alt="${pieceDefinition.type}" class="angel-image">
                        </div>
                        <h2 class="angel-title">${action.title || pieceDefinition.type + '已出现！'}</h2>
                        <p class="angel-desc">${action.description || (isReplacement ? '棋子已被替换，位置在' : '一台新的机体出现在战场上，位置在')}<span style="color:#5D5CDE;font-weight:bold;">${positionText}</span>。</p>

                        ${replacementHTML}

                        <div class="angel-stats">
                            <div class="angel-stat angel-stat-type">
                                <span class="stat-label">类型</span>
                                <span class="stat-value">${this.getMoveTypeText(pieceDefinition.moveType)}</span>
                            </div>
                            <div class="angel-stat angel-stat-hit">
                                <span class="stat-label">命中</span>
                                <span class="stat-value">${pieceDefinition.hit}</span>
                            </div>
                            <div class="angel-stat angel-stat-dodge">
                                <span class="stat-label">回避</span>
                                <span class="stat-value">${pieceDefinition.dodge}</span>
                            </div>
                        </div>

                        <button id="special-piece-confirm-btn" class="angel-confirm-btn">${action.buttonText || '确认'}</button>
                    </div>
                </div>
                `;

                // 添加特殊效果視窗到頁面
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = specialEffectHTML;
                document.body.appendChild(tempDiv.firstElementChild);

                // 獲取確認視窗元素
                const confirmOverlay = document.getElementById('special-piece-confirm-overlay');
                const confirmBtn = document.getElementById('special-piece-confirm-btn');

                // 暫停遊戲操作
                const disableGameInteraction = () => {
                    const chessCells = document.querySelectorAll('.chess-cell');
                    chessCells.forEach(cell => {
                        cell.style.pointerEvents = 'none';
                    });
                };

                // 恢復遊戲操作
                const enableGameInteraction = () => {
                    const chessCells = document.querySelectorAll('.chess-cell');
                    chessCells.forEach(cell => {
                        cell.style.pointerEvents = 'auto';
                    });
                };

                // 顯示確認視窗前暫停遊戲操作
                disableGameInteraction();

                // 顯示確認視窗
                confirmOverlay.classList.add('show');
                setTimeout(() => {
                    const card = confirmOverlay.querySelector('.angel-confirm-card');
                    if (card) card.style.opacity = '1';
                }, 50);

                // 設置確認按鈕點擊事件
                const handleConfirmClick = () => {
                    // 隱藏確認視窗
                    confirmOverlay.classList.remove('show');
                    const card = confirmOverlay.querySelector('.angel-confirm-card');
                    if (card) card.style.opacity = '0';

                    // 恢復遊戲操作
                    enableGameInteraction();

                    // 實際生成棋子
                    this.spawnPiece(pieceId, position, context);

                    // 如果設置了確認後的動作，執行它
                    if (action.onConfirm) {
                        try {
                            action.onConfirm(context);
                        } catch (error) {
                            console.error("執行確認後動作出錯:", error);
                        }
                    }

                    // 移除事件監聽器和彈窗
                    if (confirmBtn) {
                        confirmBtn.removeEventListener('click', handleConfirmClick);
                    }
                    setTimeout(() => {
                        if (confirmOverlay && confirmOverlay.parentNode) {
                            confirmOverlay.parentNode.removeChild(confirmOverlay);
                        }
                    }, 500);
                };

                // 添加確認按鈕點擊事件
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', handleConfirmClick);
                }
            },

            // 獲取移動類型的中文名稱
            getMoveTypeText: function(moveType) {
                switch(moveType) {
                    case PAWN: return "步兵型";
                    case ROOK: return "城堡型";
                    case KNIGHT: return "騎士型";
                    case BISHOP: return "主教型";
                    case QUEEN: return "皇后型";
                    case KING: return "國王型";
                    default: return "未知類型";
                }
            },

            // 尋找最佳位置生成棋子
            findBestPositionForPiece: function(pieceId, options) {
                console.log("尋找最佳位置生成棋子:", pieceId);
                if (!gameState || !BOARD_SIZE) {
                    console.error('遊戲狀態不可用');
                    return null;
                }

                // 獲取棋子隊伍以確定搜索方向
                const currentLevelData = window.levelData.find(level => level.id === levelManager.currentLevel);
                if (!currentLevelData || !currentLevelData.pieceDefinitions || !currentLevelData.pieceDefinitions[pieceId]) {
                    console.error(`無法找到棋子 ${pieceId} 的定義`);
                    return null;
                }

                const pieceTeam = currentLevelData.pieceDefinitions[pieceId].team;

                // 根據隊伍和選項確定優先搜索的行
                let preferredRow = options && options.preferredRow !== undefined ? options.preferredRow : null;

                if (preferredRow === null) {
                    // 如果沒有指定，藍隊優先在第七行，紅隊優先在第二行
                    preferredRow = pieceTeam === BLUE ? 6 : 1;
                }

                // 在優先行尋找空位
                let availablePositions = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (!gameState.board[preferredRow][col]) {
                        availablePositions.push([preferredRow, col]);
                    }
                }

                // 如果優先行有空位，選擇距離中央最近的
                if (availablePositions.length > 0) {
                    const centerCol = 3.5; // 中間位置在3和4之間
                    let bestPosition = null;
                    let minDistance = Infinity;

                    for (const pos of availablePositions) {
                        const col = pos[1];
                        const distance = Math.abs(col - centerCol);

                        if (distance < minDistance) {
                            minDistance = distance;
                            bestPosition = pos;
                        }
                    }

                    return bestPosition;
                }

                // 如果優先行沒有空位，在整個棋盤上尋找最適合的位置
                const centerRow = 3.5;
                const centerCol = 3.5;
                let closestPosition = null;
                let minDistance = Infinity;

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (!gameState.board[row][col]) {
                            // 計算到中心的距離
                            const distance = Math.sqrt(
                                Math.pow(row - centerRow, 2) +
                                Math.pow(col - centerCol, 2)
                            );

                            if (distance < minDistance) {
                                minDistance = distance;
                                closestPosition = [row, col];
                            }
                        }
                    }
                }

                return closestPosition;
            },

            // 顯示任務提示框
            showMissionPopup: function(text) {
                const missionPopup = document.getElementById('mission-popup');
                const missionDesc = document.getElementById('mission-desc');

                if (!missionPopup || !missionDesc) {
                    console.error('任務提示框元素不存在');
                    return;
                }

                // 設置文本並顯示
                missionDesc.textContent = text;
                missionPopup.classList.add('show');

                // 五秒後自動隱藏
                setTimeout(() => {
                    missionPopup.classList.remove('show');
                }, 5000);
            }
        };

        // 顯示序章頁面
        function showPrologue() {
            // 添加序章頁面到DOM
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = prologueHTML;
            const prologueOverlay = tempDiv.firstElementChild;
            document.body.appendChild(prologueOverlay);

            // 設置繼續按鈕事件
            const prologueContinueBtn = document.getElementById('prologue-continue-btn');
            if (prologueContinueBtn) {
                prologueContinueBtn.addEventListener('click', () => {
                    // 淡出序章
                    prologueOverlay.style.opacity = '0';

                    // 延遲後移除序章並顯示第一關
                    setTimeout(() => {
                        if (prologueOverlay.parentNode) {
                            prologueOverlay.parentNode.removeChild(prologueOverlay);
                        }

                        // 初始化並顯示第一關
                        if (levelManager) {
                            levelManager.loadLevel(1);
                        } else {
                            console.error('關卡管理器未初始化');
                            // 回退到默認行為
                            gameUI.style.display = 'block';
                            initializeGame();
                        }
                    }, 500);
                });
            }

            // 顯示序章（淡入效果）
            setTimeout(() => {
                prologueOverlay.style.opacity = '1';
                const card = prologueOverlay.querySelector('div[class*="scale-95"]');
                if (card) card.classList.remove('scale-95');
            }, 50);
        }

        // 設置頁面按鈕事件
        function setupButtonEvents() {
            // 設置界面
            document.getElementById('settings-cover-btn').onclick = function() {
                document.getElementById('settings-overlay').style.opacity = '1';
                document.getElementById('settings-overlay').style.pointerEvents = 'auto';
            };

            document.getElementById('settings-close-btn').onclick = function() {
                document.getElementById('settings-overlay').style.opacity = '0';
                document.getElementById('settings-overlay').style.pointerEvents = 'none';
            };
        }

        // 在DOM加载完成后添加事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 保存进度按钮
            const saveProgressBtn = document.getElementById('save-progress-btn');
            if (saveProgressBtn) {
                saveProgressBtn.addEventListener('click', saveProgress);
            }
    
            // 载入进度按钮
            const loadProgressBtn = document.getElementById('load-progress-btn');
            if (loadProgressBtn) {
                loadProgressBtn.addEventListener('click', loadProgress);
            }
        });

        // 從URL加載關卡
        async function loadLevelsFromURL(url) {
            // 顯示加載界面
            const loadingOverlay = document.getElementById('csv-loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                // 獲取和解析CSV數據
                const csvText = await fetchCSVFromURL(url);
                const csvEntries = parseCSV(csvText);
                const levels = createLevelsFromCSV(csvEntries);

                // 替換全局關卡數據
                if (levels.length > 0) {
                    window.levelData = levels;
                    console.log("成功從URL加載關卡數據");
                    return true;
                } else {
                    throw new Error("解析CSV後沒有獲得有效的關卡數據");
                }
            } catch (error) {
                console.error("加載關卡數據失敗:", error);
                // 顯示錯誤訊息
                document.getElementById('csv-loading-message').textContent = "加載關卡數據失敗: " + error.message;
                // 5秒後隱藏加載界面
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 5000);
                return false;
            } finally {
                // 從這裡移除加載界面顯示，在成功情況下調用者會處理
            }
        }

        // Main code
        // Set up cover page
        setupSpaceBackground(document.getElementById('cover-space-bg'));

        // Set up buttons
        setupButtonEvents();

        // Update document title with loading time
        document.title = `超級機械人大戰Chess - ${Date.now() - window.gameLoadStartTime}ms`;

        // 單人遊戲按鈕事件
        singleplayerBtn.onclick = async function(e) {
            // 防止事件冒泡
            e.preventDefault();
            e.stopPropagation();

            // 播放介紹音樂
            playIntroMusic();

            // 指定CSV URL
            const csvUrl = "./stages/SRWCStage01.csv";

            // 隱藏封面頁面
            coverPage.classList.add('hide');

            // 顯示加載界面
            document.getElementById('csv-loading-overlay').style.display = 'flex';
            document.getElementById('csv-loading-message').textContent = "正在從外部數據源獲取關卡信息...";

            try {
                // 加載關卡數據
                const success = await loadLevelsFromURL(csvUrl);

                if (success) {
                    // 更新加載消息
                    document.getElementById('csv-loading-message').textContent = "正在預載圖片資源...";

                    // 預載圖片
                    console.log("開始預載圖片...");
                    const imagesToLoad = getAllImageURLsFromLevelData();
                    await preloadImages(imagesToLoad);

                    // 隱藏加載界面
                    document.getElementById('csv-loading-overlay').style.display = 'none';

                    // 創建遊戲棋盤
                    createBoard();

                    // 初始化事件系統
                    if (typeof eventSystem !== 'undefined' && typeof eventSystem.init === 'function') {
                        eventSystem.init();
                    }

                    // 顯示序章
                    showPrologue();
                } else {
                    throw new Error("加載關卡數據失敗");
                }
            } catch (error) {
                console.error("處理失敗:", error);

                // 顯示錯誤消息
                const loadingMessage = document.getElementById('csv-loading-message');
                if (loadingMessage) loadingMessage.textContent = "錯誤: " + error.message;

                // 延遲後返回主畫面
                setTimeout(() => {
                    document.getElementById('csv-loading-overlay').style.display = 'none';
                    coverPage.classList.remove('hide');
                }, 3000);
            }

            return false;
        };
    </script>
</body>
</html>
